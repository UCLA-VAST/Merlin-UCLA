#if 0
// get all the function decls with body
void CSageCodeGen::GetAllFuncDeclToCall(
    const set<void *> &func_decls, map<void *, vector<void *>> &func2calls) {

  for (auto decl : func_decls) {
    GetFuncCallsFromDecl(decl, nullptr, func2calls[decl]);
  }
  return;
}
#endif
#if 0
vector<void *> CSageCodeGen::GetAllFuncCallByName(string sFuncName) {
  vector<void *> vecCallOut;
  size_t j;
  vector<void *> vecCall;
  GetNodesByType_int(m_sg_project, "preorder", V_SgFunctionCallExp, &vecCall);
  for (j = 0; j < vecCall.size(); j++) {
    if (GetFuncNameByCall(vecCall[j]) == sFuncName)
      vecCallOut.push_back(vecCall[j]);
  }
  return vecCallOut;
}
#endif
// Cautious: return -1 if unknown
// can not use now
/*
bool CSageCodeGen::isSameType(void *type1_, void *type2_) {
#if 0
    assert(0);
    return 0;
#else

  //    void * type1;
  //    void * type2;
  //    int ret1 = RemoveTypedef(type1_, type1, type1_); //ZP: 202170320:
  //    RemoveTypedef does not clear on the return value: even primitive types
  //    return 0 int ret2 = RemoveTypedef(type1_, type1, type1_); if (ret1 == 0
  //    || ret2 == 0) return -1;
  void *type1 = type1_;
  void *type2 = type2_;

  // FIXME: ZP: 20160920
  // This function is not supported in the current ROSE version
  return SageInterface::isEquivalentType((SgType *)type1, (SgType *)type2);
#endif
}
*/
#if 0
vector<void *> CSageCodeGen::GetAllFuncDeclByCall(void *sg_func_call_,
                                                  int require_body /* = 0*/) {
  vector<void *> vecDeclOut;
  if (!isSgFunctionCallExp((SgNode *)sg_func_call_))
    return vecDeclOut;
  void *decl = GetAssociatedFuncDeclByCall(sg_func_call_);
  if (!decl)
    return vecDeclOut;
  return GetAllFuncDeclByName(GetFuncName(decl), require_body);
}
#endif

#if 0
void *CSageCodeGen::GetFuncReturnTypeByCall(void *sg_func_call_) {
  void *sg_func_decl = GetFuncDeclByCall(sg_func_call_, 0);
  return GetFuncReturnType(sg_func_decl);
}

//////////////////////////////////
// ZP: 20150624
// This is an inital implementation of range analysis
// Now it is just used for constant integer value
// It is to be extended to support range later
int CSageCodeGen::get_expression_bound_integer(void *sg_exp, int &upper,
                                               int &lower) {
  //    map<string, int> mapVar2Coeff;
  //    int ret = analyze_linear_expression(sg_exp, mapVar2Coeff);
  //    if (!ret) return 0;
  //
  //    // check if it is constant
  //    int const_term = 0;
  //    map<string, int>::iterator it;
  //    for (it = mapVar2Coeff.begin(); it != mapVar2Coeff.end(); it++)
  //    {
  //       if (it->first != "1" && it->second != 0) return 0;
  //       if (it->first == "1") const_term = it->second;
  //    }

  if (isSgIntVal((SgNode *)sg_exp)) {
    upper = lower = isSgIntVal((SgNode *)sg_exp)->get_value();
    return 1;
  }
  if (isSgLongIntVal((SgNode *)sg_exp)) {
    upper = lower = isSgLongIntVal((SgNode *)sg_exp)->get_value();
    return 1;
  }
  if (isSgLongLongIntVal((SgNode *)sg_exp)) {
    upper = lower = isSgLongLongIntVal((SgNode *)sg_exp)->get_value();
    return 1;
  }

  int const_term;

  // FIXME: ZP 20150824: Please use a real position indicator here instead of
  // projedct
  CMarsExpression me(sg_exp, this, m_sg_project);
  if (me.IsConstant())
    const_term = me.GetConstant();
  else
    return 0;

  upper = lower = const_term;
  return 1;
}

int CSageCodeGen::analyze_linear_expression(void *sg_exp,
                                            map<string, int> &mapVar2Coeff) {

  //    assert(0);
  PolyVector poly_out;

  int ret = Expr2Vector(sg_exp, poly_out);

  // cout << "codegen print " << UnparseToString(sg_exp) << ", " <<
  // poly_out.print() << endl;
  // cout << "ret1 " << ret << endl;

  vector<string> parameters;
  void *sg_func_decl = TraceUpByTypeCompatible(sg_exp, V_SgFunctionDeclaration);
  if (!sg_func_decl)
    return 0;
  ret &= simplify_intermediate_variables(sg_exp, GetFuncBody(sg_func_decl),
                                         poly_out, parameters);
  //  cout << "ret2 " << ret << endl;

  // printf ("+++%s\n", poly_out.print().c_str());
  if (!ret) {
    mapVar2Coeff["nullptr"] = 1;
    return 0;
  }

  vector<string> vec_vars;
  poly_out.get_vars(vec_vars);

  for (size_t i = 0; i < vec_vars.size(); i++) {
    string var = vec_vars[i];
    if (var == "#")
      continue;
    if (poly_out.get_coeff(var))
      mapVar2Coeff[var] = poly_out.get_coeff(var);
  }
  if (poly_out.get_const())
    mapVar2Coeff["1"] = poly_out.get_const();

  return 1;
}

// In this function, the variable name is matched in the scopes between sg_exp
// and sg_scope
// Modified by Hui
int CSageCodeGen::simplify_intermediate_variables(void *sg_exp_,
                                                  void *sg_scope_,
                                                  string &poly_in,
                                                  vector<string> &vec_vars,
                                                  vector<string> parameters_) {
  return 0;
#if 0
  int i, j;
  vector<string> parameters = parameters_;

  // 0. get loops between sg_exp and sg_scope and add them to parameters
  PolyMatrix inner_domain_matrix;
  int ret = analyze_iteration_domain(sg_scope_, sg_exp_, inner_domain_matrix);

  parameters = str_vector_add(parameters, inner_domain_matrix.get_iterators());
  parameters = str_vector_add(parameters, kernel_invar_param);

  if (DEBUG) {
    cout << "DEBUG:kernel_invar_param.size = " << kernel_invar_param.size()
         << endl;
    for (size_t idx = 0; idx < parameters.size(); idx++)
      cout << parameters[idx] << "\t";
    cout << endl;
    cout << "DEBUG: start var = ";
    for (size_t idx = 0; idx < vec_vars.size(); idx++)
      cout << vec_vars[idx] << "\t";
    cout << endl;
  }

  while (1) {
    // 1. get the var to simplify
    // vector<string> vec_vars;
    // poly_in.get_nonzero_vars(vec_vars);
    vector<string> remain = str_vector_sub(vec_vars, parameters);
    if (remain.size() == 0) {
      break; // no more things to do
    }
    string curr_var = remain[0];
    if (DEBUG)
      cout << "DEBUG: curr_var = " << curr_var << endl;
    // 2. get all the references of curr_var
    vector<void *> vec_refs;
    {
      vector<void *> vec_refs_;
      GetNodesByType_int(sg_scope_, "preorder", V_SgVarRefExp, &vec_refs_);

      for (i = 0; i < vec_refs_.size(); i++) {
        if (UnparseToString(vec_refs_[i]) == curr_var) {
          vec_refs.push_back(vec_refs_[i]);
        }
      }

      vec_refs_.clear();
      GetNodesByType_int(sg_scope_, "preorder", V_SgInitializedName, &vec_refs_);
      for (i = 0; i < vec_refs_.size(); i++) {
        // void * ref = vec_refs_[i];

        // cout<<"vec_refs "<<i<<" "<<UnparseToString(vec_refs[i])<<endl;
        SgInitializedName *sg_name =
            isSgInitializedName((SgNode *)vec_refs_[i]);
        SgAssignInitializer *sg_assign =
            isSgAssignInitializer(sg_name->get_initializer());
        //	cout<<"sg_assign = "<<sg_assign<<" vec_refs[i] =
        //"<<UnparseToString(vec_refs_[i])<<endl;

        if (UnparseToString(vec_refs_[i]) == curr_var && sg_assign) {
          vec_refs.push_back(vec_refs_[i]);
        }
      }
    }

    // 3. for each reference
    // 3.1 if it is in a function call statement => false
    // 3.2 if there is multiple assignment op    => false
    // 3.3 if there is ++/--                     => false
    // 3.4 if there is a PntrArrRef expression   => false
    // 3.5 for the only assignment, call Expr2Vector and simplify, then replace
    // the poly_in
    int found = 0;

    // cout<<"vec_refs size = "<<vec_refs.size()<<endl;

    for (i = 0; i < vec_refs.size(); i++) {
      void *ref = vec_refs[i];

      // cout << "[simplify] " << UnparseToString(ref) << endl;
      // cout << "[simplify] type :" << (((SgNode*)ref)->class_name()) << endl;

      if (GetEnclosingNode("FunctionCallExp", ref)) {
#ifdef PROJDEBUG
        cout << "\n[codegen] ERROR: Ilegal function call expression "
             << UnparseToString(ref)
             << " appear in array access subscript.\n\n";
#endif
				// exit(1);
        poly_in = "";
        return 0;
      }
      if (isBinaryAssign(isSgBinaryOp((SgNode *)GetParent(ref)))) {
        // cout<<"return 0_2"<<endl;
#ifdef PROJDEBUG
        cout << "\n[codegen] ERROR: Ilegal binary assignment "
             << UnparseToString(ref)
             << " appear in array access subscript.\n\n";
#endif
				// exit(1);
        poly_in = "";
        return 0;
      }
      if (isSgPntrArrRefExp((SgNode *)GetParent(ref)) &&
          isSgPntrArrRefExp((SgNode *)GetParent(ref))->get_lhs_operand() ==
              ref) // lhs of a PntrArrRef
      {
#ifdef PROJDEBUG
        cout << "\n[codegen] ERROR: Ilegal LHS of pointer array reference "
             << UnparseToString(ref)
             << " appear in array access subscript.\n\n";
#endif
				// exit(1);
        poly_in = "";
        return 0;
      }
      if (isSgPlusPlusOp((SgNode *)GetParent(ref))) {
#ifdef PROJDEBUG
        cout << "\n[codegen] ERROR: Ilegal plus-plus operation op "
             << UnparseToString(ref)
             << " appear in array access subscript.\n\n";
#endif
				// exit(1);
        poly_in = "";
        return 0;
      }
      if (isSgMinusMinusOp((SgNode *)GetParent(ref))) {
#ifdef PROJDEBUG
        cout << "\n[codegen] ERROR: Ilegal minus-minus operation op "
             << UnparseToString(ref)
             << " appear in array access subscript.\n\n";
#endif
				// exit(1);
        poly_in = "";
        return 0;
      }

      SgAssignOp *assign_op = isSgAssignOp((SgNode *)GetParent(ref));
      SgAssignStatement *assign_stmt =
          isSgAssignStatement((SgNode *)GetParent(ref));
      SgInitializedName *assign_name = isSgInitializedName((SgNode *)ref);
      if (0 == assign_op && 0 == assign_stmt && 0 == assign_name) {
        continue;
      }
      SgExpression *value_exp = 0;
      if (assign_op && assign_op->get_lhs_operand() == ref) {
        if (IsForStatement(GetEnclosingNode(
                "Statement", ref))) // Can not be assigned in a for loop
        {
          //	cout<<"return 0_6"<<endl;
#ifdef PROJDEBUG
          cout << "\n[codegen] ERROR: Ilegal defined-in-loop variable"
               << UnparseToString(ref)
               << " appear in array access subscript.\n\n";
#endif
					// exit(1);
          poly_in = "";
          return 0;
          //	return 0;
        }
        value_exp = assign_op->get_rhs_operand();
      } else if (assign_stmt && assign_stmt->get_label() == ref) {
        value_exp = assign_stmt->get_value();
      } else if (assign_name) {
        SgAssignInitializer *sg_assign =
            isSgAssignInitializer(assign_name->get_initializer());
        if (!sg_assign) // only support assign initialized (no constructor
                        // initialize) in simplification
        {
          //	cout<<"return 0_7"<<endl;
#ifdef PROJDEBUG
          cout << "\n[codegen] ERROR: Missing initialization of variable "
               << UnparseToString(assign_name)
               << " in array access subscript.\n\n";
#endif
          poly_in = "";
          return 0;
          // exit(1);
          //	return 0;
        }
        value_exp = sg_assign->get_operand();
      } else {
        continue; // others are read references
      }
      if (found) // that means we do not have loop iterators and
      {
        return 0;
      }
      found = 1;

      // 3.5.1 call Expr2Vector and simplify
      // PolyVector vec_exp;
      string vec_exp;
      vector<string> vec_vars_new;
      // vec_vars.clear();
      if (!Expr2Vector(value_exp, vec_exp, vec_vars_new)) {
#ifdef PROJDEBUG
        cout << "\n[codegen] ERROR: array access subscript is not linear in "
             << UnparseToString(value_exp) << ".\n\n";
#endif
        // ZP: 2014-08-21
        // exit(1);
        return 0;
      }

      string curr_var_str = "(" + curr_var + ")";
      if (vec_exp.find(curr_var_str) != string::npos) {
#ifdef PROJDEBUG
        cout << "\n[codegen] ERROR: variable " << curr_var
             << " has self-dependency in " << UnparseToString(value_exp)
             << ".\n\n";
#endif
        // ZP: 2014-08-21
        // exit(1);
        return 0;
      }

      vector<string> local_parameters = parameters;
      if (DEBUG)
        cout << "+++ start simplify " << UnparseToString(value_exp) << endl;

      int ret = simplify_intermediate_variables(value_exp, sg_scope_, vec_exp,
                                                vec_vars_new, local_parameters);
      if (!ret) {
        return 0;
      }
      if (DEBUG)
        cout << "--- end simplify " << UnparseToString(value_exp) << endl;

      // 3.5.2 then replace the poly_in
      while (1) {
        if (poly_in.find(curr_var_str) == string::npos) {
          if (DEBUG)
            cout << "break when poly_in = " << poly_in
                 << " curr_var = " << curr_var_str << endl;
          break;
        }
        int pos = poly_in.find(curr_var_str);
        if (DEBUG)
          cerr << "replace " << curr_var_str << " --> " << vec_exp << endl;
        poly_in.replace(pos, curr_var_str.size(), vec_exp);
      };

      vector<string> vec_curr;
      vec_curr.push_back(curr_var);
      vec_vars = str_vector_sub(vec_vars, vec_curr);

      // poly_in.substitude(curr_var, vec_exp);

      break;
    }

    if (found == 0) {
#ifdef PROJDEBUG
      cout << "\n[codegen] ERROR: Ilegal local variable " << curr_var
           << " appear in array access subscript.\n\n";
#endif
      // ZP: 2014-08-22
      // exit(1);
      return 0; // no assign statements found
    }
  }
  if (DEBUG) {
    cout << "DEBUG: end var = ";
    for (size_t idx = 0; idx < vec_vars.size(); idx++)
      cout << vec_vars[idx] << "\t";
    cout << endl;
  }

  return 1;
#endif
}

int CSageCodeGen::simplify_intermediate_variables(void *sg_exp_,
                                                  void *sg_scope_,
                                                  PolyVector &poly_in,
                                                  vector<string> parameters_) {
  size_t i;
  vector<string> parameters = parameters_;

  // 0. get loops between sg_exp and sg_scope and add them to parameters
  PolyMatrix inner_domain_matrix;
  int ret = analyze_iteration_domain(sg_scope_, sg_exp_, inner_domain_matrix);
  if (!ret)
    return ret;
  parameters = str_vector_add(parameters, inner_domain_matrix.get_iterators());

  while (1) {
    // 1. get the var to simplify
    vector<string> vec_vars;
    poly_in.get_nonzero_vars(vec_vars);
    vector<string> remain = str_vector_sub(vec_vars, parameters);
    if (remain.size() == 0)
      break; // no more things to do
    string curr_var = remain[0];

    // 2. get all the references of curr_var
    vector<void *> vec_refs;
    {
      vector<void *> vec_refs_;
      GetNodesByType_int(sg_scope_, "preorder", V_SgVarRefExp, &vec_refs_);

      for (i = 0; i < vec_refs_.size(); i++) {
        if (UnparseToString(vec_refs_[i]) == curr_var)
          vec_refs.push_back(vec_refs_[i]);
      }

      vec_refs_.clear();
      GetNodesByType_int(sg_scope_, "preorder", V_SgInitializedName,
                         &vec_refs_);
      for (i = 0; i < vec_refs_.size(); i++) {
        SgInitializedName *sg_name =
            isSgInitializedName((SgNode *)vec_refs_[i]);
        SgAssignInitializer *sg_assign =
            isSgAssignInitializer(sg_name->get_initializer());

        //    if(sg_assign)
        //	    cout<<"sg_assign = "<< sg_assign->unparseToString() <<"
        // vec_refs[i] = "<<UnparseToString(vec_refs_[i])<<endl;

        if (UnparseToString(vec_refs_[i]) == curr_var && sg_assign)
          vec_refs.push_back(vec_refs_[i]);
#if 0
                cout << "[simplify ] " << UnparseToString(sg_name) << " " << UnparseToString(GetParent(sg_name))      << endl;
                if (sg_assign) cout << "[simplify ] type :" << (((SgNode*)sg_name->get_initializer())->class_name()) << endl;
#endif
      }
    }

    // 3. for each reference
    // 3.1 if it is in a function call statement => false
    // 3.2 if there is multiple assignment op    => false
    // 3.3 if there is ++/--                     => false
    // 3.4 if there is a PntrArrRef expression   => false
    // 3.5 for the only assignment, call Expr2Vector and simplify, then replace
    // the poly_in
    int found = 0;

    for (i = 0; i < vec_refs.size(); i++) {
      void *ref = vec_refs[i];
#if 0
            cout << "[simplify] " << UnparseToString(ref) << " " << UnparseToString(GetParent(ref)) << endl;
            cout << "[simplify] type :" << (((SgNode*)ref)->class_name()) << endl;
#endif

      if (GetEnclosingNode("FunctionCallExp", ref) &&
          !(isSgBinaryOp((SgNode *)GetParent(ref)))) {
        return 0;
      }
      if (isBinaryAssign(isSgBinaryOp((SgNode *)GetParent(ref)))) {
        return 0;
      }
      if (isSgPntrArrRefExp((SgNode *)GetParent(ref)) &&
          isSgPntrArrRefExp((SgNode *)GetParent(ref))->get_lhs_operand() ==
              ref) // lhs of a PntrArrRef
      {
        return 0;
      }
      if (isSgPlusPlusOp((SgNode *)GetParent(ref))) {
        return 0;
      }
      if (isSgMinusMinusOp((SgNode *)GetParent(ref))) {
        return 0;
      }

      SgAssignOp *assign_op = isSgAssignOp((SgNode *)GetParent(ref));
      SgAssignStatement *assign_stmt =
          isSgAssignStatement((SgNode *)GetParent(ref));
      SgInitializedName *assign_name = isSgInitializedName((SgNode *)ref);

      if (nullptr == assign_op && nullptr == assign_stmt &&
          nullptr == assign_name) {
        continue;
      } else {
      }
      SgExpression *value_exp = nullptr;
      if (assign_op && assign_op->get_lhs_operand() == ref) {

        // cout << "\ncodegen check " <<
        // UnparseToString(GetEnclosingNode("ForLoop", assign_op)) << endl;
        // cout << "\ncodegen check " <<
        // UnparseToString(GetEnclosingNode("Statement", assign_op)) << endl;
        // cout << "\ncodegen check " << UnparseToString(assign_op) << endl;
        // if (IsForStatement(GetEnclosingNode("ForLoop", ref))) // Can not be
        // assigned in a for loop

        // Modified by Yuxin, May 20 2015, if the assignment to a non-iterator
        // variable exists as a for initial statement in the function, take the
        // reference as non-linear
        // if (isSgForInitStatement((SgNode*)GetEnclosingNode("Statement",
        // ref))) // Can not be assigned in a for loop
        if (SageInterface::getEnclosingNode<SgForInitStatement>(
                (SgNode *)assign_op)) // Can not be assigned in a for loop
        {
#ifdef PROJDEBUG
          cout << "\n[MARS-IR-WARN] " << UnparseToString(ref)
               << " is used outside a loop range. This usage is considered to "
                  "be non-linear."
               << endl;
#endif
          return 0;
        }
        value_exp = assign_op->get_rhs_operand();
      } else if (assign_stmt && assign_stmt->get_label() == ref) {
        value_exp = assign_stmt->get_value();
      } else if (assign_name) {
        SgAssignInitializer *sg_assign =
            isSgAssignInitializer(assign_name->get_initializer());
        if (!sg_assign) // only support assign initialized (no constructor
                        // initialize) in simplification
        {
          return 0;
        }
        value_exp = sg_assign->get_operand();
      } else {
        continue; // others are read references
      }
      if (found) // that means we do not have loop iterators and
      {
        return 0;
      }
      found = 1;

      // 3.5.1 call Expr2Vector and simplify
      PolyVector vec_exp;
      if (!Expr2Vector(value_exp, vec_exp)) {
        return 0;
      }

      // cout<<"DEBUG: vec_exp = "<<vec_exp.print()<<endl;

      vector<string> local_parameters = parameters;
      int ret = simplify_intermediate_variables(value_exp, sg_scope_, vec_exp,
                                                local_parameters);
      if (!ret) {
        return 0;
      }

      // 3.5.2 then replace the poly_in
      poly_in.substitude(curr_var, vec_exp);

      break;
    }

    if (found == 0) {
      return 0; // no assign statements found
    }
  }

  return 1;
}
#endif

#if 0
// This function add "volatile" qualifier to the argument of the function if it
// did not have originally
void CSageCodeGen::function_argument_volatile_type(void *func_decl, int i) {
  assert(0 <= i && i < GetFuncParamNum(func_decl));
  // int i;
  // for (i = 0; i < GetFuncParamNum(func_decl); i++)
  {
    void *arg = GetFuncParam(func_decl, i);

    // if (UnparseToString(arg) != sArray) continue;

    SgInitializedName *sg_arg = isSgInitializedName((SgNode *)arg);

    string str_type = UnparseToString(sg_arg->get_type());

    if ("volatile" != str_type.substr(0, strlen("volatile"))) {
      SgType *sg_type = sg_arg->get_type();
      SgPointerType *sg_ptr_type = isSgPointerType(sg_type);
      if (sg_ptr_type) {
        sg_type = sg_ptr_type->get_base_type();
      }
      sg_type = SageBuilder::buildVolatileType(sg_type);
      // markBuild(* this, sg_type, "Build in " + to_string(__LINE__) + " for "
      // + to_string((long) sg_type));
      if (sg_ptr_type) {
        sg_type = SageBuilder::buildPointerType(sg_type);
        // markBuild(* this, sg_type, "Build in " + to_string(__LINE__) + " for
        // " + to_string((long) sg_type));
      }
      sg_arg->set_type(sg_type);
    }
  }
}

// ZP: 2013-12-31
void *CSageCodeGen::match_var_in_expression(string sVar, void *sg_exp) {
  size_t j;
  vector<void *> vecVarRef;
  GetNodesByType_int(sg_exp, "preorder", V_SgVarRefExp, &vecVarRef);
  for (j = 0; j < vecVarRef.size(); j++) {
#if USE_LOWERCASE_NAME
    if (get_lower_case(UnparseToString(vecVarRef[j])) == get_lower_case(sVar))
      return vecVarRef[j];
#else
    if (UnparseToString(vecVarRef[j]) == sVar)
      return vecVarRef[j];
#endif
  }
  return nullptr;
}

int CSageCodeGen::get_io_matrix_of_function_recur(
    void *sg_func_decl, string sPort, int nDim,
    map<string, vector<poly_access_pattern>> &mapMatrix,
    vector<string> iterators) {
  // ZP: 2015-01-04: remove access analysis for default data type "bus_e1",
  // which keeps the simple things simple
  {
    string port_type;
    if (mapAccess2PortType.count(sPort) > 0)
      port_type = mapAccess2PortType[sPort];
    else
      port_type = "bus_e1";
    if (port_type == "bus_e1") {
      return 0; // do not need to deal with the access, default processing is
                // performed.
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////
  // The function detects the linear access of array sPort if it is statically
  // analyzable.
  // Analyzability requirements:
  // 1. ref of sPort only used either 1) standalone as a parameter of function
  // call or 2) in an PntrArrRef with full dimensions
  // 2. the indexes of the PntrArrRef is linear form of local iterators or
  // scalar parameters of the scope functions
  // 3. the local function calls with sPort argument should not have other
  // arguments which is neither the local iterators nor the parameters of the
  // scope function
  // 4. do not have recursive call
  // if any of the requirement above is not satisfied, the mapMatrix is not
  // valid and the return value is 0

  int i;
  string sArray = sPort;
  int all_reference_parsed = 1;
  // 1. recursion in function calls // FIXME:
  {
    vector<void *> vecCall;
    GetNodesByType_int(GetFuncBody(sg_func_decl), "preorder",
                       V_SgFunctionCallExp, &vecCall);
    for (size_t j = 0; j < vecCall.size(); j++) {
      // ZP: 2013-12-31
      {
        if (IsMemCpy(vecCall[j])) {

          void *var_ref = nullptr;
          for (i = 0; i < GetFuncCallParamNum(vecCall[j]); i++) {
            void *arg_exp = GetFuncCallParam(vecCall[j], i);
            if (!arg_exp)
              continue;
            if (match_var_in_expression(sArray, arg_exp)) {
              var_ref = match_var_in_expression(sArray, arg_exp);
              if (DEBUG)
#ifdef PROJDEBUG
                printf("access with memcpy: [%s] %s\n",
                       UnparseToString(var_ref).c_str(),
                       UnparseToString(arg_exp).c_str());
#endif
              break;
            }

            // if (UnparseToString(arg_exp) == sArray) break;
          }

          if (i > 2)
            continue;

          poly_access_pattern access;
          access.access_pattern = "";
          access.sArray = sArray;
          access.sPortType = (mapAccess2PortType.count(sArray) > 0)
                                 ? mapAccess2PortType[sArray]
                                 : "bus_e1";
          if (access.sPortType != "bus_e1") {
#ifdef PROJDEBUG
            printf("[tldm_task_extract] ERROR: memcpy can only work with "
                   "bus_e1 port (port=%s type=%s)\n",
                   sArray.c_str(), access.sPortType.c_str());
#endif
            assert(0);
          }
          access.nDim = nDim;
          access.nDir =
              (i == 0) ? poly_access_pattern::WRITE : poly_access_pattern::READ;
          access.sRef = nullptr;
          access.sDataType = UnparseToString(
              trace_base_type(GetTypebyVarRef(var_ref))); //"int";
          // access.inner_iterators;

          if (mapMatrix.end() == mapMatrix.find(sArray)) {
            vector<poly_access_pattern> empty;
            mapMatrix[sArray] = empty;
          }
          vector<poly_access_pattern> &vecPattern = mapMatrix[sArray];
          vecPattern.push_back(access);

          continue;
        }
      }

      // 1.1 check recursive
      void *decl = GetFuncDeclByCall(vecCall[j]);

      // FIXME: if decl==null, decl is a system call
      // assert(GetFuncBody(decl));
      if (!decl)
        continue;

      if (decl == sg_func_decl) {
        return 0; // do not allow recursive function call to itself
        // FIXME: the recursive testing is not fully correct: A->B->C->B is not
        // considered !!!
      }

      // 1.2 traverse low level accesses in function calls
      for (i = 0; i < GetFuncCallParamNum(vecCall[j]); i++) {
        void *arg_exp = GetFuncCallParam(vecCall[j], i);
        if (!arg_exp)
          continue;
        if (!match_var_in_expression(sArray, arg_exp))
          continue;
        if (UnparseToString(arg_exp) != sArray) {
#ifdef PROJDEBUG
          printf("\n[tldm_task_extract] ERROR: Function arguments do not allow "
                 "complex expression of port variable.\n");
          printf("    Func=%s, Arg=%s, Port=%s\n\n",
                 GetFuncNameByCall(vecCall[j]).c_str(),
                 UnparseToString(arg_exp).c_str(), sArray.c_str());
          printf("Suggestion: add a temporary variable for the expression is a "
                 "workaround.\n\n");
#endif
          assert(0);
        }

        // add local iterators into the boundary list, uncommented by zhangpeng
        // 2013-05-08
        PolyMatrix inner_domain_matrix;
        int ret = analyze_iteration_domain(GetFuncBody(sg_func_decl), arg_exp,
                                           inner_domain_matrix);
        vector<string> inner_iterators = inner_domain_matrix.get_iterators();
        vector<string> new_iterators = iterators;
        new_iterators.insert(new_iterators.end(), inner_iterators.begin(),
                             inner_iterators.end());

        map<string, vector<poly_access_pattern>> map_temp;
        string sArgName = UnparseToString(GetFuncParam(decl, i));

        // function_argument_name_replace(vecCall[j], decl, new_iterators);  //
        // fixed by zhangpeng 2013-05-06, but do not need now 2013-05-21
        {
          // get all the declarations and replace the argument type
          vector<void *> vecDecls = GetAllFuncDeclByCall(vecCall[j]);
          for (size_t k = 0; k < vecDecls.size(); k++) {
            function_argument_volatile_type(vecDecls[k],
                                            i); // fixed by zhangpeng 2013-05-21
          }
        }

        ret = get_io_matrix_of_function_recur(decl, sArgName, nDim, map_temp,
                                              new_iterators);
        if (!ret)
          return 0;

        // modify array name and keep the access info
        map<string, vector<poly_access_pattern>>::iterator it;
        for (it = map_temp.begin(); it != map_temp.end(); it++) {
          for (size_t k = 0; k < it->second.size(); k++) {
            poly_access_pattern access = it->second[k];
            access.sArray = sArray;
            access.matrix.rename_var(sArgName + "_d0",
                                     sArray + "_d0"); // only one dimension

            if (mapMatrix.end() == mapMatrix.find(sArray)) {
              vector<poly_access_pattern> empty;
              mapMatrix[sArray] = empty;
            }
            vector<poly_access_pattern> &vecPattern = mapMatrix[sArray];
            vecPattern.push_back(access);

            if (1) {
#ifdef PROJDEBUG
              std::cout << "Propagate an access: [" << GetFuncName(decl) << ":"
                        << sArgName << "] -> [" << GetFuncName(sg_func_decl)
                        << ":" << sArray << "] " << endl;
#endif
              //  << access.matrix.print_expression(sArray+"_d0") << endl;
            }
          }
        }
      }
    }
  }

  // 2. traverse pointer references

  // added by Hui
  map<string, vector<int>> arr_name2dim;
  get_arrays_dim(sg_func_decl, arr_name2dim);

  map<void *, map<string, vector<int>>> block2arr_name2dim;
  vector<void *> vecRef;
  GetNodesByType_int(GetFuncBody(sg_func_decl), "preorder", V_SgPntrArrRefExp,
                     &vecRef);
  for (size_t j = 0; j < vecRef.size(); j++) {
    // 2014-01-01
    if (is_pointer_ref_in_memcpy(vecRef[j]))
      continue;

    // get the innermost level of the pntr expression
    SgPntrArrRefExp *pntr = isSgPntrArrRefExp((SgNode *)vecRef[j]);
    SgExpression *sgvar = pntr->get_lhs_operand();
    // std::cout << UnparseToString(sgvar) << " " << sArray << endl;
    if (UnparseToString(sgvar) != sArray)
      continue;

    // added by Hui

    string task_name = "default";
    string graph_name = "default";
    string sFilter;
    string sCmd;

    // printf("vec_ref = %s\n", UnparseToString(vecRef[j]).c_str());
    /*	while(graph_bb)
        {
        graph_bb = TraceUpByType(GetParent(graph_bb), "SgBasicBlock");

        printf("graph_bb = %s\n", UnparseToString(graph_bb).c_str());
        void* sg_parent = GetParent(graph_bb);
        printf("after get parent\n");
        printf("sg_parent = %s\n", UnparseToString(sg_parent).c_str());

        if(!IsBasicBlock(sg_parent)) break;
        if(!graph_bb) break;
        size_t idx = GetChildStmtIdx(sg_parent, graph_bb); 
        if(0 == idx || idx >= GetChildStmtNum(sg_parent)) continue;

        void* pre_stmt = GetChildStmt(sg_parent, idx - 1);

        string sPragma = GetPragmaString(pre_stmt);
        if("" == sPragma) continue;

        map<string, pair<vector<string>, vector<string> > > mapParams;
        tldm_pragma_parse_whole(sPragma, sFilter, sCmd, mapParams);

        if("tldm" == sFilter && "task_block" == sCmd)
        {
        task_name = mapParams["name"].first[0];
        printf("task_name = %s\n", task_name.c_str());
        }

        if("tldm" == sFilter && "graph_block" == sCmd)
        {
        graph_name = mapParams["name"].first[0];
        printf("graph_name = %s\n", graph_name.c_str());
        break;
        }
        }; */
    // assert(IsBasicBlock(graph_bb));

    // printf("task name = %s, graph name = %s\n", task_name.c_str(),
    // graph_name.c_str());
    // printf("arr_name2size = %d\n", arr_name2dim.size());

    /*for(map<string, vector<int> >::iterator di = arr_name2dim.begin(); di !=
      arr_name2dim.end(); di ++)
      {
      cout<<"arr_name = "<<(*di).first<<endl;
      vector<int> dim = (*di).second;

      for(size_t idx = 0; idx < dim.size(); idx ++)
      cout<<dim[idx]<<", ";
      cout<<endl;
      }*/

    // Mo
    // order_vector_gen(codegen, (SgNode*)vecRef[j]);
    // extract order vector for tldm access information
    string order_vec_string = order_vector_gen(*this, (SgNode *)vecRef[j], 3);

    // cout<<"order vector for tldm access:"<<endl;
    // cout<<order_vec_string<<endl;

    // added by Hui
    string access_iter_list = "";
    string access_up_list = "";

    void *access_node = vecRef[j];
    vector<string> access_iterators, access_lower, access_upper;
    void *access_inner_loop = nullptr;
    void *access_scope = nullptr;
    void *access_pre;
    bool found = false;
    bool isCondAccess = false;

    while (1) {
      access_pre = access_node;
      access_node = GetParent(access_node);
      if (!found && IsForStatement(access_node)) {
        access_inner_loop = access_pre;
        found = true;
      }
      if (IsIfStatement(access_node)) {
        isCondAccess = true;
      }
      if (IsFunctionDefinition(access_node)) {
        access_scope = access_pre;
        break;
      }
    }
    if (access_inner_loop != nullptr) {
      int ret0 = analyze_iteration_domain(access_scope, access_inner_loop,
                                          access_iterators, access_lower,
                                          access_upper);

      if (ret0)
        for (size_t i = 0; i < access_iterators.size(); i++) {
          access_iter_list += access_iterators[i];
          // up_list   += lower[i]+".."+my_itoa(my_atoi(upper[i])-1);
          access_up_list += access_lower[i] + "..(" + access_upper[i] + "-(1))";
          if (i != access_iterators.size() - 1)
            access_iter_list += ",";
          if (i != access_iterators.size() - 1)
            access_up_list += ",";
        }
    }

    // cout<<"task access iter_list = "<<access_iter_list<<endl;
    // cout<<"task access up_list = "<<access_up_list<<endl;

    poly_access_pattern access;
    access.sRef = vecRef[j];
    access.sArray = sArray;
    access.nDim = nDim;
    access.sIterators = str_merge(',', iterators);
    if (mapAccess2PortType.count(sArray) > 0)
      access.sPortType = mapAccess2PortType[sArray];
    else
      access.sPortType = "bus_e1";
    if (isCondAccess && access.sPortType == "bus_e2") {
#ifdef PROJDEBUG
      cout << "[codegen] ERROR: Find bus_e2 " << sArray
           << " access inside if-else conditional bodies." << endl;
#endif
      exit(1);
    }
    SgVarRefExp *sgref = isSgVarRefExp(sgvar);
    assert(sgref);
    access.sDataType = UnparseToString(sgref->get_type());
    access.sDataType = str_replace(access.sDataType, "volatile", "");
    access.sDataType = str_replace(access.sDataType, " ", "");
    access.sDataType = str_replace(access.sDataType, "*", "");
    access.sOrderVec = order_vec_string; // added by Hui
    access.iter_list = access_iter_list;
    access.up_list = access_up_list;
    access.access_pattern = "";
    // 2.1 dimension equalities
    int dim = 0;
    SgNode *pntr_p = pntr;
    while (pntr) {
      SgExpression *sgidx = pntr->get_rhs_operand(); // idx expression
      // Modified by Hui
      // PolyVector vec_subscript;
      string vec_subscript;
      vector<string> vec_vars;
      vec_vars.clear();

      if (!Expr2Vector(sgidx, vec_subscript, vec_vars)) {
        all_reference_parsed = 0;
#ifdef PROJDEBUG
        printf("[codegen] ERROR: the following expression cannot be fit into "
               "polyhedral model.\n%s\n",
               UnparseToString(sgidx).c_str());
#endif
        assert(0);
      }

      // trace use/def chain
      // FIXME: implement the following function which trace the intermediate
      // variables until function argument or local loop iterators
      //        It returns 0 if failed to trace to those boundary variables
      //        This function is needed to be implemented, otherwise
      //        intermediate variable can not be used for addressing
      if (1) {
        vector<string> parameters = iterators;
        // int ret = simplify_intermediate_variables(sgidx,
        // GetFuncBody(sg_func_decl), vec_subscript, parameters);
        if (DEBUG)
          cout << "+++ start simplify " << vec_subscript << endl;
        // int ret;
        simplify_intermediate_variables(sgidx, GetFuncBody(sg_func_decl),
                                        vec_subscript, vec_vars, parameters);

        // if (!ret) { if (FORCE_ASSERT) assert(0); return 0; }

#ifdef PROJDEBUG
        cout << "task access pattern = " << vec_subscript << endl;
#endif

        access.access_pattern = access.access_pattern + "," + vec_subscript;
      }

      PolyVector vec_dim(sArray + "_d" + my_itoa(dim++), 1);
      PolyVector POLYVECTOR_EQ(PolyVector::OP_FLAG_POINTER, PolyVector::OP_EQ);
      // vec_dim = vec_dim - vec_subscript + POLYVECTOR_EQ;
      // to be fixed: just remove - vec_subscript
      vec_dim = vec_dim + POLYVECTOR_EQ;
      access.matrix.append_vector(vec_dim);

      pntr_p = pntr;
      pntr = isSgPntrArrRefExp((SgNode *)GetParent(pntr));
    }
    // Commented by Hui: currently do not perform array & access dim equality
    // checking, to be added later
    // if (nDim != dim) { cout<<"return 0 ndim= dim ="<<nDim<<" "<<dim<<endl; if
    // (FORCE_ASSERT) assert(0); return 0; } // FIXME: now only support the full
    // dimension access
    access.nDir = is_write_analysis(
        pntr_p); // pntr_p is the top of the PntrArrRef expression

    // 2.2 intra-task loop iterator inequalities
    PolyMatrix inner_domain_matrix;
    int ret = analyze_iteration_domain(GetFuncBody(sg_func_decl), pntr_p,
                                       inner_domain_matrix);
    if (!ret) {
      if (FORCE_ASSERT)
        assert(0);
      return 0;
    }
    access.inner_iterators = inner_domain_matrix.get_iterators();
    access.matrix.append_matrix(inner_domain_matrix);
    vector<string> empty;
    access.matrix.set_iterators(empty);

    // 2.3 store the information
    if (mapMatrix.end() == mapMatrix.find(sArray)) {
      vector<poly_access_pattern> empty;
      mapMatrix[sArray] = empty;
    }
    vector<poly_access_pattern> &vecPattern = mapMatrix[sArray];
    vecPattern.push_back(access);

    if (1) {
#ifdef PROJDEBUG
      std::cout << "Detect an access   : [" << GetFuncName(sg_func_decl) << ":"
                << sArray << "] "
                << access.matrix.print_expression(sArray + "_d0") << endl;
#endif
    }
  }

  return all_reference_parsed;
}

// int CSageCodeGen::get_io_matrix_of_function(void * sg_func_decl, map<string,
// vector<poly_access_pattern> > & mapMatrix, vector<string> iterators,
// vector<string> & params, vector<string> & orderOfPortVar, map<>)
int CSageCodeGen::get_io_matrix_of_function(
    void *sg_func_decl, map<string, vector<poly_access_pattern>> &mapMatrix,
    vector<string> iterators, vector<string> &params,
    vector<string> &orderOfPortVar) {
  int i;
  int all_reference_parsed = 1;
  assert(GetFuncBody(sg_func_decl));

  vector<string> match_end_points = iterators; // used for expression tracing
  for (i = 0; i < GetFuncParamNum(sg_func_decl); i++) {
    match_end_points.push_back(UnparseToString(GetFuncParam(sg_func_decl, i)));
  }

  // for each argument with pointer type
  for (i = 0; i < GetFuncParamNum(sg_func_decl); i++) {
    void *arg = GetFuncParam(sg_func_decl, i);

    SgInitializedName *sg_arg = isSgInitializedName((SgNode *)arg);
    orderOfPortVar.push_back(UnparseToString(sg_arg));

    // if ("int" == UnparseToString(sg_arg->get_type()))
    // params.push_back(UnparseToString(arg));  // Fixed by peng.zhang
    // 2013-04-03
    if (!isSgPointerType(sg_arg->get_type()) &&
        !isSgArrayType(sg_arg->get_type())) { // detected scalar arguments
                                              // "param" type // FIXME: for the
                                              // condition
      vector<poly_access_pattern> vecAccessDummy;
      poly_access_pattern access;
      access.nDim = 0;
      access.sArray = UnparseToString(sg_arg);
      access.sPortType = "param";
      access.sDataType = UnparseToString(sg_arg->get_type());
      access.sDataType = str_replace(access.sDataType, "volatile", "");
      access.sDataType = str_replace(access.sDataType, " ", "");
      vecAccessDummy.push_back(access);
      mapMatrix[access.sArray] = vecAccessDummy;

      continue;
    }
    string sArray = UnparseToString(sg_arg);
    int nDim = 1; // Hui: to be fixed later by parsing cmost2d, 3d; function
                  // get_io_matrix_of_function_recur intrinsically support
                  // multi-dimensional array, but now ...

    if (!get_io_matrix_of_function_recur(sg_func_decl, sArray, nDim, mapMatrix,
                                         iterators)) {
      all_reference_parsed = 0;

      if (FORCE_ASSERT)
        assert(0);
      // FIXME: give an conservative access pattern instead
      poly_access_pattern dummy_access;
      dummy_access.nDim = 1;
      dummy_access.nDir = poly_access_pattern::READWRITE;
      dummy_access.sArray = sArray;
      dummy_access.sIterators = "";
      dummy_access.sPortType = "bus_e1";
      string sType = UnparseToString(sg_arg->get_type());
      sType = str_replace(sType, "volatile", "");
      sType = str_replace(sType, "*", "");
      sType = FormatSpace(sType);
      dummy_access.sDataType = sType;
      vector<poly_access_pattern> access_list;
      access_list.push_back(dummy_access);
      mapMatrix[sArray] = access_list;
    } else {
      if (0) {
        map<string, vector<poly_access_pattern>>::iterator it;
        for (it = mapMatrix.begin(); it != mapMatrix.end(); it++) {
#ifdef PROJDEBUG
          std::cout << "\nFind an IO of function " << GetFuncName(sg_func_decl)
                    << ": " << it->first << endl;
#endif
          vector<poly_access_pattern> &accesses = it->second;
#ifdef PROJDEBUG
          for (size_t j = 0; j < accesses.size(); j++) {
            std::cout << "\t" << accesses[j].matrix.print() << endl;
          }
#endif
        }
      }
    }
  }

  return all_reference_parsed;
}

// collect array references and function declaration arguments
int CSageCodeGen::linearize_arrays_detect(void *sg_bb_or_func_, string var,
                                          vector<void *> &bb_collected,
                                          vector<void *> &func_collected) {
  SgBasicBlock *sg_scope_bb = isSgBasicBlock((SgNode *)sg_bb_or_func_);
  SgFunctionDeclaration *sg_scope_func =
      isSgFunctionDeclaration((SgNode *)sg_bb_or_func_);

  // 1. function arguments
  if (sg_scope_func) {
    // if (GetFuncBody(sg_scope_func))  // argument in pure declaration is also
    // to be changed
    {
      for (int i = 0; i < GetFuncParamNum(sg_scope_func); i++) {
        SgInitializedName *sg_name =
            isSgInitializedName((SgNode *)GetFuncParam(sg_scope_func, i));
        if (UnparseToString(sg_name) == var)
          func_collected.push_back(sg_name);
      }
    }
  }

  // 2. variable references
  vector<void *> vecRef;
  GetNodesByType_int(sg_bb_or_func_, "preorder", V_SgVarRefExp, &vecRef);
  for (size_t i = 0; i < vecRef.size(); i++) {
    SgVarRefExp *ref = isSgVarRefExp((SgNode *)vecRef[i]);
    if (UnparseToString(ref) == var) {
      if (sg_scope_bb)
        bb_collected.push_back(ref);
      else if (sg_scope_func)
        func_collected.push_back(ref);
    }
  }

  // 3. function calls
  vector<void *> vecCalls;
  GetNodesByType_int(sg_bb_or_func_, "preorder", V_SgFunctionCallExp,
                     &vecCalls);
  for (size_t i = 0; i < vecCalls.size(); i++) {
    void *sg_call = vecCalls[i];
    void *sg_func_decl = GetAssociatedFuncDeclByCall(sg_call);
    if (!sg_func_decl)
      continue; // if it is statically called

    // ZP: 2013-01-04, do not need to trace inside for memcpy
    if (IsMemCpy(sg_call))
      return 1;
    if ("" == GetFuncName(sg_func_decl))
      return 1;

    int k;
    for (k = 0; k < GetFuncCallParamNum(sg_call); k++) {
      if (UnparseToString(GetFuncCallParam(sg_call, k)) == var)
        break;
    }

    if (k == GetFuncCallParamNum(sg_call))
      continue;

    vector<void *> vecDecl;
    GetNodesByType_int(GetProject(), "preorder", V_SgFunctionDeclaration,
                       &vecDecl);

    for (size_t j = 0; j < vecDecl.size(); j++) {
      if (GetFuncName(vecDecl[j]) == GetFuncName(sg_func_decl) &&
          IsMatchedFuncAndCall(vecDecl[j], sg_call, sg_func_decl)) {
        int ret = linearize_arrays_detect(
            vecDecl[j], UnparseToString(GetFuncParam(vecDecl[j], k)),
            bb_collected, func_collected);
        if (!ret)
          return 0;
      }
    }
  }

  return 1;
}

int CSageCodeGen::linearize_arrays_apply(void *sg_bb_or_func_, string var,
                                         void *sg_type_,
                                         vector<void *> &bb_collected,
                                         vector<void *> &func_collected) {
  size_t i, j, k;
  SgBasicBlock *sg_scope_bb = isSgBasicBlock((SgNode *)sg_bb_or_func_);

  if (sg_scope_bb && bb_collected.size() != 0) {
    // 1. add new 1D pointer
    // double * array_l = &(array[0][0][0]);
    SgInitializedName *sg_org_name;
    {
      vector<void *> vec_temp;
      GetNodesByType_int(sg_scope_bb, "preorder", V_SgVarRefExp, &vec_temp);
      for (i = 0; i < vec_temp.size(); i++)
        if (UnparseToString(vec_temp[i]) == var)
          sg_org_name = isSgInitializedName(
              (SgNode *)GetVariableInitializedName(vec_temp[i]));
    }
    void *basic_type = nullptr;
    vector<size_t> vec_sizes;
    int dim = get_type_dimension(sg_type_, basic_type, vec_sizes, sg_org_name);
    void *rhs_exp = CreateVariableRef(sg_org_name);
    for (i = 0; i < (size_t)dim; i++)
      rhs_exp = CreateExp(V_SgPntrArrRefExp, rhs_exp, CreateConst(0));
    rhs_exp = CreateExp(V_SgAddressOfOp, rhs_exp);
    void *sg_new_type =
        SageBuilder::buildPointerType(isSgType((SgNode *)basic_type));
    // markBuild(* this, (SgNode *) sg_new_type, "Build in " +
    // to_string(__LINE__) + " for " + to_string((long) sg_new_type));
    void *insert_pos =
        SageInterface::getNextStatement(sg_org_name->get_definition());
    if (!insert_pos) // the function argument
    {
      insert_pos = GetChildStmt(GetParent(sg_scope_bb), 0);
    }
    void *sg_decl =
        CreateVariableDecl(sg_new_type, UnparseToString(sg_org_name) + "_l",
                           rhs_exp, GetParent(insert_pos));
    InsertStmt(sg_decl, insert_pos);

    // 2. replace refs and indexes in bb_collected
    for (i = 0; i < bb_collected.size(); i++) {
      void *ref = bb_collected[i];
      vector<void *> vec_index;
      size_t ref_dim = get_ref_dimension(ref, vec_index);
      void *old_access = ref;
      void *new_access;
      if (ref_dim == 0) {
        new_access = CreateVariableRef(sg_decl);
      } else {
        for (j = 0; j < ref_dim; j++)
          old_access = GetParent(old_access);
        assert(ref_dim == (size_t)dim);
        // i*N*P + j*P + k
        void *new_index = nullptr;
        for (j = 0; j < ref_dim; j++) {
          void *term = CopyExp(vec_index[j]);
          for (k = j + 1; k < ref_dim; k++) {
            term = CreateExp(V_SgMultiplyOp, term,
                             CreateConst((int64_t)vec_sizes[k]));
          }
          if (new_index)
            new_index = CreateExp(V_SgAddOp, new_index, term);
          else
            new_index = term;
        }
        new_access = CreateExp(V_SgPntrArrRefExp, sg_decl, new_index);
      }
      SgExpression *old_access_ = isSgExpression((SgNode *)old_access);
      SgExpression *new_access_ = isSgExpression((SgNode *)new_access);
      replaceExpressionWithHistory(this, old_access_, new_access_);
    }
  }

  // no matter input scope, do changes for all the
  // references
  {
    void *basic_type;
    vector<size_t> vec_sizes;
    int dim = get_type_dimension(sg_type_, basic_type, vec_sizes);
    SgPointerType *sg_new_type =
        SageBuilder::buildPointerType(isSgType((SgNode *)basic_type));
    // markBuild(* this, sg_new_type, "Build in " + to_string(__LINE__) + " for
    // " + to_string((long) sg_new_type));
    void *sg_decl = nullptr;

    int found = 0;
    for (i = 0; i < func_collected.size(); i++) {
      SgInitializedName *sg_name =
          isSgInitializedName((SgNode *)func_collected[i]);

      // 1. set type to the argument
      if (sg_name) {
        sg_name->set_type(sg_new_type);

        if (found == 1)
          assert(0);
        found = 1;
        sg_decl = sg_name;
      }
    }

    assert(sg_decl);

    for (i = 0; i < func_collected.size(); i++) {
      SgVarRefExp *sg_ref = isSgVarRefExp((SgNode *)func_collected[i]);
      // 2. replace indexes in func_collected
      if (sg_ref)
        ;
      {
        void *ref = func_collected[i];
        vector<void *> vec_index;
        size_t ref_dim = get_ref_dimension(ref, vec_index);
        void *old_access = ref;
        void *new_access;
        if (ref_dim == 0) {
          // new_access = CreateVariableRef(sg_decl);
          continue; // fixed by peng zhang
        } else {
          for (j = 0; j < ref_dim; j++)
            old_access = GetParent(old_access);
          assert(ref_dim == (size_t)dim);
          // i*N*P + j*P + k
          void *new_index = nullptr;
          for (j = 0; j < ref_dim; j++) {
            void *term = CopyExp(vec_index[j]);
            for (k = j + 1; k < ref_dim; k++) {
              term = CreateExp(V_SgMultiplyOp, term,
                               CreateConst((int64_t)vec_sizes[k]));
            }
            if (new_index)
              new_index = CreateExp(V_SgAddOp, new_index, term);
            else
              new_index = term;
          }
          new_access = CreateExp(V_SgPntrArrRefExp, sg_decl, new_index);
          // new_access = CreateExp(V_SgPntrArrRefExp, sg_decl,
          // CopyExp(vec_index[0]));
        }
        SgExpression *old_access_ = isSgExpression((SgNode *)old_access);
        SgExpression *new_access_ = isSgExpression((SgNode *)new_access);
        replaceExpressionWithHistory(this, old_access_, new_access_);
      }
    }
  }
  return 1;
}
#endif

#if 0
string CSageCodeGen::get_var_ref_base_type(void *var_ref) {
  void *basic_type;
  vector<size_t> vec_sizes;
  get_type_dimension(GetTypeByExp(var_ref), basic_type, vec_sizes, var_ref);
  return UnparseToString(basic_type);
}

int CSageCodeGen::get_arrays_dim(void *sg_bb_or_func_,
                                 map<string, vector<int>> &arr_name2dim) {
  size_t i;
  SgBasicBlock *sg_scope_bb = isSgBasicBlock((SgNode *)sg_bb_or_func_);
  SgFunctionDeclaration *sg_scope_func =
      isSgFunctionDeclaration((SgNode *)sg_bb_or_func_);

  // 1. find all the multi-dimensional array names in the basicblock or in the
  // function argument list
  map<string, SgType *> mapVars;
  if (sg_scope_bb) {
    vector<void *> vecRef;
    GetNodesByType_int(sg_scope_bb, "preorder", V_SgVarRefExp, &vecRef);
#ifdef PROJDEBUG
    printf("vec_ref size = %ld\n", vecRef.size());
#endif
    for (i = 0; i < vecRef.size(); i++) {
      SgVarRefExp *ref = isSgVarRefExp((SgNode *)vecRef[i]);
      string var = UnparseToString((void *)ref);
      void *sg_type = ref->get_type();
      string var_type_string = UnparseToString((void *)sg_type);
      void *basic_type;
      vector<size_t> vec_sizes;
      int dim = get_type_dimension(sg_type, basic_type, vec_sizes, ref);
      cerr << var << " dim = " << dim << endl;
      cerr << "type is " << var_type_string << endl;
      if (mapVars.end() == mapVars.find(var) && 2 <= dim) {
        mapVars[var] = isSgType((SgNode *)sg_type);
      }
    }
  } else if (sg_scope_func) {
    if (GetFuncBody(sg_scope_func)) {
      for (i = 0; i < (size_t)GetFuncParamNum(sg_scope_func); i++) {
        SgInitializedName *sg_name =
            isSgInitializedName((SgNode *)GetFuncParam(sg_scope_func, i));
        mapVars[UnparseToString(sg_name)] = sg_name->get_type();
      }
    }
  } else {
    return 1;
  }

  // 2. for each array,
  // 2.1 detect the references to change
  // 2.2 apply the transformation
  map<string, SgType *>::iterator it;
  vector<size_t> vec_size;

  void *base_type = nullptr;

  int ret = 1;
  for (it = mapVars.begin(); it != mapVars.end(); it++) {
    vec_size.clear();
    base_type = nullptr;

    vector<void *> bb_collected, func_collected;

    if (linearize_arrays_detect(sg_bb_or_func_, it->first, bb_collected,
                                func_collected)) {
      get_type_dimension(it->second, base_type, vec_size);

      if (arr_name2dim.count((*it).first) == 0)
        arr_name2dim[(*it).first].assign(vec_size.begin(), vec_size.end());
    }
  }

  return ret;
}

int CSageCodeGen::linearize_arrays(void *sg_bb_or_func_) {
  size_t i;
  SgBasicBlock *sg_scope_bb = isSgBasicBlock((SgNode *)sg_bb_or_func_);
  SgFunctionDeclaration *sg_scope_func =
      isSgFunctionDeclaration((SgNode *)sg_bb_or_func_);

  // 1. find all the multi-dimensional array names in the basicblock or in the
  // function argument list
  map<string, SgType *> mapVars;
  if (sg_scope_bb) {
    vector<void *> vecRef;
    GetNodesByType_int(sg_scope_bb, "preorder", V_SgVarRefExp, &vecRef);
    for (i = 0; i < vecRef.size(); i++) {
      SgVarRefExp *ref = isSgVarRefExp((SgNode *)vecRef[i]);
      string var = UnparseToString((void *)ref);
      void *sg_type = ref->get_type();
      void *basic_type;
      vector<size_t> vec_sizes;
      int dim = get_type_dimension(sg_type, basic_type, vec_sizes, ref);
      if (mapVars.end() == mapVars.find(var) && 2 <= dim) {
        mapVars[var] = isSgType((SgNode *)sg_type);
      }
    }
  } else if (sg_scope_func) {
    if (GetFuncBody(sg_scope_func)) {
      for (i = 0; i < (size_t)GetFuncParamNum(sg_scope_func); i++) {
        SgInitializedName *sg_name =
            isSgInitializedName((SgNode *)GetFuncParam(sg_scope_func, i));
        mapVars[UnparseToString(sg_name)] = sg_name->get_type();
      }
    }
  } else {
    return 1;
  }

  // 2. for each array,
  // 2.1 detect the references to change
  // 2.2 apply the transformation
  map<string, SgType *>::iterator it;
  int ret = 1;
  for (it = mapVars.begin(); it != mapVars.end(); it++) {
    vector<void *> bb_collected, func_collected;
    if (linearize_arrays_detect(sg_bb_or_func_, it->first, bb_collected,
                                func_collected)) {
      linearize_arrays_apply(sg_bb_or_func_, it->first, it->second,
                             bb_collected, func_collected);
    } else
      ret = 0;
  }

  return ret;
}
#endif

#if 0
int CSageCodeGen::SetScope(void *stmt_, void *scope_) {
  SgStatement *stmt = isSgStatement((SgNode *)stmt_);
  SgScopeStatement *scope = isSgScopeStatement((SgNode *)scope_);
  if (!stmt || !scope)
    return 0;
  stmt->set_scope(scope);
  return 1;
}
#endif

#if 0
void *CSageCodeGen::is_pointer_ref_in_memcpy(void *var_ref) {
  void *sg_stmt = TraceUpByTypeCompatible(var_ref, V_SgStatement);
  if (!sg_stmt)
    return nullptr;
  if (!isSgExprStatement((SgNode *)sg_stmt))
    return nullptr;
  if (!isSgFunctionCallExp(
          isSgExprStatement((SgNode *)sg_stmt)->get_expression()))
    return nullptr;
  if (!IsMemCpy(isSgFunctionCallExp(
          isSgExprStatement((SgNode *)sg_stmt)->get_expression())))
    return nullptr;

  void *sg_func = isSgExprStatement((SgNode *)sg_stmt)->get_expression();

  void *sg_curr = var_ref;
  void *sg_curr_pre = sg_curr;
  while (sg_curr && sg_curr != sg_func) {
    sg_curr_pre = sg_curr;
    sg_curr = GetParent(sg_curr);
    if (sg_curr == sg_func)
      return sg_curr_pre;

    if (GetParent(sg_curr) == sg_func && isSgExprListExp((SgNode *)sg_curr))
      return sg_curr_pre;

    // FIXME: more constraints is to be added for the expression in memcpy.
  }

  return nullptr;
}

string CSageCodeGen::GetRefRenameAndInc(string port) {
  map<string, vector<string>>::iterator it;
  it = m_mapRefRenameList.find(port);
  if (m_mapRefRenameList.end() == it)
    return port;

  int idx = m_mapRefRenameIdx[it->first];
  m_mapRefRenameIdx[it->first]++;
  return it->second[idx];
}

void CSageCodeGen::InitRenameList(
    map<string, vector<string>> &mapRefRenameList) {
  m_mapRefRenameList = mapRefRenameList;
  ResetRefRenameList();
}

void CSageCodeGen::ResetRefRenameList() {
  m_mapRefRenameIdx.clear();
  map<string, vector<string>>::iterator it;
  for (it = m_mapRefRenameList.begin(); it != m_mapRefRenameList.end(); it++) {
    m_mapRefRenameIdx[it->first] = 0;
  }
}
#endif

// void * CSageCodeGen::GetLoopFromIterator(void * sg_var)
//{
//    if (!IsInitName(sg_var)) return nullptr;
//    void * sg_loop = TraceUpByTypeCompatible(sg_var, V_SgForStatement);
//
//    if (!sg_loop) return nullptr;
//    void * sg_iter = GetLoopIterator(sg_loop);
//
//    if (sg_iter != sg_var) return nullptr;
//
//    return sg_loop;
//}

#if 0
int CSageCodeGen::has_access_in_scope(void *scope, vector<string> &vec_names,
                                      string &found) {
  size_t i;
  vector<void *> vecRefs;
  GetNodesByType_int(scope, "preorder", V_SgVarRefExp, &vecRefs);
  for (i = 0; i < vecRefs.size(); i++) {
    string sVar = UnparseToString(vecRefs[i]);
    if (USE_LOWERCASE_NAME)
      sVar = get_lower_case(sVar);
    if (-1 != str_vector_find(vec_names, sVar)) {
      found = sVar;
      return 1;
    }
  }

  return 0;
}

void CSageCodeGen::InsertPipelinePragma(void *scope,
                                        vector<string> &vec_bus_e1) {
  size_t i, j;

  // 1. get kernal functon declareations
  vector<void *> vecKernelFunc;
  vector<void *> vecFuncDecl;
  GetNodesByType_int(scope, "preorder", V_SgFunctionDeclaration, &vecFuncDecl);
  for (i = 0; i < vecFuncDecl.size(); i++) {
    if (GetFuncBody(vecFuncDecl[i]) == nullptr)
      continue;
    if (GetFuncName(vecFuncDecl[i]).find("_kernel") != string::npos) {
      vecKernelFunc.push_back(vecFuncDecl[i]);
    }
  }

  // 2. add pragma into the innermost loops
  for (i = 0; i < vecKernelFunc.size(); i++) {
    vector<void *> vec_loops;
    GetNodesByType_int(vecKernelFunc[i], "preorder", V_SgForStatement,
                       &vec_loops);
    vector<void *> innermost_loops;
    for (j = 0; j < vec_loops.size(); j++) {
      string sBusE1 = "";
      if (!is_innermost_for_loop(vec_loops[j]))
        continue;
      if (!isSgScopeStatement((SgNode *)GetLoopBody(vec_loops[j])))
        continue; // only pipeline when there is a BB here (FIXME)
      if (has_access_in_scope(GetLoopBody(vec_loops[j]), vec_bus_e1, sBusE1)) {
#ifdef PROJDEBUG
        printf("[pipeline_insert] Find an innermost loop with single-access "
               "bus port \"%s\"\n",
               sBusE1.c_str());
#endif
        continue;
      } else {
        printf("[pipeline_insert] Find an innermost loop for pipeline\n");
      }
      innermost_loops.push_back(vec_loops[j]);
    }

    for (j = 0; j < innermost_loops.size(); j++) {
      void *loop_body = innermost_loops[j];
      if (GetChildStmtNum(loop_body) == 0)
        printf("\n[code_gen] Warning: No statement in loop body.\n\n");
      else {
        void *stmt = GetChildStmt(loop_body, 0);
        void *sg_new_pragma = CreatePragma("HLS pipeline II = 1\n", loop_body);
        InsertStmt(sg_new_pragma, stmt);
      }
    }
  }
}

int CSageCodeGen::access_wrapper(
    void *sg_func_, map<string, vector<string>> &mapRefRenameList,
    string func_prefix,
    map<string, vector<string>> &mapArray2Dim) // wrap all the access of the
                                               // pointer arguments with
                                               // function calls
{
  // m_mapRefRenameList: map<string port, vector<string ref_name> >;
  // m_mapRefRenameIdx:  map<string port, int>;
  InitRenameList(mapRefRenameList);

  int i;
  SgFunctionDeclaration *sg_scope_func =
      isSgFunctionDeclaration((SgNode *)sg_func_);
  assert(sg_scope_func);

  // 1. get sg_type for the function arguments
  map<string, SgType *> mapVars;
  {
    if (GetFuncBody(sg_scope_func)) {
      for (i = 0; i < GetFuncParamNum(sg_scope_func); i++) {
        SgInitializedName *sg_name =
            isSgInitializedName((SgNode *)GetFuncParam(sg_scope_func, i));
        mapVars[UnparseToString(sg_name)] = sg_name->get_type();
      }
    }
  }

  // 2. for each argument,
  // 2.1 detect the references to change
  // 2.2 apply the transformation
  map<string, SgType *>::iterator it;
  int ret = 1;
  for (it = mapVars.begin(); it != mapVars.end(); it++) {
    map<string, bool> mapFuncVisited;
    mapFuncVisited.clear();
    if (!one_access_wrapper(sg_func_, it->first, it->first, func_prefix,
                            mapArray2Dim, mapFuncVisited))
      ret = 0;

    // 3. change the port data type to 1-D pointer after replacing all the
    // references
    {
      SgFunctionDeclaration *sg_func_decl =
          isSgFunctionDeclaration((SgNode *)sg_func_);
      string sFuncName = GetFuncName(sg_func_decl);

      vector<void *> vecDecls = GetAllFuncDeclByName(sFuncName);
      for (size_t k = 0; k < vecDecls.size(); k++) {
        if (sFuncName != GetFuncName(vecDecls[k]))
          continue;
        sg_func_decl = isSgFunctionDeclaration((SgNode *)vecDecls[k]);
        assert(sg_func_decl);

        int arg_idx = -1;
        for (int j = 0; j < GetFuncParamNum(sg_func_decl); j++) {
          void *arg = GetFuncParam(sg_func_decl, j);
          string sArg = UnparseToString(arg);
          if (sArg == it->first) {
            arg_idx = j;
            break;
          }
        }
        assert(arg_idx != -1);

        void *arg = GetFuncParam(sg_func_decl, arg_idx);
        SgInitializedName *sg_arg = isSgInitializedName((SgNode *)arg);
        assert(sg_arg);
        SgType *sg_type = sg_arg->get_type();
        SgPointerType *sg_ptr_type = isSgPointerType(sg_type);
        if (!sg_ptr_type)
          continue;
        // assert(sg_ptr_type);
        sg_type = isSgType((SgNode *)trace_base_type(sg_ptr_type));
        assert(sg_type);
        sg_type = SageBuilder::buildVolatileType(sg_type);
        // markBuild(* this, sg_type, "Build in " + to_string(__LINE__) + " for
        // " + to_string((long) sg_type));
        if (sg_ptr_type) {
          sg_type = SageBuilder::buildPointerType(sg_type);
          // markBuild(* this, sg_type, "Build in " + to_string(__LINE__) + "
          // for " + to_string((long) sg_type));
        }
        sg_arg->set_type(sg_type);
      }
    }

    // 4. change the argument expression to 1-D pointer in the function callings
    {
      SgFunctionDeclaration *sg_func_decl =
          isSgFunctionDeclaration((SgNode *)sg_func_);
      string sFuncName = GetFuncName(sg_func_decl);

      vector<void *> vecCalls = GetAllFuncCallByName(sFuncName);
      for (size_t k = 0; k < vecCalls.size(); k++) {
#ifdef PROJDEBUG
        printf("[] %s\n", sFuncName.c_str());
#endif
        int arg_idx = -1;
        void *arg = nullptr;
        for (int j = 0; j < GetFuncParamNum(sg_func_decl); j++) {
          arg = GetFuncCallParam(vecCalls[k], j);
          if (!arg)
            continue;
          string sArg = UnparseToString(arg);
          if (sArg == it->first) {
            arg_idx = j;
            break;
          }
        }
        assert(arg_idx != -1);

        void *arg_core = arg;
        if (isSgCastExp((SgNode *)arg)) {
          arg_core = isSgCastExp((SgNode *)arg)->get_operand();
        }

        if (mapArray2Dim.find(it->first) != mapArray2Dim.end() &&
            mapArray2Dim[it->first].size() > 1 && IsVarRefExp(arg_core)) {

          int dim = (int)mapArray2Dim[it->first].size();
          int dim_i;

          vector<void *> vecIndex;
          for (dim_i = 0; dim_i < dim; dim_i++) {
            void *new_exp = CreateConst(0);
            vecIndex.push_back(new_exp);
          }
          void *array_ref = CreateArrayRef(CopyExp(arg_core), vecIndex);
          void *address_of = CreateExp(V_SgAddressOfOp, array_ref);
          ReplaceExp(arg, address_of);
        }
      }
    }
  }

  return ret;
}

void *CSageCodeGen::pointer_to_array_recur(void *sg_type) {
  if (isSgModifierType((SgNode *)sg_type)) {
    // remove Modified type
    return pointer_to_array_recur(
        isSgModifierType((SgNode *)sg_type)->get_base_type());
  } else if (isSgPointerType((SgNode *)sg_type)) {
    void *sg_base = pointer_to_array_recur(
        isSgPointerType((SgNode *)sg_type)->get_base_type());

    auto sg_new_type = SageBuilder::buildArrayType(
        isSgType((SgNode *)sg_base),
        isSgExpression((SgNode *)CreateConst(1024)));
    // markBuild(* this, sg_new_type, "Build in " + to_string(__LINE__) + " for
    // " + to_string((long) sg_new_type));
    return sg_new_type;
  } else
    return sg_type;
}
#endif

#if 0
void *CSageCodeGen::GetBaseTypeByModifierType(void *sg_type_) {
  if (SgModifierType *sg_m_type = isSgModifierType((SgNode *)sg_type_)) {
    void *base_type = sg_m_type->get_base_type();
    return GetBaseTypeByModifierType(base_type);
  }
  return sg_type_;
}
#endif

#if 0
void CSageCodeGen::get_all_func_path_in_scope_int(
    void *array, void *range_scope, list<t_func_call_path> &vec_paths) {
  vec_paths.clear();

  vector<void *> vec_calls;
  GetNodesByType_int_compatible(range_scope, V_SgFunctionCallExp, vec_calls);

  for (size_t i = 0; i < vec_calls.size(); i++) {
    void *sg_call = vec_calls[i];
    void *sg_decl = GetFuncDeclByCall(sg_call);
    void *sg_body = GetFuncBody(sg_decl);
    if (sg_decl && sg_body) {
      int arg_num = GetFuncParamNum(sg_decl);
      void *new_array = nullptr;
      for (int j = 0; j != arg_num; ++j) {
        void *arg = GetFuncCallParam(sg_call, j);
        if (!arg)
          continue;
        void *array_ref;
        parse_array_ref_from_pntr(arg, array_ref, sg_call);
        if (!array_ref)
          continue;
        void *var_init = GetVariableInitializedName(array_ref);
        if (var_init != array) {
          continue;
        }
        new_array = GetFuncParam(sg_decl, j);
        break;
      }
      if (!new_array)
        continue;
      pair<void *, void *> edge(sg_decl, sg_call);

      // Youxiang 20180627 do not analysis the implementation of wide bus
      if (GetFuncName(sg_decl).find("memcpy_wide_bus_") == 0) {
        t_func_call_path path;
        path.push_back(edge);
        vec_paths.push_back(path);
        continue;
      }
      list<t_func_call_path> tmp_paths;

      get_all_func_path_in_scope_int(new_array, sg_body, tmp_paths);

      for (auto path : tmp_paths) {
        path.push_back(edge);
        vec_paths.push_back(path);
      }
    }
  }

  if (vec_paths.size() == 0) {
    t_func_call_path empty_path;
    vec_paths.push_back(empty_path);
  }
}
#endif

#if 0
int CSageCodeGen::Expr2Vector(SgExpression *sgExp, string &poly_vec,
                              vector<string> &vec_var, int force_linear) {
  /////////////////////////
  // ZP: 20150722: to be out-dated
  // assert(false);
  /////////////////////////

  sgExp->unparseToString();

  string vec1, vec2;
  string item, flag;

  if (isSgBinaryOp(sgExp)) {
    SgBinaryOp *sgbinOp = isSgBinaryOp(sgExp);
    SgExpression *sgOprand1 = sgbinOp->get_lhs_operand();
    SgExpression *sgOprand2 = sgbinOp->get_rhs_operand();
    if (!Expr2Vector(sgOprand1, vec1, vec_var))
      return 0;
    if (!Expr2Vector(sgOprand2, vec2, vec_var))
      return 0;
  }

  if (isSgCastExp(sgExp)) {
    SgCastExp *sgbinOp = isSgCastExp(sgExp);
    SgExpression *sgOprand1 = sgbinOp->get_operand();
    return Expr2Vector(sgOprand1, poly_vec, vec_var, force_linear);
  } else if (isSgDoubleVal(sgExp)) // fixed by zhangpeng, 2011-08-17
  {
    item = sgExp->unparseToString();
    poly_vec = "(" + item + ")";
    return 1;
  } else if (isSgValueExp(sgExp)) {
    int64_t value = 0;
    if (!IsConstantInt(sgExp, value))
      return 0;
    char value_char[256];

    sprintf(value_char, "%lld", value);

    item = value_char;
    poly_vec = poly_vec + item;
    poly_vec = "(" + poly_vec + ")";
    return 1;
  } else if (isSgVarRefExp(sgExp)) {
    SgInitializedName *var =
        isSgVarRefExp(sgExp)->get_symbol()->get_declaration();

    // TODO : get parameter or loop count for specific loop, if not exist (new
    // parameters), create with the sgnode
    // PolyVector item(GetAnode_ex(var, sgExp), 1);
    item = var->unparseToString();
    size_t i;
    for (i = 0; i < vec_var.size(); i++) {
      if (vec_var[i] == item)
        break;
    }
    if (i == vec_var.size())
      vec_var.push_back(item);

    if (DEBUG)
      cout << "-- DEBUG: find var " << item << endl;

    // if(!(poly_vec.size() == 0 && item.size() == 0))
    poly_vec = poly_vec + item;
    poly_vec = "(" + poly_vec + ")";
    return 1;
  } else if (isSgAddOp(sgExp)) {
    poly_vec = vec1 + "+" + vec2;
    poly_vec = "(" + poly_vec + ")";
    return 1;
  } else if (isSgSubtractOp(sgExp)) {
    poly_vec = vec1 + "-" + vec2;
    poly_vec = "(" + poly_vec + ")";
    return 1;
  } else if (isSgMultiplyOp(sgExp)) {
    //	int level1 = vec1.level();
    //	int level2 = vec2.level();
    //	if (level1 == 0 || level2 == 0)
    //	{
    poly_vec = vec1 + "*" + vec2;
    poly_vec = "(" + poly_vec + ")";
    //	}
    /*	else // high order term generated by multiplication - non linear
        {
    //PolyVector item(sgExp->unparseToString(), 1);
    item = sgExp->unparseToString();
    poly_vec = poly_vec + "+" + item;
    if (force_linear) return 0;
    }*/
    return 1;
  } else if (isSgDivideOp(sgExp)) {
    // to be fixed: only allow division between constant & user-specified
    // kernel-invariant parameter
    poly_vec = vec1 + "/" + vec2;
    poly_vec = "(" + poly_vec + ")";
    return 1;
  }
  //////////////////////////////////////////////////////////////////////////
  // for boolean conditions
  else if (isSgEqualityOp(sgExp)) {
    poly_vec = vec2 + "-" + vec1;
    // PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_EQ);
    flag = "==";
    poly_vec = poly_vec + flag;
    poly_vec = "(" + poly_vec + ")";
    if (force_linear) {
      if (DEBUG_FORCE_ASSERT)
        assert(0);
      return 0;
    }
  } else if (isSgNotEqualOp(sgExp)) {
    poly_vec = vec2 + "-" + vec1;
    // PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_NE);
    flag = "!=";
    poly_vec = poly_vec + flag;
    poly_vec = "(" + poly_vec + ")";
    if (force_linear) {
      if (DEBUG_FORCE_ASSERT)
        assert(0);
      return 0;
    }
  } else if (isSgLessThanOp(sgExp)) {
    poly_vec = vec2 + "-" + vec1;
    // PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_GT);
    flag = "<";
    poly_vec = poly_vec + flag;
    poly_vec = "(" + poly_vec + ")";
    if (force_linear) {
      if (DEBUG_FORCE_ASSERT)
        assert(0);
      return 0;
    }
  } else if (isSgLessOrEqualOp(sgExp)) {
    poly_vec = vec2 + "-" + vec1;
    // PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_GE);
    flag = "<=";
    poly_vec = poly_vec + flag;
    poly_vec = "(" + poly_vec + ")";
    if (force_linear) {
      if (DEBUG_FORCE_ASSERT)
        assert(0);
      return 0;
    }
  } else if (isSgGreaterThanOp(sgExp)) {
    poly_vec = vec1 + "-" + vec2;
    // PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_GT);
    flag = ">";
    poly_vec = poly_vec + flag;
    poly_vec = "(" + poly_vec + ")";
    if (force_linear) {
      if (DEBUG_FORCE_ASSERT)
        assert(0);
      return 0;
    }
  } else if (isSgGreaterOrEqualOp(sgExp)) {
    poly_vec = vec1 + "-" + vec2;
    // PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_GE);
    flag = ">=";
    poly_vec = poly_vec + flag;
    poly_vec = "(" + poly_vec + ")";
    if (force_linear) {
      if (DEBUG_FORCE_ASSERT)
        assert(0);
      return 0;
    }
  }
  //////////////////////////////////////////////////////////////////////////
  else if (isSgFunctionCallExp(sgExp)) {
    item = sgExp->unparseToString();
    if (poly_vec.size() != 0)
      poly_vec = poly_vec + "+" + item;
    else
      poly_vec = item;
    poly_vec = "(" + poly_vec + ")";
    if (force_linear) {
      if (DEBUG_FORCE_ASSERT)
        assert(0);
      return 0;
    }
  } else {
    // PolyVector item(sgExp->unparseToString(), 1);
    item = sgExp->unparseToString();
    if (poly_vec.size() != 0)
      poly_vec = poly_vec + "+" + item;
    else
      poly_vec = item;

    poly_vec = "(" + poly_vec + ")";
    if (force_linear) {
      if (DEBUG_FORCE_ASSERT)
        assert(0);
      return 0;
    }

    // assert(false);
#ifdef PROJDEBUG
    cout << "[codegen] Warning: Unrecognized type of Expression: "
         << sgExp->unparseToString() << " - " << sgExp->class_name() << endl;
#endif
    if (FORCE_ASSERT)
      assert(false);
  }

  return 1;
}


// return 0 if failed to convert into a linear form
int CSageCodeGen::Expr2Vector(void *sgExp_, PolyVector &poly_vec,
                              int force_linear) {

  SgExpression *sgExp = isSgExpression((SgNode *)sgExp_);

  PolyVector vec1, vec2;

  if (isSgUnaryOp(sgExp)) {

    if (isSgMinusOp(sgExp)) {
      int value = 0;
      SgUnaryOp *sguinOp = isSgUnaryOp(sgExp);
      //	    cout << "00000" << sguinOp->get_operand()->unparseToString()
      //<< endl;
      SgExpression *sgOprand1 = sguinOp->get_operand();
      if (isSgIntVal(sgOprand1)) {
        value = -(isSgIntVal(sgOprand1)->get_value());
        //		cout<< value <<endl;

        PolyVector item(PolyVector::CONST_POINTER, value);
        poly_vec = poly_vec + item;
        return 1;
      }
    }
    return 0;
  }

  if (isSgBinaryOp(sgExp)) {
    SgBinaryOp *sgbinOp = isSgBinaryOp(sgExp);
    SgExpression *sgOprand1 = sgbinOp->get_lhs_operand();
    SgExpression *sgOprand2 = sgbinOp->get_rhs_operand();
    if (!Expr2Vector(sgOprand1, vec1))
      return 0;
    if (!Expr2Vector(sgOprand2, vec2))
      return 0;
  }

  if (isSgCastExp(sgExp)) {
    SgCastExp *sgbinOp = isSgCastExp(sgExp);
    SgExpression *sgOprand1 = sgbinOp->get_operand();
    return Expr2Vector(sgOprand1, poly_vec, force_linear);
  } else if (isSgDoubleVal(sgExp)) // fixed by zhangpeng, 2011-08-17
  {
    PolyVector item(sgExp->unparseToString(), 1);
    poly_vec = poly_vec + item;
    return 1;
  } else if (isSgValueExp(sgExp)) {
    int64_t value = 0;
    if (!IsConstantInt(sgExp, value)) {
      // fixed by youxiang, 2015-11-09, TemplateParameterValue
      if (force_linear) {
        printf(
            "[codegen] ERROR: non-linear expression inside access pattern \n");
        return 0;
      }
      return 1;
    }

    PolyVector item(PolyVector::CONST_POINTER, value);
    poly_vec = poly_vec + item;
    return 1;
  } else if (isSgVarRefExp(sgExp)) {
    SgInitializedName *var =
        isSgVarRefExp(sgExp)->get_symbol()->get_declaration();

    // TODO : get parameter or loop count for specific loop, if not exist (new
    // parameters), create with the sgnode
    // PolyVector item(GetAnode_ex(var, sgExp), 1);
    PolyVector item(var->unparseToString(), 1);
    poly_vec = poly_vec + item;
    return 1;
  } else if (isSgAddOp(sgExp)) {
    poly_vec = vec1 + vec2;
    return 1;
  } else if (isSgSubtractOp(sgExp)) {
    poly_vec = vec1 - vec2;
    return 1;
  } else if (isSgMultiplyOp(sgExp)) {
    int level1 = vec1.level();
    int level2 = vec2.level();
    if (level1 == 0 || level2 == 0) {
      poly_vec = vec1 * vec2;
    } else // high order term generated by multiplication - non linear
    {
      PolyVector item(sgExp->unparseToString(), 1);
      poly_vec = poly_vec + item;
      if (force_linear) {
        printf(
            "[codegen] ERROR: non-linear expression inside access pattern \n");
        return 0;
      }
      // if (force_linear) return 0;
    }
    return 1;
  } // Add by Yuxin: didnt consider divide operation before Jun 27 2015
  else if (isSgDivideOp(sgExp)) {
    int level1 = vec1.level();
    int level2 = vec2.level();
    int value = 0;
    SgBinaryOp *sgbinOp = isSgBinaryOp(sgExp);
    SgExpression *sgExp2 = sgbinOp->get_rhs_operand();
    if (isSgValueExp(sgExp2)) {
      if (isSgIntVal(sgExp2)) {
        value = isSgIntVal(sgExp2)->get_value();
      } else
        return 0;
    } else
      return 0;

    if (value && (level1 == 0 || level2 == 0)) {
      poly_vec = vec1 / value;
    } else // high order term generated by multiplication - non linear
    {
      PolyVector item(sgExp->unparseToString(), 1);
      poly_vec = poly_vec + item;
      if (force_linear) {
        printf("[codegen] ERROR: non-linear expression inside access pattern ");
        return 0;
      }
      // if (force_linear) return 0;
    }
    return 1;
  }
  //////////////////////////////////////////////////////////////////////////
  // for boolean conditions
  else if (isSgEqualityOp(sgExp)) {
    poly_vec = vec2 - vec1;
    PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_EQ);
    poly_vec = poly_vec + flag;
    if (force_linear) {
      printf("[codegen] ERROR: Equal expression inside access pattern ");
      return 0;
    }
    // if (force_linear) return 0;
  } else if (isSgNotEqualOp(sgExp)) {
    poly_vec = vec2 - vec1;
    PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_NE);
    poly_vec = poly_vec + flag;
    if (force_linear) {
      printf("[codegen] ERROR: notEqual expression inside access pattern ");
      return 0;
    }
    // if (force_linear) return 0;
  } else if (isSgLessThanOp(sgExp)) {
    poly_vec = vec2 - vec1;
    PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_GT);
    poly_vec = poly_vec + flag;
    if (force_linear) {
      printf("[codegen] ERROR: lessThan expression inside access pattern ");
      return 0;
    }
    // if (force_linear) return 0;
  } else if (isSgLessOrEqualOp(sgExp)) {
    poly_vec = vec2 - vec1;
    PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_GE);
    poly_vec = poly_vec + flag;
    if (force_linear) {
      printf("[codegen] ERROR: lessOrEqual expression inside access pattern ");
      return 0;
    }
    // if (force_linear) return 0;
  } else if (isSgGreaterThanOp(sgExp)) {
    poly_vec = vec1 - vec2;
    PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_GT);
    poly_vec = poly_vec + flag;
    if (force_linear) {
      printf("[codegen] ERROR: greaterThan expression inside access pattern ");
      return 0;
    }
    // if (force_linear) return 0;
  } else if (isSgGreaterOrEqualOp(sgExp)) {
    poly_vec = vec1 - vec2;
    PolyVector flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_GE);
    poly_vec = poly_vec + flag;
    if (force_linear) {
      printf(
          "[codegen] ERROR: greaterOrEqual expression inside access pattern ");
      return 0;
    }
    // if (force_linear) return 0;
  }
  //////////////////////////////////////////////////////////////////////////
  else if (isSgFunctionCallExp(sgExp)) {
    PolyVector item(sgExp->unparseToString(), 1);
    poly_vec = poly_vec + item;
    if (force_linear) {
      printf(
          "[codegen] ERROR: function call expression inside access pattern ");
      return 0;
    }
  } else if (isSgCastExp(sgExp)) {
    PolyVector item(sgExp->unparseToString(), 1);
    poly_vec = poly_vec + item;
    if (force_linear) {
      printf("[codegen] ERROR: type_cast expression inside access pattern ");
      return 0;
    }
  } else {
    PolyVector item(sgExp->unparseToString(), 1);
    poly_vec = poly_vec + item;
    if (force_linear) {
      printf(
          "[codegen] ERROR: Unrecognized expression inside access pattern \n");
      return 0;
    }

    // assert(false);
  }

  return 1;
}

int CSageCodeGen::get_const_value(void *exp_, int &a) {
  PolyVector poly_vec;
  SgExpression *sg_exp = isSgExpression((SgNode *)exp_);
  Expr2Vector(sg_exp, poly_vec);

  if (!poly_vec.is_const())
    return 0;

  a = poly_vec.get_const();
  return 1;
}
#endif

#if 0
void *CSageCodeGen::CreateAggregateInitializer(void *expr_list_,
                                               void *sg_type) {
  SgExprListExp *expr_list = isSgExprListExp((SgNode *)expr_list_);
  void *aggr_initializer = SageBuilder::buildAggregateInitializer(
      expr_list, isSgType((SgNode *)sg_type));
  return aggr_initializer;
}
#endif

/*
CSageCodeGen::CSageCodeGen(string sFileName) {
  m_defuse = nullptr;
  m_liveness = nullptr;
  m_callgraph = nullptr;
  s_liveness_previous_func = nullptr;
  m_tfn_syms_valid = false;
  m_tc_syms_valid = false;
  vector<string> vecFiles;
  vecFiles.push_back(sFileName);
  m_sg_project = isSgProject((SgNode *)CreateSourceFile(vecFiles));

  s_liveness_previous_func = nullptr;

#if 0
  if (!m_defuse || !m_liveness) {
    init_defuse();
  }
#endif
  // ZP: 20160812: call graph is not stable, so we moved to here so that it can
  // be turned off
  //  if (!m_callgraph) {
  //    init_callgraph();
  //  }

#if _INITIAL_RANGE_ANALYSIS_
  reset_range_analysis();
#else
  m_init_range = 0;
#endif
}
*/

/*
void *CSageCodeGen::CreateSourceFile(vector<string> sFileName) {
  size_t i;
  string s_empty = " ";

  int argc = 1 + sFileName.size();
  char *argv[12];
  char tmp_arg[2][1024];
  strcpy(tmp_arg[0], "exe_name");
  argv[0] = tmp_arg[0];
  char argvv[10][1024];
  assert(sFileName.size() < 10);
  m_inputFiles.clear();
  for (i = 0; i < sFileName.size(); i++) {
    // if (!test_file_for_read(sFileName[i])) // TODO: FIXME: support for append
    // to files
    { write_string_into_file(s_empty, sFileName[i]); }

    strcpy(argvv[i], sFileName[i].c_str());
    argv[i + 1] = argvv[i];
    m_inputFiles.insert(sFileName[i]);
  }
  strcpy(tmp_arg[1], "-I./");
  argv[argc++] = tmp_arg[1];
  ;
  // argv[i+2] = "-I/usr/include/linux"; //ZP: 2014-04-22: to fix the gcc
  // version conflict problem in some machines (where stddef.h can not be found)

  SgProject *project = frontend(argc, argv);
  m_sg_project = project;
  //if (!m_defuse || !m_liveness) {
    //init_defuse();
  //}

  // ZP: 20160812: call graph is not stable, so we moved to here so that it can
  // be turned off
  // if (!m_callgraph) {
  //  init_callgraph();
  //}

#if _INITIAL_RANGE_ANALYSIS_
  reset_range_analysis();
#else
  m_init_range = 0;
#endif
  return project;
}
*/

#if 0
int CSageCodeGen::IsForwardInitName(void *sg_node) {
  // ROSE has bug to determine forward variable declaration
  assert(0);

  // SgInitializedName * sg_name = isSgInitializedName((SgNode*)sg_node) ;
  // if (!sg_name) return 0;
  // SgDeclarationStatement * sg_decl = sg_name -> get_declaration();
  // if (!sg_decl) return 0;

  // void * sg_global = GetGlobal(sg_node);
  // void * sg_scope = TraceUpByTypeCompatible(sg_node, V_SgScopeStatement);

  // if (sg_scope != sg_global) return 0;
  //
  // return sg_decl->isForward();
}
#endif

#if 0
int CSageCodeGen::AddCastToExp(void *sg_exp, string s_type) {
  SgType *sg_type = isSgType((SgNode *)GetTypeByString(s_type));
  if (!sg_type)
    return 0;
  return AddCastToExp(sg_exp, sg_type);
}
#endif

#if 0
void *CSageCodeGen::GetFuncParamFromCallArg(void *sg_arg) {
  int arg_idx;
  if (-1 == (arg_idx = GetFuncCallParamIndex(sg_arg)))
    return nullptr;

  void *sg_call = TraceUpToFuncCall(sg_arg);
  if (!sg_call)
    return nullptr;

  void *sg_decl = GetFuncDeclByCall(sg_call);
  if (!sg_decl)
    return nullptr;

  void *sg_body = GetFuncBody(sg_decl);
  if (!sg_body)
    return nullptr;

  return GetFuncParam(sg_decl, arg_idx);
}

vector<void *> CSageCodeGen::GetFuncReturnStmt(void *sg_scope) {
  vector<void *> return_stmt;
  vector<void *> all_stmts;
  GetNodesByType_int(sg_scope, "preorder", V_SgStatement, &all_stmts);
  for (size_t i = 0; i < all_stmts.size(); i++) {
    if (isSgReturnStmt((SgNode *)all_stmts[i])) {
      return_stmt.push_back(all_stmts[i]);
    }
  }
  return return_stmt;
}
#endif

#if 0
void *CSageCodeGen::CreateExpList(vector<size_t> dims, void *sg_var,
                                  void *bindNode) {
  if (dims.empty())
    return CreateVariableRef(sg_var, bindNode);
  vector<void *> vec_exp;
  vector<size_t> sub_dims;
  int j = 0;
  for (auto dim : dims) {
    if (j + 1 < dims.size())
      sub_dims.push_back(dim);
    j++;
  }

  int i = 0;
  while (i++ < dims.back()) {
    vec_exp.push_back(CreateExpList(sub_dims, sg_var, bindNode));
  }
  return CreateExpList(vec_exp, bindNode);
}
#endif

#if 0
// Mo
bool CSageCodeGen::GetChildTaskIdx(void *sg_scope_, void *sg_child_, int &index,
                                   int HGT) {
  size_t i;
  SgScopeStatement *sg_scope = isSgScopeStatement((SgNode *)sg_scope_);
  SgStatement *sg_child = isSgStatement((SgNode *)sg_child_);
  // assert(sg_scope);

  // Mo, 2013.12.23 when using assert, BUG: when if-else without scope, fail in
  // recursive call!
  if (!sg_scope) {
    if (sg_scope == sg_child)
      return true;
    else
      return false;
  }
  // Mo, 2013.12.23 add to deal with if-else if...
  if (isSgIfStmt(sg_scope)) {
#ifdef MO_VERBOSE
    cout << "scope, now recur!\n";
#endif
    if (GetChildTaskIdx(((SgIfStmt *)sg_scope)->get_true_body(), sg_child,
                        index, HGT))
      return true;
    if (((SgIfStmt *)sg_scope)->get_false_body()) {
      index++;
      if (GetChildTaskIdx(((SgIfStmt *)sg_scope)->get_false_body(), sg_child,
                          index, HGT))
        return true;
    }
    return false;
  }

#ifdef MO_VERBOSE
  cout << "DEBUG: " << UnparseToString(sg_scope) << endl
       << isSgIfStmt(sg_scope) << endl;
#endif
  SgStatementPtrList &stmt_lst = sg_scope->getStatementList();
  for (i = 0; i < stmt_lst.size(); i++) {
    index++;
#ifdef MO_VERBOSE
    cout << "children:" << i << "\n"
         << UnparseToString(stmt_lst[i]) << endl
         << endl;
#endif
    if (sg_child_ == stmt_lst[i]) {
#ifdef MO_VERBOSE
      cout << "bingo!\n";
#endif
      return true;
    }
    string str = GetPragmaString((SgNode *)stmt_lst[i]);
    // if the child is a pragma, and the pragma is a task_block

    // XP : 2014-04-05
    // if ((HGT == 3 && str.substr(0, 15) == "tldm task_block") || (HGT == 2 &&
    // str.substr(0, 16) == "tldm graph_block"))
    if ((HGT == 3 && ((str.substr(0, 15) == "tldm task_block") ||
                      (str.substr(0, 16) == "cmost task_block"))) ||
        (HGT == 2 && ((str.substr(0, 16) == "tldm graph_block") ||
                      (str.substr(0, 17) == "cmost graph_block")))) {
      // find the adjacent block and compare
      if (stmt_lst[++i] == sg_child) {
#ifdef MO_VERBOSE
        cout << "bingo pragma!\n";
#endif
        return true;
      } else {
//			index++;
#ifdef MO_VERBOSE
        cout << "++index, index is now " << index << endl;
#endif
      }
    } else if ("" != str)
      continue;
    // if the child is a for statement
    if (IsForStatement(stmt_lst[i])) {
      if (sg_child_ == stmt_lst[i]) {
#ifdef MO_VERBOSE
        cout << "bingo for!\n";
#endif
        return true;
      } else {

//				index++;
#ifdef MO_VERBOSE
        cout << "++index, index is now " << index << endl;
#endif
      }
    }
    // added by ZP for MO: 2013-12-11
    else if (isSgIfStmt(stmt_lst[i]) != nullptr) {
#ifdef MO_VERBOSE
      cout << "scope, now recur!\n";
#endif
      if (GetChildTaskIdx(((SgIfStmt *)stmt_lst[i])->get_true_body(), sg_child,
                          index, HGT))
        return true;
      if (((SgIfStmt *)stmt_lst[i])->get_false_body()) {
        index++;
        if (GetChildTaskIdx(((SgIfStmt *)stmt_lst[i])->get_false_body(),
                            sg_child, index, HGT))
          return true;
      }
    } else if (IsBasicBlock(stmt_lst[i])) {
#ifdef MO_VERBOSE
      cout << "scope, now recur!\n";
#endif
      if (GetChildTaskIdx(stmt_lst[i], sg_child, index, HGT))
        return true;
    }
  }
  return false;
}
#endif

#if 0
void *CSageCodeGen::CreateFuncDecl(void *ret_type, string sFuncName,
                                   vector<string> vec_name,
                                   vector<void *> vec_type, void *sg_scope,
                                   bool definition,
                                   void *bindNode /*= nullptr*/) {
  size_t i;
  vector<void *> fp_list;
  for (i = 0; i < vec_name.size(); i++) {
    void *sg_param = CreateVariable(vec_type[i], vec_name[i]);
    fp_list.push_back(sg_param);
  }
  void *sg_func_decl = CreateFuncDecl(ret_type, sFuncName, fp_list, sg_scope,
                                      definition, bindNode);

  return sg_func_decl;
}
#endif

#if 0
string CSageCodeGen::GetMangledFuncName(void *sg_decl_) {
  SgNode *sg_decl = (SgNode *)sg_decl_;
  SgFunctionDeclaration *sg_func = isSgFunctionDeclaration(sg_decl);
  if (!sg_func && isSgFunctionDefinition(sg_decl)) {
    sg_func = isSgFunctionDefinition(sg_decl)->get_declaration();
  }
  if (!sg_func)
    return "";
  // if (!isCppLinkage(sg_decl_))
  //  return sg_func->get_name();
  return sg_func->get_mangled_name();
}
#endif

#if 0
void *CSageCodeGen::CopyFuncDecl(void *sg_decl_, string sFuncName) {

  // ZP: 20151105 Please have a discussion with me if you have any problem
  // In general this function is not safe, especiallly in C++
  // It will lose the symbolic link between the declaration and reference
  //
  // Note: if we only want to change the function name, please use
  // SetFuncName() instead.
  assert(0);

  SgNode *sg_decl = (SgNode *)sg_decl_;
  SgFunctionDeclaration *sg_func = isSgFunctionDeclaration(sg_decl);
  if (!sg_func)
    return nullptr;
  // else return sg_func->set_name(sFuncName);

  // 1. create a copy of the basicblock
  // SEAN: do not need to copy here
  // otherwise, it will be floating
  void *sg_body;
  { sg_body = GetFuncBody(sg_decl); }

  // 2. create the argument list
  vector<void *> arg_list;
  for (int i = 0; i < GetFuncParamNum(sg_decl); i++) {
    void *init_name = GetFuncParam(sg_decl, i);
    void *type = GetTypebyVar(init_name);
    string var = UnparseToString(init_name);

    SgInitializedName *sg_param =
        SageBuilder::buildInitializedName(var, (SgType *)type);
    markBuild(*this, sg_param,
              "Build in " + to_string(__LINE__) + " for " +
                  to_string((long)sg_param));
    arg_list.push_back(sg_param);
  }

  //{
  //	if (GetFuncParamNum(sg_decl) != 0)
  //	{
  //		printf("[codegen] ReplaceMainFuncName only supports main()
  // without
  // any arguments \n");
  //		assert(0);
  //	}
  //	assert(GetFuncParamNum(sg_decl) == 0);
  //}

  // 3. create funciton declaration
  void *sg_decl_new;
  {
    sg_decl_new = CreateFuncDecl("int", sFuncName, arg_list, GetGlobal(sg_decl),
                                 true, sg_decl);

    void *sg_body_new = GetFuncBody(sg_decl_new);

    for (int i = 0; i < GetChildStmtNum(sg_body); i++) {
      void *stmt = GetChildStmt(sg_body, i);
      // SEAN: copy here
      AppendChild(sg_body_new, CopyStmt(stmt));
    }
  }

  AppendChild(GetParent(sg_decl), sg_decl_new);

  return sg_decl_new;
}
#endif

#if 0
void *CSageCodeGen::GetVariableSymbol(void *sg_var_ref_) {
  SgVarRefExp *sg_var_ref = isSgVarRefExp((SgNode *)sg_var_ref_);
  assert(sg_var_ref);
  return sg_var_ref->get_symbol();
}
#endif

#if 0
// get the uniq actual declaration (across function)
void *CSageCodeGen::get_actual_var_decl_by_ref(void *var_ref) {
  void *sg_init = GetVariableInitializedName(var_ref);
  if (!sg_init)
    return nullptr;

  if (!IsArgumentInitName(sg_init))
    return GetVariableDecl(var_ref);

  int idx = GetFuncParamIndex(sg_init);
  assert(-1 == idx);

  void *func_decl = TraceUpToFuncDecl(sg_init);
  assert(func_decl);

  vector<void *> sg_calls;
  GetFuncCallsFromDecl(func_decl, nullptr, sg_calls);
  if (sg_calls.size() != 1)
    return nullptr;

  void *actual_exp = GetFuncCallParam(sg_calls[0], idx);
  if (!actual_exp)
    return nullptr;
  remove_cast(actual_exp);

  if (!IsVarRefExp(actual_exp))
    return nullptr;

  return get_actual_var_decl_by_ref(actual_exp);
}
#endif

#if 0
void *CSageCodeGen::CreatePointerType(void *base_type, int levels,
                                      void *bindNode /*= nullptr*/) {
  SgType *curr_type = (SgType *)base_type;

  for (int i = 0; i < levels; i++)
    curr_type = (SgType *)CreatePointerType(curr_type, bindNode);

  return curr_type;
}
#endif

#if 0
// Yuxin Aug 2016
void *CSageCodeGen::CreateConst(short value_, void *bindNode /*= nullptr*/) {
  auto sg_type = SageBuilder::buildShortVal(value_);
  markBuild(*this, sg_type,
            "Build in " + to_string(__LINE__) + " for " +
                to_string((long)sg_type),
            bindNode);
  return sg_type;
}
#endif

#if 0
void *CSageCodeGen::CopyVarDeclStmt(void *sg_stmt_, void *scope) {
  void *sg_name = GetVariableInitializedName(sg_stmt_);
  string s_var = _up(sg_name);
  void *sg_type = GetTypebyVar(sg_name);
  void *sg_init = nullptr;
  if (GetInitializer(sg_name))
    sg_init = CopyExp(GetInitializer(sg_name));

  return CreateVariableDecl(sg_type, s_var, sg_init, scope);
}

void *CSageCodeGen::CopyInitName(void *sg_name) {
  string s_var = _up(sg_name);
  void *sg_type = GetTypebyVar(sg_name);

  return CreateVariable(sg_type, s_var);
}
#endif

#if 0

void CSageCodeGen::GeneratePDF() { generatePDF(*m_sg_project); }
#endif

#if 0
void * CSageCodeGen::CreateFuncDeclFromScoplib(string sFuncName, scoplib_scop_p scop)
{
    int i;
    vector<int> iterator_length;
    vector<string> iterator_name;
    iterator_name.push_back("block");
    iterator_length.push_back(12);
    iterator_name.push_back("i");
    iterator_length.push_back(3);

    {
        //string sFuncName = string("idct_row_loop_core");
        string sFileName = sFuncName+string(".c");
        CSageCodeGen codegen("tmp.c");
        void * sg_project = codegen.GetProject();
        void * sg_global  = codegen.GetGlobal();

        codegen.InitBuiltinTypes();

        string sType;
        SgType * sg_type;
        vector<void *> fp_list;

        // Create Function Declaration
        int total_iterator_length = 0;
        for (i = 0; i < iterator_length.size(); i++) total_iterator_length += iterator_length[i];
        string sLength = my_itoa(total_iterator_length);

        void * sg_param0 = codegen.CreateVariable("volatile uint"+ sLength +" *", "o_iterators");
        fp_list.push_back(sg_param0);
        //void * sg_param1 = codegen.CreateVariable("volatile uint"+ sLength +" *", "param1");
        //fp_list.push_back(sg_param1);

        void * sg_func_decl = codegen.CreateFuncDecl("int", sFuncName, fp_list, sg_global);
        codegen.AppendChild(sg_global, sg_func_decl);
        void * sg_func_body = codegen.GetFuncBody(sg_func_decl);

        codegen.AddDirectives("\n#include <ap_int.h>\n",  sg_func_decl);
        codegen.AddDirectives(  "#include <ap_cint.h>\n", sg_func_decl);

        // Create Variable Declaration
        vector<void *> sg_iterators;
        for (i = 0; i < iterator_name.size(); i++)
        {
            sLength = my_itoa(iterator_length[i]+1);  // loop iterator needs one more bit
            void * sg_decl = codegen.CreateVariableDecl("uint"+sLength, iterator_name[i], nullptr, sg_func_body);
            codegen.AppendChild(sg_func_body, sg_decl);
            sg_iterators.push_back(sg_decl);
        }

        // Create Loop Body
        void * sg_basicblock = codegen.CreateStmt(V_SgBasicBlock, nullptr);
        codegen.AppendChild(sg_func_body, sg_basicblock);
        vector<void *> sg_iterators_t;
        for (i = 0; i < iterator_name.size(); i++)
        {
            sLength = my_itoa(iterator_length[i]);  // loop iterator needs one more bit
            void * sg_init = codegen.CreateVariableRef(sg_iterators[i]);
            void * sg_decl = codegen.CreateVariableDecl("uint"+sLength, iterator_name[i]+"_t", sg_init, sg_basicblock);
            codegen.AppendChild(sg_basicblock, sg_decl);
            sg_iterators_t.push_back(sg_decl);
        }
        {
            vector<void *> sg_init_list;
            for (i = 0; i < sg_iterators_t.size(); i++)
                sg_init_list.push_back(codegen.CreateVariableRef(sg_iterators_t[i]));
            void * sg_func_call = codegen.CreateFuncCall("apint_concatenate", codegen.GetTypeByString("int"), sg_init_list, sg_basicblock);

            void * sg_lhs = codegen.CreateExp(V_SgPointerDerefExp, codegen.CreateVariableRef(sg_param0));
            void * sg_stmt = codegen.CreateStmt(V_SgAssignStatement, sg_lhs, sg_func_call);
            codegen.AppendChild(sg_basicblock, sg_stmt);
        }

        //// Create Loop structure
        //void * sg_for_stmt = codegen.CreateLoopNestFromScoplib(scop);
        //codegen.AppendChild(sg_func_body, sg_for_stmt);

        codegen.GeneratePDF();
        codegen.GenerateCode();
    }

    return nullptr;
}
#endif

#if 0
// Trace the unique initial name
void *CSageCodeGen::TraceVariableInitializedName(void *sg_name) {
  void *sg_scope = GetProject();

  if (!IsInitName(sg_name))
    return nullptr;

  if (-1 == GetFuncParamIndex(sg_name, sg_scope))
    return sg_name;

  vector<void *> vec_sources;

  TraceUpFuncArgSource(sg_scope, sg_name, vec_sources);

#ifdef DEBUG_FUNC_TRACE_UP
  int size = vec_sources.size();
  void *head = (size > 0) ? vec_sources[0] : nullptr;
  cout << "[TraceInitName] " << UnparseToString(sg_name)
       << " size=" << my_itoa(size) << " head=" << my_itoa_hex((int64_t)head)
       << " " << UnparseToString(head) << endl;
#endif

  if (vec_sources.size() == 0 || vec_sources.size() > 1)
    return nullptr;

  void *ret = vec_sources[0];
  // if (IsInitName(ret)) return ret;
  if (isSgVarRefExp((SgNode *)ret))
    return GetVariableInitializedName(ret);
  else
    return nullptr;
}
#endif

#if 0
bool CSageCodeGen::IsConstantTrue(void *sg_exp_) {
  vector<void *> vec_or_list;
  GetExprListFromOrOp(sg_exp_, vec_or_list);
  if (vec_or_list.size() > 1) {
    for (auto &or_op : vec_or_list)
      if (IsConstantTrue(or_op))
        return true;
    return false;
  }
  SgExpression *sg_exp = isSgExpression((SgNode *)sg_exp_);
  if (!sg_exp)
    return false;
  int64_t res = 0;
  bool res_determined = true;
  if (IsCompareOp(sg_exp)) {
    void *op0 = nullptr, *op1 = nullptr;
    GetExpOperand(sg_exp, op0, op1);
    CMarsExpression e0(op0, this);
    CMarsExpression e1(op1, this);
    CMarsExpression diff = e0 - e1;
    if (diff.IsConstant())
      res = diff.GetConstant();
    else
      res_determined = false;
  }
  switch (sg_exp->variantT()) {
  case V_SgIntVal:
    return isSgIntVal(sg_exp)->get_value() != 0;
  case V_SgCastExp:
    return IsConstantTrue(isSgCastExp(sg_exp)->get_operand());
  case V_SgNotOp:
    return IsConstantFalse(isSgNotOp(sg_exp)->get_operand());
  case V_SgAddressOfOp:
    return true;
  case V_SgEqualityOp:
    return res_determined && res == 0;
  case V_SgLessOrEqualOp:
    return res_determined && res <= 0;
  case V_SgLessThanOp:
    return res_determined && res < 0;
  case V_SgNotEqualOp:
    return res_determined && res != 0;
  case V_SgGreaterOrEqualOp:
    return res_determined && res >= 0;
  case V_SgGreaterThanOp:
    return res_determined && res > 0;
  default:
    return false;
  }
  return false;
}

bool CSageCodeGen::IsConstantFalse(void *sg_exp_) {
  vector<void *> vec_and_list;
  GetExprListFromAndOp(sg_exp_, vec_and_list);
  if (vec_and_list.size() > 1) {
    for (auto &and_op : vec_and_list)
      if (IsConstantFalse(and_op))
        return true;
    return false;
  }
  SgExpression *sg_exp = isSgExpression((SgNode *)sg_exp_);
  if (!sg_exp)
    return false;
  int64_t res = 0;
  bool res_determined = true;
  if (IsCompareOp(sg_exp)) {
    void *op0 = nullptr, *op1 = nullptr;
    GetExpOperand(sg_exp, op0, op1);
    CMarsExpression e0(op0, this);
    CMarsExpression e1(op1, this);
    CMarsExpression diff = e0 - e1;
    if (diff.IsConstant())
      res = diff.GetConstant();
    else
      res_determined = false;
  }
  switch (sg_exp->variantT()) {
  case V_SgBoolValExp:
    return isSgBoolValExp(sg_exp)->get_value() == false;
  case V_SgIntVal:
    return isSgIntVal(sg_exp)->get_value() == 0;
  case V_SgCastExp:
    return IsConstantFalse(isSgCastExp(sg_exp)->get_operand());
  case V_SgNotOp:
    return IsConstantTrue(isSgNotOp(sg_exp)->get_operand());
  case V_SgEqualityOp:
    return res_determined && res != 0;
  case V_SgLessOrEqualOp:
    return res_determined && res > 0;
  case V_SgLessThanOp:
    return res_determined && res >= 0;
  case V_SgNotEqualOp:
    return res_determined && res == 0;
  case V_SgGreaterOrEqualOp:
    return res_determined && res < 0;
  case V_SgGreaterThanOp:
    return res_determined && res <= 0;
  default:
    return false;
  }
  return false;
}
#endif

#if 0
void CSageCodeGen::get_perfectly_nested_loops(void *sg_loop,
                                              vector<void *> &loops) {
  void *curr_stmt = sg_loop;
  while (IsForStatement(curr_stmt)) {
    loops.push_back(curr_stmt);
    curr_stmt = GetLoopBody(curr_stmt);
    while (IsBasicBlock(curr_stmt)) {
      int num_childs = GetChildStmtNum(curr_stmt);
      void *next_stmt = nullptr;
      for (int i = 0; i < num_childs; ++i) {
        void *one_child = GetChildStmt(curr_stmt, i);
        if (IsPragmaDecl(one_child) || IsLabelStatement(one_child))
          continue;
        if (next_stmt) {
          next_stmt = nullptr;
          break;
        }
        next_stmt = one_child;
      }
      if (!next_stmt)
        break;
      curr_stmt = next_stmt;
    }
  }
  return;
}
#endif

#if 0
void *CSageCodeGen::GetCommonPosition(const vector<void *> &vec_pos) {
  if (vec_pos.size() <= 0)
    return nullptr;
  void *comm_pos = vec_pos[0];
  size_t i = 1;
  while (i < vec_pos.size()) {
    comm_pos = GetCommonPosition(comm_pos, vec_pos[i]);
    ++i;
  }
  return comm_pos;
}
#endif

#if 0
void CSageCodeGen::GetClassDataMembersByDecl(void *sg_class_decl,
                                             vector<void *> &data_members) {
  vector<void *> members;
  GetClassMembersByDecl(sg_class_decl, members);
  for (auto m : members) {
    if (IsVariableDecl(m))
      data_members.push_back(m);
    if (IsAnonymousTypeDecl(m)) {
      vector<void *> sub_members;
      GetClassDataMembersByDecl(m, sub_members);
      data_members.insert(data_members.end(), sub_members.begin(),
                          sub_members.end());
    }
  }
  return;
}

void CSageCodeGen::GetClassFunctionMembers(void *sg_class_type,
                                           vector<void *> &func_members) {
  vector<void *> members;
  GetClassMembers(sg_class_type, members);
  for (auto m : members)
    if (IsFunctionDeclaration(m))
      func_members.push_back(m);
  return;
}
#endif

#if 0
string CSageCodeGen::get_identifier_from_ast(void *sg_node) {
  // FIXME: how to distinguish different functions with the same name
  // in different files
  void *func_decl = TraceUpToFuncDecl(sg_node);
  string func_name = GetMangledFuncName(func_decl);
  if (IsFunctionDeclaration(sg_node) || IsFunctionDefinition(sg_node)) {
    return "function:" + func_name;
  }

  if (IsForStatement(sg_node)) {
    return "loop:" + func_name + get_internal_loop_label(sg_node);
  }

  if (IsArgumentInitName(sg_node)) {
    return "parameter:" + func_name + GetVariableName(sg_node);
  }

  if (IsLocalInitName(sg_node)) {
    // FIXME: how to distinguish different local variables with the same name
    return "local:" + func_name + GetVariableName(sg_node);
  }

  if (IsGlobalInitName(sg_node)) {
    return "global:" + GetVariableName(sg_node);
  }

#ifdef PROJDEBUG
  cout << _p(sg_node) << endl;
#endif
  assert(0 && "cannot support ast node");
  return "";
}

string CSageCodeGen::GetLocationFromIdentifier(string id) {
  if (!test_file_for_read(message_file))
    return "";
  if (_USE_CACHE_IN_TRAVERSE_) {
    if (s_message_metadata_cache.count(id) > 0)
      return s_message_metadata_cache[id];
  }
  CXMLParser parser;
  CXMLNode *pTLDMRoot = parser.parse_from_file(message_file);
  vector<CXMLNode *> vecNodes = pTLDMRoot->TraverseByName("element");
  size_t j = 0, matched = 0;
  s_message_metadata_cache.clear();
  for (j = 0; j < vecNodes.size(); j++) {
    CXMLNode *element = vecNodes[j];
    string element_id = element->GetParam("id");
    string location = element->GetParam("location");
    s_message_metadata_cache[element_id] = location;
    if (element_id == id) {
      matched = 1;
    }
  }
  if (matched == 0) {
#ifdef PROJDEBUG
    printf("No identifier named %s\n", id.c_str());
#endif
    return "";
  } else {
    return s_message_metadata_cache[id];
  }
}

void CSageCodeGen::InsertIdentifierInformation(string id, string location) {
  if (!test_file_for_read(message_file))
    return;
  CXMLParser parser;
  CXMLNode *pTLDMRoot = parser.parse_from_file(message_file);
  vector<CXMLNode *> vecNodes = pTLDMRoot->TraverseByName("element");
  size_t j = 0, matched = 0;
  for (j = 0; j < vecNodes.size(); j++) {
    CXMLNode *element = vecNodes[j];
    string element_id = element->GetParam("id");
    if (element_id == id) {
      element->SetParam("location", location);
      matched = 1;
    }
  }
  if (matched == 0) {
    CXMLNode *element = pTLDMRoot->CreateAppendChild("element");
    element->SetParam("location", location);
    element->SetParam("id", id);
  } else {
#ifdef PROJDEBUG
    printf("Already have an id named %s\n", id.c_str());
#endif
    return;
  }
  parser.write_into_file(message_file);
}

void CSageCodeGen::InsertIdentifierInformation(
    const map<string, string> &id2loc) {
  if (!test_file_for_read(message_file))
    return;
  CXMLParser parser;
  CXMLNode *pTLDMRoot = parser.parse_from_file(message_file);
  vector<CXMLNode *> vecNodes = pTLDMRoot->TraverseByName("element");
  size_t j = 0;
  map<string, CXMLNode *> id2node;
  for (j = 0; j < vecNodes.size(); j++) {
    CXMLNode *element = vecNodes[j];
    string element_id = element->GetParam("id");
    id2node[element_id] = element;
  }
  for (auto p : id2loc) {
    auto id = p.first;
    auto location = p.second;
    if (id2node.count(id) > 0) {
#ifdef PROJDEBUG
      printf("Already have an id named %s\n", id.c_str());
#endif
      auto element = id2node[id];
      element->SetParam("location", location);
    } else {
      CXMLNode *element = pTLDMRoot->CreateAppendChild("element");
      element->SetParam("location", location);
      element->SetParam("id", id);
    }
  }
  parser.write_into_file(message_file);
}
#endif

#if 0
// ykchoi
int CSageCodeGen::get_loop_trip_count(void *for_loop, void *&trip_count) {
  void *iv, *lb, *ub, *step, *body;
  bool inc_dir, inclusive_bound;
  int step_val;
  int ret = IsCanonicalForLoop(for_loop, &iv, &lb, &ub, &step, &body, &inc_dir,
                               &inclusive_bound);
  ret &= GetLoopStepValueFromExpr(step, step_val);
  if (!ret || !abs(step_val)) {
    trip_count = nullptr;
    return 0;
  }
  CMarsRangeExpr mr = CMarsVariable(for_loop, this).get_range();
  CMarsExpression me_lb, me_ub;
  if (mr.get_simple_bound(me_lb, me_ub)) {
    CMarsExpression len = me_ub - me_lb + 1;
    CMarsExpression me_trip_count = len / abs(step_val);
    trip_count = me_trip_count.get_expr_from_coeff();
    return 1;
  } else {
    trip_count = nullptr;
    return 0;
  }
}
#endif

#if 0
void *get_multi_assign_operand(void *assign_op) {
  SgNode *n = static_cast<SgNode *>(assign_op);
  assert(n != nullptr);
  if (isSgAssignOp(n)) {
    auto assign = isSgAssignOp(n);
    return get_multi_assign_operand(assign->get_rhs_operand_i());
  } else {
    return assign_op;
  }
}
#endif

#if 0
int CSageCodeGen::IsVarArgFunction(void *func_decl) {
  for (auto arg : GetFuncParams(func_decl)) {
    if (isSgTypeEllipse((SgNode *)GetTypebyVar(arg)))
      return 1;
  }
  return 0;
}
#endif

#if 0
int CSageCodeGen::IsRestrictType(void *sg_type) {
  if (!IsType(sg_type)) {
    return 0;
  }
  return SageInterface::isRestrictType((SgType *)sg_type) != 0;
}
#endif

#if 0
// primitive type, class/struct without function member, non-recusive type
int CSageCodeGen::IsCStyleSimpleType(void *sg_type_, void *&unsupported_type,
                                     string &reason) {
  void *sg_type = GetOrigTypeByTypedef(sg_type_, true);
  void *base_type = GetBaseType(sg_type);
  base_type = GetOrigTypeByTypedef(base_type, true);
  if (IsRecursiveType(base_type, unsupported_type)) {
    reason = "recursive type";
    return 0;
  }
  if (IsStructureType(base_type) || IsClassType(base_type) ||
      IsUnionType(base_type)) {
    void *type_decl = GetTypeDeclByType(base_type);
    if (IsTemplateInstClassDecl(type_decl)) {
      reason = "template type";
      return 0;
    }
    vector<void *> vec_members;
    GetClassFunctionMembers(base_type, vec_members);
    if (vec_members.size() > 0) {
      reason = "C++ style class";
      return 0;
    }
    GetClassDataMembers(base_type, vec_members);
    for (auto member : vec_members) {
      void *var_init = GetVariableInitializedName(member);
      void *var_type = GetTypebyVar(var_init);
      if (!IsCStyleSimpleType(var_type, unsupported_type, reason)) {
        unsupported_type = member;
        return 0;
      }
      if (IsStatic(member)) {
        unsupported_type = member;
        reason = "static class member";
        return 0;
      }
    }
    return 1;
  }
  if (IsEnumType(base_type) || IsIntegerType(base_type) || IsFloatType(base_type))
    return 1;

  unsupported_type = base_type;
  if (IsFunctionType(base_type)) {
    reason = "function pointer type";
  } else if (IsVoidType(base_type)) {
    reason = "void type";
  } else {
    reason = "unknown type";
  }
  return 0;
}
#endif

#if 0
void *CSageCodeGen::ContainsClassType(void *sg_type_) {
  void *sg_type = GetOrigTypeByTypedef(sg_type_, true);
  void *base_type = GetBaseType(sg_type);
  base_type = GetOrigTypeByTypedef(base_type, true);
  if (IsStructureType(base_type) || IsClassType(base_type) ||
      IsUnionType(base_type)) {
    return base_type;
  }
  return base_type;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
std::vector<void *> // defs of an init_name , at a certain position
CSageCodeGen::GetVarDefbyPosition_v2(void *init_name, void *pos) {
  void *sg_type = GetTypebyVar(init_name);
  void *sg_orig_type = GetOrigTypeByTypedef(sg_type);
  if (!IsPointerType(sg_orig_type))
    return GetVarDefbyPosition(init_name, pos);

  vector<void *> res;
  if (IsArgumentInitName(init_name))
    res.push_back(init_name);
  else if (IsLocalInitName(init_name) || IsGlobalInitName(init_name)) {
    void *initializer = GetInitializer(init_name);
    if (initializer)
      res.push_back(initializer);
  }

  void *func_decl = TraceUpToFuncDecl(pos);
  if (!func_decl) {
    res.push_back(init_name);
    return res;
  }
  void *func_body = GetFuncBody(func_decl);
  assert(func_body);

  vector<void *> vec_refs;
  get_ref_in_scope(init_name, func_body, vec_refs);
  for (auto ref : vec_refs) {
    void *new_def = nullptr;
    if (is_write_conservative(ref, new_def, false)) {
      assert(new_def);
      res.push_back(new_def);
    }
  }
  return res;
}

std::vector<void *> // uses for an init_name , at a certain position
CSageCodeGen::GetVarUsebyPosition(void *init_name, void *pos) {
  if (!m_defuse)
    init_defuse();
  void *func_decl = TraceUpToFuncDecl(pos);
  if (func_decl && s_def_use_cache.count(func_decl) <= 0) {
    s_def_use_cache.insert(func_decl);
    string func_name = GetFuncName(func_decl, false);
    if (func_name.find("memcpy_wide_bus_read") != 0 &&
        func_name.find("memcpy_wide_bus_write") != 0) {
      SgFunctionDefinition *sg_func_def =
          isSgFunctionDefinition((SgNode *)GetFuncDefinitonByDecl(func_decl));
      m_defuse->start_traversal_of_one_function(sg_func_def);
    }
  }
  // use the first statement as postiion
  // because basic block has no defuse
  if (IsBasicBlock(pos) && GetChildStmtNum(pos) > 0)
    pos = GetChildStmt(pos, 0);
  vector<SgNode *> vec_uses = m_defuse->getUseFor(
      (SgNode *)pos, isSgInitializedName((SgNode *)init_name));

  std::sort(vec_uses.begin(), vec_uses.end(), [](auto a, auto b) {
    return a->unparseToString() < b->unparseToString();
  });
  vector<void *> ret;

  for (size_t i = 0; i < vec_uses.size(); i++) {
    ret.push_back(vec_uses[i]);
  }

  return ret;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
vector<string> CSageCodeGen::GetFromJson(string filename, string key,
                                         string level_1, string level_2) {
  vector<string> ret;
  assert(!level_1.empty());
  assert(!key.empty());

  ifstream ifs(filename);
  if (!ifs.good()) {
    fprintf(stderr, "cant read file: %s\n", filename.c_str());
    assert(0);
    return ret;
  }
  IStreamWrapper isw(ifs);
  Document d;
  d.ParseStream(isw);
  ifs.close();

  Value::MemberIterator src = d.FindMember(level_1.c_str());
  if (!level_2.empty()) {
    src = src->value.FindMember(level_2.c_str());
  }

  const Value &v = src->value[key.c_str()];
  if (v.IsString()) {
    ret.push_back(v.GetString());
  } else if (v.IsArray()) {
    for (auto &e : v.GetArray()) {
      ret.push_back(e.GetString());
    }
  }

  return ret;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void CSageCodeGen::UpdateLocationFromIdentifier(string id, string location) {
  if (!test_file_for_read(message_file))
    return;
  CXMLParser parser;
  CXMLNode *pTLDMRoot = parser.parse_from_file(message_file);
  vector<CXMLNode *> vecNodes = pTLDMRoot->TraverseByName("element");
  size_t j = 0, matched = 0;
  for (j = 0; j < vecNodes.size(); j++) {
    CXMLNode *element = vecNodes[j];
    string element_id = element->GetParam("id");
    if (element_id == id) {
      element->SetParam("location", location);
      matched = 1;
    }
  }
  if (matched == 0) {
#ifdef PROJDEBUG
    printf("No id named %s\n", id.c_str());
#endif
  }
  parser.write_into_file(message_file);
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void *CSageCodeGen::GetTypeByDecl(void *sg_class_decl_) {
  SgClassDeclaration *sg_class_decl =
      isSgClassDeclaration((SgNode *)sg_class_decl_);
  if (!sg_class_decl)
    return nullptr;
  if (sg_class_decl->get_isUnNamed())
    return nullptr;
  return sg_class_decl->get_type();
}
#endif

// all the variable ref in the exp has only one define (by defuse)
#if USED_CODE_IN_COVERAGE_TEST
int CSageCodeGen::is_single_def_expression(void *exp, void *pos) {
  if (pos == nullptr)
    pos = exp;

  if (IsValueExp(exp))
    return 1;

  int64_t value;
  if (IsConstantInt(exp, value))
    return 1;

  assert(!is_floating_node(pos));

  if (TraceUpToFuncDecl(exp) != TraceUpToFuncDecl(pos))
    return 0;

  map<void *, int> vec_names;
  vector<void *> vec_refs;
  GetNodesByType_int(exp, "preorder", V_SgVarRefExp, &vec_refs);

  for (size_t i = 0; i < vec_refs.size(); i++) {
    void *name = GetVariableInitializedName(vec_refs[i]);
    vec_names[name] = 1;
  }

  // void *new_scope = TraceUpByTypeCompatible(pos, V_SgScopeStatement);

  map<void *, int>::iterator it;
  for (it = vec_names.begin(); it != vec_names.end(); it++) {
    void *sg_name = it->first;
    // void *var_scope = GetProject();
    // if (IsArgumentInitName(sg_name)) {
    //  void *func_decl = TraceUpToFuncDecl(sg_name);
    //  var_scope = GetFuncBody(func_decl);
    //} else if (IsLocalInitName(sg_name))
    //  var_scope = TraceUpByTypeCompatible(sg_name, V_SgScopeStatement);

    vector<void *> vec_def = GetVarDefbyPosition(sg_name, pos);
    if (vec_def.size() != 1)
      return 0;
  }

  return 1;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void CSageCodeGen::clean_floating_expr_nodes(void *scope, string str_sg_type) {
  if (scope == nullptr)
    scope = m_sg_project;
  vector<void *> vec_nodes;
  GetNodesByType_compatible(scope, str_sg_type, vec_nodes);

  for (size_t i = 0; i < vec_nodes.size(); i++) {
    void *expr = vec_nodes[i];
    if (expr && !GetParent(expr)) {
      //   printf("here \n");
      DeleteNode(expr);
    }
  }
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
vector<string> CSageCodeGen::outline_simplify_get_deref_vars(
    SgFunctionDeclaration *sg_func_decl) {
  int j;
  vector<string> vecVars;

  for (j = 0; j < GetFuncParamNum(sg_func_decl); j++) {
    void *arg = GetFuncParam(sg_func_decl, j);
    string sArg = UnparseToString(arg);
    vecVars.push_back(sArg.substr(0, sArg.size() - 3));
  }
  return vecVars;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void CSageCodeGen::filter_vec_node_in_path(t_func_call_path &fn_path,
                                           vector<void *> &vec_in) {
  vector<void *> vec_out;
  for (size_t t = 0; t < vec_in.size(); t++) {
    if (is_located_in_path(vec_in[t], fn_path))
      vec_out.push_back(vec_in[t]);
  }
  vec_in = vec_out;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void *CSageCodeGen::outline(void *sg_bb_, string func_name,
                            void **sg_new_decl) {

  freopen("outline.log", "w", stdout);
  freopen("outline.err", "w", stderr);
  int i;
  SgBasicBlock *sg_bb = isSgBasicBlock((SgNode *)sg_bb_);
  assert(sg_bb);

  ///////////////////////////////////////////////////
  // ZP: 2014-07-28: skip outline if code matches, workaround for the outliner
  // problems in C++
  ///////////////////////////////////////////////////
  // skip condition:
  // 1. one single statement in the basicblock
  // 2. the statement is a function call
  // 3. the function name matches with task name
  {
    if (GetChildStmtNum(sg_bb) == 1) {
      void *stmt = GetChildStmt(sg_bb, 0);
      int out = 0;
      while (IsBasicBlock(stmt) && !out) {
        if (GetChildStmtNum(stmt) != 1)
          out = 1;
        else
          stmt = GetChildStmt(stmt, 0);
      }
      if (IsExprStatement(stmt)) {
        SgExprStatement *sg_stmt = isSgExprStatement((SgNode *)stmt);
        void *exp = sg_stmt->get_expression();
        if (IsFunctionCall(exp)) {
          string sFuncName = GetFuncNameByCall(exp);
          if (sFuncName == func_name) {
#ifdef PROJDEBUG
            printf("Task function %s matched, skip outlining.\n",
                   func_name.c_str());
#endif
            char cmd[1024];
            sprintf(cmd,
                    "echo '// The body of the task in the original source "
                    "file.' > %s.cl",
                    func_name.c_str());
            int ret = system(cmd);
            if (!ret) {
              fprintf(stderr, "Error: command %s failed\n", cmd);
              exit(ret);
            }
            void *sg_matched_func_decl = GetFuncDeclByCall(exp);
            if (sg_new_decl)
              *sg_new_decl = sg_matched_func_decl;
            return exp;
          }
        }
      }
    }
  }
  ///////////////////////////////////////////////////

  if (!Outliner::isOutlineable(sg_bb)) {
    return nullptr;
  }
  Outliner::Result rst = Outliner::outlineBlock(sg_bb, func_name);
  SgFunctionDeclaration *sg_func_decl = rst.decl_;
  SgStatement *sg_func_call = rst.call_;

  //    if (1) GenerateCode();
  //    exit(0);

  for (i = 0; i < GetFuncParamNum(sg_func_decl); i++) {
    outline_simplify_one_var(sg_func_decl, i);
  }

  // fixed by zhangpeng: rename port name (xxx) into "p_xxx"  2013-05-06
  for (i = 0; i < GetFuncParamNum(sg_func_decl); i++) {
    void *arg = GetFuncParam(sg_func_decl, i);
    SgInitializedName *sg_arg = isSgInitializedName((SgNode *)arg);
    assert(sg_arg);
    string sPortName = sg_arg->get_name();
    // sg_arg->set_name("p_" + sPortName);
  }

  // # ZP 2013-11-12: set_return_type has bug in rose, FIXME for the opencl
  // runtime case
  if (0) {
    void *func_ret_type = sg_func_decl->get_type()->get_return_type();
    string opencl_ret_type_string =
        "__kernel " + UnparseToString(func_ret_type);
    string s11 = UnparseToString(sg_func_decl->get_type());
#ifdef PROJDEBUG
    printf("function decl 1 %s\n", s11.c_str());
#endif
    RegisterType(opencl_ret_type_string);

    void *opencl_ret_type = GetTypeByString(opencl_ret_type_string);
    sg_func_decl->get_type()->set_return_type((SgType *)(opencl_ret_type));

#ifdef PROJDEBUG
    s11 = UnparseToString(sg_func_decl->get_type());
    printf("function type decl %s\n", s11.c_str());
    s11 = UnparseToString(sg_func_call);
    printf("function call %s\n", s11.c_str());
#endif
  }

  // for windows/dos
  // freopen("CON", "w", stdout);
  // freopen("CON", "w", stderr);
  // for Linux
  freopen("/dev/tty", "w", stdout);
  freopen("/dev/tty", "w", stderr);

  if (sg_new_decl)
    *sg_new_decl = sg_func_decl;
  return sg_func_call; // the function call statement
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void *CSageCodeGen::GetUniqueFuncDeclByCall(void *sg_call) {

  if (!isSgFunctionCallExp((SgNode *)sg_call))
    return nullptr;

  void *func_decl = GetAssociatedFuncDeclByCall(sg_call);
  return GetUniqueFuncDecl(func_decl);
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
int CSageCodeGen::analyze_linear_expression_new(
    void *sg_exp, map<void *, int> &mapVar2Coeff) {
  // PolyVector_new poly_out;
  // CMarsExpression m_expr;

  // Expr2Vector_new(sg_exp, m_expr);

  // cout << "codegen print " << UnparseToString(sg_exp) << ", " <<
  // poly_out.print() << endl;

  //    vector<string> parameters;
  //    void * sg_func_decl = TraceUpByTypeCompatible(sg_exp,
  //    V_SgFunctionDeclaration);
  //    ret &= simplify_intermediate_variables(sg_exp,
  //    GetFuncBody(sg_func_decl), poly_out, parameters);

#if 0
    vector<string> vec_vars;
    poly_out.get_vars(vec_vars);

    for (size_t i = 0; i < vec_vars.size(); i++)
    {
        string var = vec_vars[i];
        if (var == "#") continue;
        if (poly_out.get_coeff(var)) mapVar2Coeff[var] = poly_out.get_coeff(var);
    }
    if (poly_out.get_const()) mapVar2Coeff["1"] = poly_out.get_const();
#endif

  return 1;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
int CSageCodeGen::function_argument_name_replace(void *sg_call, void *sg_decl,
                                                 vector<string> &parameters) {
  int i;
  // FIXME:
  //		Now we do not support if for an iterator, the names of the
  // declaration and calling argument are different
  //		Now we just check the assumption here, to be enhanced later
  for (i = 0; i < GetFuncCallParamNum(sg_call); i++) {
    string sVar = UnparseToString(GetFuncCallParam(sg_call, i));
    if (-1 == str_vector_find(parameters, sVar)) {
      string sVar1 = UnparseToString(GetFuncParam(sg_decl, i));
      if (sVar != sVar1) {
#ifdef PROJDEBUG
        printf("\n[codegen] The names of function declaration and calling for "
               "an iterator do not match. \n");
        printf("\t calling     : %s \n", UnparseToString(sg_call).c_str());
        printf("\t declaration : %s \n", UnparseToString(sg_decl).c_str());
        printf("\t iterations  : %s \n\n", str_merge(',', parameters).c_str());
#endif
        assert(0);
      }
    }
  }

  return 1;
}
#endif

// not stable !!!
// The simple version of parse_pntr_ref_by_array_ref
// only support a[][][]
#if USED_CODE_IN_COVERAGE_TEST
void CSageCodeGen::get_pntr_ref_by_array_ref(void *sg_ref, void *&sg_array,
                                             void *&sg_pntr,
                                             vector<void *> &sg_indexes) {
  void *sg_var = sg_ref;
  sg_array = nullptr;
  sg_array = GetVariableInitializedName(sg_var);
  get_ref_dimension(sg_var, sg_indexes);
  get_pntr_from_var(sg_ref, sg_pntr);
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
int CSageCodeGen::ConvertFuncParamTypePointer2Array(void *sg_func_arg) {
  SgInitializedName *sg_arg = isSgInitializedName((SgNode *)sg_func_arg);
  assert(sg_arg);
  SgType *sg_type = sg_arg->get_type();
  SgType *sg_type_new = isSgType((SgNode *)pointer_to_array_recur(sg_type));
  sg_arg->set_type(sg_type_new);
  return 1;
}
#endif

// return inner loop (according to the loop level)
#if USED_CODE_IN_COVERAGE_TEST
void *CSageCodeGen::ParseLoopNest(void *sg_for_scope, int loop_level,
                                  vector<void *> &vec_iter) {
  int i, j;
  SgStatement *sg_cur = isSgStatement((SgNode *)sg_for_scope);
  assert(sg_cur);
  for (i = 0; i < loop_level; i++) {
    // find a loop
    while (1) {
      if (isSgForStatement(sg_cur)) {
        break;
      } else if (isSgScopeStatement(sg_cur)) {
        SgStatement *sg_stmt_for = 0;
        for (j = 0; j < GetChildStmtNum(sg_cur); j++) {
          sg_stmt_for = (SgStatement *)GetChildStmt(sg_cur, j);
          if (isSgForStatement(sg_stmt_for))
            break;
        }
        assert(isSgForStatement(sg_stmt_for));
        sg_cur = sg_stmt_for;
        continue;
      } else {
        assert(0);
      }
    }

    SgForStatement *sg_for = isSgForStatement(sg_cur);
    assert(sg_for);

    {
      SgInitializedName *ivar = nullptr;
      SgExpression *lb = nullptr, *ub = nullptr, *step = nullptr;
      SgStatement *loop_body = nullptr;
      SgBinaryOp *cond_op;
      int ulimit = 0;
      int is_canonical = ParseForLoop(sg_for, &ivar, &lb, &ub, &step, &cond_op,
                                      &loop_body, ulimit);
      assert(is_canonical);

      vec_iter.push_back((void *)(ivar));
      sg_cur = loop_body;
      assert(isSgStatement(sg_cur));
    }
  }

  return sg_cur;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void *GetAnode(void *a) { return a; }
#endif

#if USED_CODE_IN_COVERAGE_TEST
int CSageCodeGen::fix_scope_issue(void *scope) {
  vector<void *> vec_funcs;
  GetNodesByType_int_compatible(scope, V_SgFunctionDeclaration, vec_funcs);
  bool Changed = false;
  for (auto func : vec_funcs) {
    void *parent = GetParent(func);
    void *curr_scope = isSgFunctionDeclaration((SgNode *)func)->get_scope();
    if (parent == curr_scope)
      continue;

#ifdef PROJDEBUG
    cout << "\n[codegen] fix incorrect scope for function " << GetFuncName(func)
         << endl;
#endif
    SetScope(func, parent);
    Changed = true;
  }
  return Changed;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
string CSageCodeGen::GetPragmaStringAbove(void *pos) {
  void *sg_pragma = GetPreviousStmt(pos);
  if (sg_pragma && IsPragmaDecl(sg_pragma))
    return GetPragmaString(sg_pragma);
  else
    return "";
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void CSageCodeGen::SetMutable(void *sg_decl_) {
  SgDeclarationStatement *sg_decl =
      isSgDeclarationStatement((SgNode *)sg_decl_);
  if (!sg_decl)
    return;
  ((sg_decl->get_declarationModifier()).get_storageModifier()).setMutable();
}
#endif

// arr_name[ivar0+offset0][ivar1+offset1][ivar2+offset2]...
// SgExpression * BuildSimpleArrayRef(SgExpression * lhs,
// vector<SgVariableDeclaration *> & vec_ivar, vector<int> dim_offset)
#if USED_CODE_IN_COVERAGE_TEST
void *CSageCodeGen::CreateSimpleArrayRef(void *array_var_ref,
                                         vector<void *> vec_var,
                                         vector<int> offsets,
                                         void *bindNode /*= nullptr*/) {
  assert(vec_var.size() == offsets.size());

  SgExpression *arr_ref = isSgExpression((SgNode *)array_var_ref);
  for (size_t i = 0; i < offsets.size(); i++) {
    SgVariableDeclaration *sg_decl =
        isSgVariableDeclaration((SgNode *)vec_var[i]);

    int offset_val = offsets[i];
    SgExpression *idx_exp = isSgExpression((SgNode *)CreateExp(
        V_SgAddOp, (SgExpression *)CreateVariableRef(sg_decl),
        (SgExpression *)CreateConst(&offset_val)));
    SgExpression *new_ref = isSgExpression(
        (SgNode *)CreateExp(V_SgPntrArrRefExp, arr_ref, idx_exp, 0, bindNode));
    arr_ref = new_ref;
  }
  return arr_ref;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void *CSageCodeGen::CreateLabel(string sName, void *bindNode /*= nullptr*/) {
  SgStatement *ret_stmt;
  SgName sgname(sName);
  ret_stmt = SageBuilder::buildLabelStatement(sgname);
  markBuild(*this, ret_stmt,
            "Build in " + to_string(__LINE__) + " for " +
                to_string((long)ret_stmt),
            bindNode);
  return ret_stmt;
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void CSageCodeGen::CopyPreprocInfo(void *sg_to_, void *sg_from_) {
  SgLocatedNode *sg_from = isSgLocatedNode((SgNode *)sg_from_);
  SgLocatedNode *sg_to = isSgLocatedNode((SgNode *)sg_to_);
  if (!sg_from || !sg_to)
    return;
  AttachedPreprocessingInfoType *info_from =
      sg_from->get_attachedPreprocessingInfoPtr();
  AttachedPreprocessingInfoType *info_to =
      sg_to->get_attachedPreprocessingInfoPtr();
  if (!info_to) {
    info_to = new AttachedPreprocessingInfoType;
    sg_to->set_attachedPreprocessingInfoPtr(info_to);
  }
  info_to->resize(info_from->size());
  std::copy(info_from->begin(), info_from->end(), info_to->begin());
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void CSageCodeGen::PrependDirectives(string sDirective, void *sg_scope) {
  if (GetChildStmtNum(sg_scope) == 0)
    return;

  void *sg_node_ = GetChildStmt(sg_scope, 0);

  SgLocatedNode *sg_node = isSgLocatedNode((SgNode *)sg_node_);
  assert(sg_node);
  SageInterface::addTextForUnparser(sg_node, sDirective,
                                    AstUnparseAttribute::e_before);
}
#endif

#if USED_CODE_IN_COVERAGE_TEST
void *CSageCodeGen::BuildExpressFromPolyVector(PolyVector vecDim,
                                               vector<void *> vecVarDecl,
                                               int &bit_out) {
  void *sg_exp = nullptr;
  size_t k;
  vector<string> vecVarStr = vecDim.get_iterators();
  for (k = 0; k < vecVarStr.size(); k++) {
    string sTaskIter = vecVarStr[k];
    int coeff = vecDim.get_coeff(sTaskIter);
    if (coeff == 0)
      continue;
    void *dep_dim_exp = CreateVariableRef(vecVarDecl[k]);
    if (coeff != 1) {
      void *sg_coeff = CreateConst(&coeff);
      dep_dim_exp = CreateExp(V_SgMultiplyOp, sg_coeff, dep_dim_exp);
    }

    if (sg_exp == nullptr)
      sg_exp = dep_dim_exp;
    else {
      sg_exp = CreateExp(V_SgAddOp, sg_exp, dep_dim_exp);
    }
  }
  // const term
  {
    int coeff = vecDim.get_const();
    if (coeff != 0) {
      void *dep_dim_exp = CreateConst(&coeff);

      if (sg_exp == nullptr)
        sg_exp = dep_dim_exp;
      else {
        sg_exp = CreateExp(V_SgAddOp, sg_exp, dep_dim_exp);
      }
    }
  }

  bit_out = 32; // FIXME: calculate from iterators

  return sg_exp;
}
#endif

//
#if USED_CODE_IN_COVERAGE_TEST
void *CSageCodeGen::copy_node_and_replace_reference(void *sg_node,
                                                    void *sg_init,
                                                    void *new_exp) {
  void *ret = CopyChild(sg_node);
  if (!ret)
    return nullptr;

  vector<void *> vec_ref;
  GetNodesByType_int(ret, "preorder", V_SgVarRefExp, &vec_ref);

  for (auto ref : vec_ref)
    if (sg_init == GetVariableInitializedName(ref)) {
      ReplaceExp(ref, CopyExp(new_exp));
    }

  return ret;
}
#endif

#if 0
//////////////////////////////////////////
// one_access_wrapper
// Function: add cmost_read/cmost_write wrapper for normal data, and add
// cmost_pointer to memcpy argument
// 1. access_wrapper must be performed in the post-order, which matches the
//    port (reference) order in tldm specification
//    (CSageCodeGen::get_io_matrix_of_function())
int CSageCodeGen::one_access_wrapper(void *sg_func_, string sVar, string sPort,
                                     string func_prefix,
                                     map<string, vector<string>> &mapArray2Dim

                                     // ZP: 2104-06-25: fixbug: if one function
                                     // has been visited, it should not be visit
                                     // again
                                     ,
                                     map<string, bool> &mapFuncVisited) {
  // FIXME: maybe too strong, 2013-06-04 zhangpeng
  if (USE_LOWERCASE_NAME)
    sVar = get_lower_case(sVar);
  if (USE_LOWERCASE_NAME)
    sPort = get_lower_case(sPort);

  size_t i, j, k;
  // SgFunctionDeclaration * sg_scope_func =
  // isSgFunctionDeclaration((SgNode*)sg_func_);
  // assert(sg_scope_func);

  // ZP: 2104-06-25: fixbug: if one function has been visited (multiple calls),
  // it should not be visit again
  if (isSgFunctionDeclaration((SgNode *)sg_func_)) {
    string sFuncName = GetFuncName(sg_func_);

    // if (sFuncName == "recv_data")
    //{
    //    printf("here\n");
    //}

    if (mapFuncVisited.find(sFuncName) == mapFuncVisited.end()) {
      mapFuncVisited[sFuncName] = true;
    } else {
      return 1;
    }
  }

  // 1. function calls
  vector<void *> vecCalls;
  GetNodesByType_int(sg_func_, "preorder", V_SgFunctionCallExp, &vecCalls);
  for (i = 0; i < vecCalls.size(); i++) {
    void *sg_call = vecCalls[i];
    void *sg_func_decl = GetAssociatedFuncDeclByCall(sg_call);
    if (!sg_func_decl)
      continue; // if it is statically called
    string sFuncName = GetFuncNameByCall(sg_call);
    if (sFuncName.size() >= sizeof("cmost_read_") &&
        "cmost_read_" == sFuncName.substr(sizeof("cmost_read_")))
      continue;
    if (sFuncName.size() >= sizeof("cmost_write_") &&
        "cmost_write_" == sFuncName.substr(sizeof("cmost_write_")))
      continue;

    // ZP : 2013-12-31
    if ("memcpy" == sFuncName) {
      for (j = 0; j < (size_t)GetFuncCallParamNum(sg_call); j++) {
        void *arg_exp = GetFuncCallParam(sg_call, j);
        void *var_ref = match_var_in_expression(sVar, arg_exp);

        if (var_ref) {
          // if var is a scalar return
          void *sg_name_ = GetVariableInitializedName(var_ref);
          SgInitializedName *sg_name = isSgInitializedName((SgNode *)sg_name_);
          assert(sg_name);
          if (!isSgPointerType(sg_name->get_type()))
            continue;

          // var -> module_name_cmost_pointer_var(var);
          vector<void *> sg_init_list;
          sg_init_list.push_back(CopyExp(arg_exp));
          void *sg_func_call = CreateFuncCall(
              func_prefix + "_pointer_" + sVar, GetTypeByString("void"),
              sg_init_list,
              TraceUpByTypeCompatible(arg_exp, V_SgScopeStatement));

          string sOldExp = UnparseToString(arg_exp);
          if (sOldExp.length() > 40)
            sOldExp = sOldExp.substr(0, 40) + "...";
          string sNewExp = UnparseToString(sg_func_call);
          if (sNewExp.length() > 60)
            sNewExp = sNewExp.substr(0, 60) + "...";
          void *sg_func_up =
              TraceUpByTypeCompatible(arg_exp, V_SgFunctionDeclaration);
#ifdef PROJDEBUG
          std::cout << "[access_wrapper]" << GetFuncName(sg_func_up) << "\t"
                    << sOldExp << " -> " << sNewExp << endl;
#endif
          ReplaceExp(arg_exp, sg_func_call);
        }
      }
      continue;
    }

    int k;
    for (k = 0; k < GetFuncCallParamNum(sg_call); k++) {
#if USE_LOWERCASE_NAME
      if (get_lower_case(UnparseToString(GetFuncCallParam(sg_call, k))) ==
          get_lower_case(sVar))
        break;
#else
      if (UnparseToString(GetFuncCallParam(sg_call, k)) == sVar)
        break;
#endif
    }

    if (k == GetFuncCallParamNum(sg_call))
      continue;

    vector<void *> vecDecl;
    GetNodesByType_int(GetProject(), "preorder", V_SgFunctionDeclaration,
                       &vecDecl);

    for (j = 0; j < vecDecl.size(); j++) {
      if (GetFuncName(vecDecl[j]) == GetFuncName(sg_func_decl) &&
          GetFuncBody(vecDecl[j]) &&
          IsMatchedFuncAndCall(vecDecl[j], sg_call, sg_func_decl)) {
        int ret = one_access_wrapper(
            vecDecl[j], UnparseToString(GetFuncParam(vecDecl[j], k)), sPort,
            func_prefix, mapArray2Dim, mapFuncVisited);
        if (!ret)
          return 0;
      }
    }
  }

  // 2. variable references
  vector<void *> ref_collected;
  {
    vector<void *> vecRef;
    GetNodesByType_int(sg_func_, "preorder", V_SgVarRefExp, &vecRef);
    for (i = 0; i < vecRef.size(); i++) {
      SgVarRefExp *ref = isSgVarRefExp((SgNode *)vecRef[i]);
#if USE_LOWERCASE_NAME
      if (get_lower_case(UnparseToString(ref)) == get_lower_case(sVar))
#else
      if (UnparseToString(ref) == sVar)
#endif
      {
        ref_collected.push_back(ref);
      }
    }
  }

  for (i = 0; i < ref_collected.size(); i++) {
    SgVarRefExp *ref = isSgVarRefExp((SgNode *)ref_collected[i]);
    SgVarRefExp *sg_ref = isSgVarRefExp((SgNode *)ref);

    void *sg_name_ = GetVariableInitializedName(sg_ref);
    SgInitializedName *sg_name = isSgInitializedName((SgNode *)sg_name_);
    assert(sg_name);
    if (!isSgPointerType(sg_name->get_type()))
      continue;

    // ZP: 2014-01-01: for memcpy multi-dimensional access
    void *arg_exp = nullptr;
    if ((arg_exp = is_pointer_ref_in_memcpy(sg_ref))) {
      vector<void *> vec_index;
      size_t ref_dim = get_ref_dimension(ref, vec_index);
      void *full_index_expr = ref;
      for (j = 0; j < ref_dim; j++)
        full_index_expr = GetParent(full_index_expr);
      vector<string> vecDim_local = mapArray2Dim[sPort];
      if (ref_dim != vecDim_local.size() - 1) {
#ifdef PROJDEBUG
        printf("[tldm_task_extract(access_wrapper)] ERROR: Array dimension "
               "mismatch in memcpy: array=%s(dim=%d), polyinfo_dim=%s\n",
               UnparseToString(full_index_expr).c_str(), (int)ref_dim,
               str_merge(',', vecDim_local).c_str());
        printf("   Statement = %s\n\n",
               UnparseToString(TraceUpByTypeCompatible(sg_ref, V_SgStatement))
                   .c_str());
        printf("   This may be due to missing cmost_malloc_xd call for array "
               "%s.\n\n",
               sVar.c_str());
#endif
        assert(0);
      }

      void *new_index_exp = nullptr;
      for (j = 0; j < ref_dim; j++) {
        void *term = CopyExp(vec_index[j]);
        for (k = j + 1; k < vecDim_local.size(); k++) {
          term = CreateExp(V_SgMultiplyOp, term,
                           CreateConst(my_atoi(vecDim_local[k])));
        }
        if (new_index_exp)
          new_index_exp = CreateExp(V_SgAddOp, new_index_exp, term);
        else
          new_index_exp = term;
      }

      if (new_index_exp) {
        void *new_full_index_expr =
            CreateExp(V_SgAddOp, CopyExp(sg_ref), new_index_exp);

        string sOldExp = UnparseToString(full_index_expr);
        if (sOldExp.length() > 40)
          sOldExp = sOldExp.substr(0, 40) + "...";
        string sNewExp = UnparseToString(new_full_index_expr);
        if (sNewExp.length() > 60)
          sNewExp = sNewExp.substr(0, 60) + "...";
        void *sg_func_up =
            TraceUpByTypeCompatible(full_index_expr, V_SgFunctionDeclaration);
#ifdef PROJDEBUG
        std::cout << "[access_wrapper]" << GetFuncName(sg_func_up) << "\t"
                  << sOldExp << " -> " << sNewExp << endl;
#endif
        ReplaceExp(full_index_expr, new_full_index_expr);
      }

      continue;
    }

    // 2. replace indexes in func_collected
    if (sg_ref) {
      // void * ref = func_collected[i];
      vector<void *> vec_index;
      size_t ref_dim = get_ref_dimension(ref, vec_index);
      void *old_access = ref;
      vector<void *> new_index;
      if (ref_dim == 0) {

        // ZP: 2014-12-30: Port variables can not be de-refered
        if (isSgPointerDerefExp((SgNode *)GetParent(ref))) {
#ifdef PROJDEBUG
          printf("\n[tldm_task_extract] FATAL ERROR: Port variables can not be "
                 "de-refered (such as *var = ...) \n");
          printf("   var=%s, access=%s\n", sVar.c_str(),
                 UnparseToString(GetParent(ref)).c_str());
          printf("   Please change \"*var\" to \"var[0]\"\n\n");
#endif
          assert(0);
        }

        continue; // fixed by peng zhang; scalar and pure pointer are ignored in
                  // access wrapper
      } else {
        for (j = 0; j < ref_dim; j++)
          old_access = GetParent(old_access);
        // assert(ref_dim == 1); // do linearization first
        for (size_t kk = 0; kk < ref_dim; kk++) {
          new_index.push_back(CopyExp(vec_index[kk]));
        }
        // new_index = CopyExp(vec_index[0]);
      }

      int is_write = is_write_analysis((SgNode *)old_access);
      if (poly_access_pattern::READWRITE == is_write) {
        // ZP: 2013-12-31: add this message
#ifdef PROJDEBUG
        printf("\n[tldm_task_extract] ERROR: Compound Assignment to array "
               "variable is not allowed (such as +=, -=, *=, etc.).\n");
        printf("   var=%s, access=%s\n\n", sVar.c_str(),
               UnparseToString(old_access).c_str());
#endif
        assert(0);
      } else if (poly_access_pattern::WRITE == is_write) {
        SgAssignOp *sg_assign = isSgAssignOp((SgNode *)GetParent(old_access));
        assert(sg_assign);
        assert(sg_assign->get_lhs_operand() == old_access);

        string rename_idx_for_write = GetRefRenameAndInc(sPort);
        //////////////////////////////////////////////////////////////////////////
        // fixed by zhangpeng 2013-05-11, otherwise the corresponding read
        // references will not be replaced
        one_access_wrapper(sg_assign->get_rhs_operand(), sVar, sPort,
                           func_prefix, mapArray2Dim, mapFuncVisited);
        //////////////////////////////////////////////////////////////////////////

        vector<string> vecDim_local = mapArray2Dim[sPort];
        if (vecDim_local.size() != ref_dim) {
#ifdef PROJDEBUG
          printf("\n[tldm_task_extract(access_wrapper)] ERROR: Array dimension "
                 "mismatch: ref=%s(dim=%d), polyinfo_dim=%s.\n\n",
                 UnparseToString(old_access).c_str(), (int)ref_dim,
                 str_merge(',', vecDim_local).c_str());
          printf("   This may be due to missing cmost_malloc_xd call for array "
                 "%s.\n\n",
                 sVar.c_str());
#endif
          assert(0);
        }

        vector<void *> sg_init_list;
        sg_init_list.push_back(CopyExp(sg_ref));
        {
          void *new_index_exp = nullptr;
          for (j = 0; j < ref_dim; j++) {
            void *term = new_index[j];
            for (k = j + 1; k < ref_dim; k++) {
              term = CreateExp(V_SgMultiplyOp, term,
                               CreateConst(my_atoi(vecDim_local[k])));
              // term = CreateExp(V_SgMultiplyOp, term, CreateConst(512));
            }
            if (new_index_exp)
              new_index_exp = CreateExp(V_SgAddOp, new_index_exp, term);
            else
              new_index_exp = term;
          }
          sg_init_list.push_back(new_index_exp);
        }
        sg_init_list.push_back(CopyExp(sg_assign->get_rhs_operand()));
        // void * sg_func_call = CreateFuncCall(func_prefix+"_write_"+sPort,
        // GetTypeByString("void"), sg_init_list,
        // TraceUpByTypeCompatible(sg_func_, V_SgScopeStatement));

        if (USE_LOWERCASE_NAME) {
          rename_idx_for_write = get_lower_case(rename_idx_for_write);
        }

        void *sg_func_call = CreateFuncCall(
            func_prefix + "_write_" + rename_idx_for_write,
            GetTypeByString("void"), sg_init_list,
            TraceUpByTypeCompatible(sg_func_, V_SgScopeStatement));
        string sOldExp = UnparseToString(sg_assign);
        if (sOldExp.length() > 40)
          sOldExp = sOldExp.substr(0, 40) + "...";
        string sNewExp = UnparseToString(sg_func_call);
        if (sNewExp.length() > 60)
          sNewExp = sNewExp.substr(0, 60) + "...";
        ReplaceExp(sg_assign, sg_func_call);

        if (1) {
          void *sg_func_up =
              TraceUpByTypeCompatible(sg_func_, V_SgFunctionDeclaration);
#ifdef PROJDEBUG
          std::cout << "[access_wrapper]" << GetFuncName(sg_func_up) << "\t"
                    << sOldExp << " -> " << sNewExp << endl;
#endif
        }
      } else {
        vector<string> vecDim_local = mapArray2Dim[sPort];
        if (vecDim_local.size() != ref_dim) {
#ifdef PROJDEBUG
          printf("\n[tldm_task_extract(access_wrapper)] ERROR: Array dimension "
                 "mismatch: ref=%s(dim=%d), polyinfo_dim=%s.\n\n",
                 UnparseToString(old_access).c_str(), (int)ref_dim,
                 str_merge(',', vecDim_local).c_str());
#endif
          assert(0);
        }

        vector<void *> sg_init_list;
        sg_init_list.push_back(CopyExp(sg_ref));
        // sg_init_list.push_back(CopyExp(new_index));
        {
          void *new_index_exp = nullptr;
          for (j = 0; j < ref_dim; j++) {
            void *term = new_index[j];
            for (k = j + 1; k < ref_dim; k++) {
              term = CreateExp(V_SgMultiplyOp, term,
                               CreateConst(my_atoi(vecDim_local[k])));
              // term = CreateExp(V_SgMultiplyOp, term, CreateConst(512));
            }
            if (new_index_exp)
              new_index_exp = CreateExp(V_SgAddOp, new_index_exp, term);
            else
              new_index_exp = term;
          }
          sg_init_list.push_back(new_index_exp);
        }

        // void * sg_func_call = CreateFuncCall(func_prefix+"_read_"+sPort,
        // GetTypeByString("int"), sg_init_list,
        // TraceUpByTypeCompatible(sg_func_, V_SgScopeStatement));

        string read_ref_name = GetRefRenameAndInc(sPort);
        if (USE_LOWERCASE_NAME) {
          read_ref_name = get_lower_case(read_ref_name);
        }

        void *sg_func_call = CreateFuncCall(
            func_prefix + "_read_" + read_ref_name, GetTypeByString("int"),
            sg_init_list,
            TraceUpByTypeCompatible(sg_func_, V_SgScopeStatement));

        string sOldExp = UnparseToString(old_access);
        if (sOldExp.length() > 40)
          sOldExp = sOldExp.substr(0, 40) + "...";
        string sNewExp = UnparseToString(sg_func_call);
        if (sNewExp.length() > 60)
          sNewExp = sNewExp.substr(0, 60) + "...";

        ReplaceExp(old_access, sg_func_call);
        if (1) {
          void *sg_func_up =
              TraceUpByTypeCompatible(sg_func_, V_SgFunctionDeclaration);
#ifdef PROJDEBUG
          std::cout << "[access_wrapper]" << GetFuncName(sg_func_up) << "\t"
                    << sOldExp << " -> " << sNewExp << endl;
#endif
        }
      }
    }
  }

  return 1;
}
#endif

#if 0
int CSageCodeGen::analysis_array_flatten(void *array_init,
                                         vector<size_t> &old_dims) {
  size_t i;
  void *sg_scope = m_sg_project;

  int type_dim; // = get_pntr_type_dim(sg_pntr);
  {
    if (!IsInitName(array_init))
      return 0;
    if (IsArgumentInitName(array_init))
      return 0;

    void *tt_type = GetTypebyVar(array_init);
    void *tt_base_type;
    get_type_dimension(tt_type, tt_base_type, old_dims, array_init);
    type_dim = old_dims.size();

    if (type_dim <= 1)
      return 0;
  }

  // Algorithm
  // 1. Check all the references are simple access

  vector<void *> vec_access;
  // 1. Get all the references
  {
    GetPntrReferenceOfArray(array_init, sg_scope, vec_access);

    for (i = 0; i < vec_access.size(); i++) {
      void *sg_pntr = vec_access[i];
      assert(!is_floating_node(sg_pntr));
      //            cout << _p(sg_pntr) << endl;
    }
  }

  // 2. Check all the references are simple access
  {
    for (size_t i0 = 0; i0 < vec_access.size(); i0++) {
      void *sg_pntr = vec_access[i0];

      if (IsCastExp(sg_pntr))
        remove_cast(sg_pntr);

      int type_dim; // = get_pntr_type_dim(sg_pntr);
      int pntr_dim; // = get_pntr_pntr_dim(sg_pntr);
      {
        void *tt_array;
        vector<void *> tt_vec;
        parse_pntr_ref_new(sg_pntr, tt_array, tt_vec);
        pntr_dim = tt_vec.size();

        void *tt_type = GetTypebyVar(tt_array);
        void *tt_base_type;
        vector<size_t> tt_size;
        get_type_dimension(tt_type, tt_base_type, tt_size, sg_pntr);
        type_dim = tt_size.size();
      }

      if (type_dim <= 1)
        return 0;

      if (type_dim != pntr_dim) {
        if (pntr_dim == 0)
          continue;
        else
          return 0;
      }
    }
  }

  return 1;
}

int CSageCodeGen::apply_array_flatten(void *array_init,
                                      vector<size_t> &old_dims) {
  size_t i;
  void *sg_scope = m_sg_project;

  if (old_dims.size() <= 1)
    return 0;
  int dim_num = old_dims.size();
  // Algorithm
  // 1. Get all the references, and iterator range and steps
  // 2. For each reference, check if all the referneces are transformable
  // 3. do the transform one by one

  vector<void *> vec_access;
  GetPntrReferenceOfArray(array_init, sg_scope, vec_access);
  // 1. Get all the references, and iterator range and steps
  int is_feasible = 1;
  {
    for (i = 0; i < vec_access.size(); i++) {
      void *sg_pntr = vec_access[i];
      assert(!is_floating_node(sg_pntr));

      if (IsCastExp(sg_pntr))
        remove_cast(sg_pntr);

      int type_dim; // = get_pntr_type_dim(sg_pntr);
      int pntr_dim; // = get_pntr_pntr_dim(sg_pntr);
      {
        void *tt_array;
        vector<void *> tt_vec;
        parse_pntr_ref_new(sg_pntr, tt_array, tt_vec);
        pntr_dim = tt_vec.size();

        void *tt_type = GetTypebyVar(tt_array);
        void *tt_base_type;
        vector<size_t> tt_size;
        get_type_dimension(tt_type, tt_base_type, tt_size, sg_pntr);
        type_dim = tt_size.size();
      }

      // Note: Do not apply the whole transform if there is partial pntr
      if (type_dim <= 1) {
        is_feasible = 0;
        break;
      }
      if (type_dim != pntr_dim && pntr_dim != 0) {
        is_feasible = 0;
        break;
      }

      if (!is_feasible)
        break;
    }
  }

  // 1. get all the array init names to be changed
  map<void *, int> init_to_change;
  {
    for (i = 0; i < vec_access.size(); i++) {
      void *sg_pntr = vec_access[i];

      void *curr_array;
      vector<void *> curr_idx;
      parse_pntr_ref_new(sg_pntr, curr_array, curr_idx);

      if (curr_array)
        init_to_change[curr_array] = 1;
    }
  }

  // perform transformation for each reference
  vector<void *> vec_sys_call_ref;
  {
    // if (UnparseToString(array_init) == "eigenvalues")
    //{
    //    printf("dd");
    //}
    for (i = 0; i < vec_access.size(); i++) {
      void *sg_pntr = vec_access[i];
      void *sg_org_pntr = sg_pntr;
      // if (IsCastExp(sg_pntr)) remove_cast(sg_pntr);

      int type_dim; // = get_pntr_type_dim(sg_pntr);
      int pntr_dim; // = get_pntr_pntr_dim(sg_pntr);
      {
        void *tt_array = nullptr;
        vector<void *> tt_vec;
        parse_pntr_ref_new(sg_pntr, tt_array, tt_vec);
        pntr_dim = tt_vec.size();

        void *tt_type = GetTypebyVar(tt_array);
        void *tt_base_type;
        vector<size_t> tt_size;
        get_type_dimension(tt_type, tt_base_type, tt_size, sg_pntr);
        type_dim = tt_size.size();
      }

      // Note: Do not apply the whole transform if there is partial pntr
      if (type_dim <= 1) {
        is_feasible = 0;
        break;
      }
      if (type_dim != pntr_dim && pntr_dim != 0) {
        is_feasible = 0;
        break;
      }

      if (pntr_dim == 0) {
        int param_index = GetFuncCallParamIndex(sg_org_pntr);
        if (-1 != param_index) {
          void *sg_call = TraceUpByTypeCompatible(sg_pntr, V_SgFunctionCallExp);
          assert(sg_call);

          string str_call = GetFuncNameByCall(sg_call);

          if (str_call == "memcpy" || str_call == "memset") {
            vec_sys_call_ref.push_back(sg_pntr);
          }
        }
        continue;
      }

      vector<void *> vec_new_expr;

      CMarsAccess ac(sg_pntr, this, nullptr);
      assert(ac.GetIndexes().size() == (size_t)dim_num);
      CMarsExpression sum(this, 0);
      for (size_t dim = 0; dim < old_dims.size(); dim++) {
        CMarsExpression me = ac.GetIndexes()[dim];
        int factor = old_dims[dim_num - 1 - dim];
        sum = sum * factor;
        sum = sum + me;
      }
      vec_new_expr.push_back(sum.get_expr_from_coeff());

      // apply the new expression
      {
        void *local_var;
        {
          vector<void *> vec;
          parse_pntr_ref_new(sg_pntr, local_var, vec);
          assert(local_var);
        }
        void *new_access =
            CreateArrayRef(CreateVariableRef(local_var), vec_new_expr);

        ReplaceExp(sg_pntr, new_access);
      }
    }

    // change the type of the array
    {
      // 1. get all the array init names to be changed
      // moved to front
      // map<void*, int> init_to_change;
      //{
      //    for (i = 0; i < vec_access.size(); i++)
      //    {
      //        void * sg_pntr = vec_access[i];

      //        void * curr_array;
      //        vector<void*> curr_idx;
      //        parse_pntr_ref_new(sg_pntr, curr_array, curr_idx);

      //        if (curr_array) init_to_change[curr_array] = 1;
      //    }
      //}

      // 2. apply the type change
      vector<size_t> new_array_dims;

      void *sg_base_type;
      vector<size_t> sg_sizes;
      get_type_dimension(GetTypebyVar(array_init), sg_base_type, sg_sizes,
                         array_init);
      size_t total = 1;

      for (i = 0; i < old_dims.size(); i++) {
        total *= old_dims[i];
      }

      new_array_dims.push_back(total);

      map<void *, int>::iterator it;
      for (it = init_to_change.begin(); it != init_to_change.end(); it++) {
        SetTypetoVar(it->first, CreateArrayType(sg_base_type, new_array_dims));
      }

      // 3. apply to function arg of memset and memcpy
      {
        for (i = 0; i < vec_sys_call_ref.size(); i++) {
          void *sg_pntr = vec_sys_call_ref[i];
          vector<void *> tt_index;

          void *curr_array; // = GetVariableInitializedName(sg_pntr);
          void *array_ref;
          vector<void *> tt_vec;
          {
            parse_pntr_ref_new(sg_pntr, curr_array, tt_vec);
            parse_array_ref_from_pntr(sg_pntr, array_ref);
          }
          CMarsExpression new_index(this, 0);
          for (size_t tt = 0; tt < tt_vec.size(); tt++) {
            new_index = new_index * (int64_t)old_dims[dim_num - tt - 1];
            new_index =
                new_index + CMarsExpression(tt_vec[tt], this, array_ref);
          }
          tt_index.push_back(new_index.get_expr_from_coeff());
          void *new_pntr_ref =
              CreateArrayRef(CreateVariableRef(curr_array), tt_index);
          ReplaceExp(array_ref, new_pntr_ref);
        }
      }
    }
  }
  return 1;
}
#endif

#if 0
// the size of cond_vector equals order_vec, currently set to be (1, 1, ..., 1)
string cond_vector_gen(string order_vec) {
  string cond_vec;
  int pos = -1;
  while (1) {
    cond_vec = cond_vec + "1";
    if (order_vec.find(",", pos + 1) == string::npos) {
      break;
    }
    pos = order_vec.find(",", pos + 1);
    cond_vec = cond_vec + ",";
  }
  return cond_vec;
}

// Mo
string order_vector_gen(CSageCodeGen &codegen, void *sg_node_scope,
                        void *sg_node, int HGT) // task: sg_node = basicblock
                                                // task access: sg_node = one
                                                // reference //Mo
{
  vector<string> order_vec;
  vector<string> iterators, conditions, lower, upper;
  vector<int> loop_indices;
  // if (codegen.IsBasicBlock(sg_node))
  {
    int ret = codegen.analyze_iteration_domain_order(
        sg_node_scope, sg_node, iterators, loop_indices, conditions, lower,
        upper, HGT);
    if (ret == -1) {
      // continue;
      printf("ret = 1!\n");
      exit(1);
    }
  }
  assert(iterators.size() + 1 == loop_indices.size());
  size_t i;
  for (i = 0; i < iterators.size(); i++) {
    order_vec.push_back(my_itoa(loop_indices[i]));
    order_vec.push_back(iterators[i]);
  }
  order_vec.push_back(my_itoa(loop_indices[i]));
  // convert to a string
  string order_vec_string;
  for (i = 0; i < order_vec.size() - 1; i++) {
    order_vec_string += order_vec[i];
    order_vec_string += ",";
  }
  order_vec_string += order_vec[i];

  return order_vec_string;
}

// For tldm access function
string order_vector_gen(CSageCodeGen &codegen, void *sg_node, int HGT) {
  // void *sg_node_inner_loop = nullptr;
  void *sg_node_scope = nullptr;
  void *sg_pre = nullptr;
  void *sg_node_in = sg_node;
  bool found = false;
  while (1) {
    sg_pre = sg_node;
    sg_node = codegen.GetParent(sg_node);
    if (!found && codegen.IsForStatement(sg_node)) {
      // sg_node_inner_loop = sg_pre;
      found = true;
    }
    if (codegen.IsFunctionDefinition(sg_node)) {
      sg_node_scope = sg_pre;
      break;
    }
  }
  // if (sg_node_inner_loop == nullptr)
  //{
  //	return "0";
  //}
  // string order_vec_string = order_vector_gen(codegen, sg_node_scope,
  // sg_node_inner_loop, HGT);
  string order_vec_string =
      order_vector_gen(codegen, sg_node_scope, sg_node_in, HGT);
  return order_vec_string;
}
#endif
#if 0
vector<void *> CSageCodeGen::TraceDownToFuncCall(void *sg_pos) {
  vector<void *> func_call;
  void *p_statement = sg_pos;
  while (1) {
    p_statement = GetNextStmt(p_statement);
    if (IsStatement(p_statement)) {
      if (IsFunctionCall(GetFuncCallInStmt(p_statement))) {
        // printf("return2 func_call = %s\n",
        // UnparseToString(GetFuncCallInStmt(p_statement)).c_str());
        // return GetFuncCallInStmt(p_statement);
        func_call.push_back(GetFuncCallInStmt(p_statement));
      }
    } else {
      break;
    }
  }
  return func_call;
}
#endif
#if 0
string CSageCodeGen::GetMallocVarName(void *parent) {
  string arr_name_str;

  // int elem_size = 0;
  // int total_size = 0;

  while (1) {
    parent = GetParent(parent);
    if (!parent)
      break;
    // cerr<<"class_name = "<<((SgNode*)(parent))->class_name()<<endl;
    // arr_name_str = UnparseToString(parent);
    if (isSgVariableDeclaration((SgNode *)parent)) {
      SgInitializedName *init_name = isSgInitializedName(
          ((SgVariableDeclaration *)((SgNode *)parent))->get_variables()[0]);
      arr_name_str = UnparseToString(init_name);
      // cerr<<"var_name = "<<arr_name_str<<endl;
      break;
    }
    if (isSgAssignOp((SgNode *)parent)) {
      SgVarRefExp *ivar_exp = isSgVarRefExp(
          ((SgAssignOp *)((SgNode *)parent))->get_lhs_operand_i());
      arr_name_str = UnparseToString(ivar_exp);
      // cerr<<"var_name = "<<arr_name_str<<endl;
      break;
    }
  }

  return arr_name_str;
}

// return 1 for false deref (read only), 0 for true deref, conservative towards
// 0
int CSageCodeGen::outline_check_false_deref(SgFunctionDeclaration *sg_func_decl,
                                            SgInitializedName *arg) {
  size_t i;
  void *func_body = GetFuncBody(sg_func_decl);
  if (!func_body)
    return 0;
  string sVar = UnparseToString(arg);

  vector<void *> vecNodes;
  GetNodesByType_int(func_body, "preorder", V_SgVarRefExp, &vecNodes);
  for (i = 0; i < vecNodes.size(); i++) {
    if (sVar != UnparseToString(vecNodes[i]))
      continue;

    // 1. make sure each reference is in an deref expression
    void *deref_node = GetParent(vecNodes[i]);
    // if (!isSgPointerDerefExp((SgNode*)deref_node)) return 0;

    // ZP: 2014-08-27: FATAL and FIXME: There is a bug in Outliner for C++, a
    // deref is missing
    if (!isSgPointerDerefExp((SgNode *)deref_node)) {

      return 0;

      // continue;

      // SgExpression * var_ref = isSgExpression((SgNode*)vecNodes[i]);
      // SgExpression * var_ref_deref = isSgExpression( (SgNode *)
      //    CreateExp(V_SgPointerDerefExp, CopyExp(var_ref), nullptr));

      // assert(var_ref_deref);

      // replaceExpressionWithHistory(this, var_ref, var_ref_deref, true);
    }

    // 2. make sure the deref is not an operand of an address expression
    if (isSgAddressOfOp((SgNode *)GetParent(deref_node)))
      return 0;

    // 2.5 make sure the deref is not a left value of structure inference,
    // conservative
    if (isSgDotExp((SgNode *)GetParent(deref_node)))
      return 0;
    if (isSgArrowExp((SgNode *)GetParent(deref_node)))
      return 0;

    // 3. make sure if the deref is the left value of an expression
    if (isSgExpression((SgNode *)GetParent(deref_node))) {
      SgBinaryOp *bin_op = isSgBinaryOp((SgNode *)GetParent(deref_node));
      if (isBinaryAssign(bin_op) && bin_op->get_lhs_operand() == deref_node)
        return 0;

      SgPlusPlusOp *pp_op = isSgPlusPlusOp((SgNode *)GetParent(deref_node));
      SgMinusMinusOp *mm_op = isSgMinusMinusOp((SgNode *)GetParent(deref_node));

      if (pp_op || mm_op)
        return 0;
    } else {
      assert(0);
      return 0;
    }
  }

  return 1;
}

void CSageCodeGen::outline_simplify_one_var(
    SgFunctionDeclaration *sg_func_decl_, int arg_idx) {
  size_t i, j;
  string sVar;
  string sFuncName = GetFuncName(sg_func_decl_);
  int do_reference = 0; // mark if the variable arg_idx need de-ref

  vector<void *> vecFunc;
  {
    GetNodesByType_int(GetProject(), "preorder", V_SgFunctionDeclaration,
                       &vecFunc);

    // 0 check if de-ref is needed
    for (j = 0; j < vecFunc.size(); j++) {
      SgFunctionDeclaration *sg_func_decl =
          isSgFunctionDeclaration((SgNode *)vecFunc[j]);
      if (GetFuncName(sg_func_decl) != sFuncName)
        continue;

      void *arg = GetFuncParam(sg_func_decl, arg_idx);
      SgInitializedName *sg_arg = isSgInitializedName((SgNode *)arg);
      assert(sg_arg);

      string sVarName = UnparseToString(arg);
      sVar = sVarName;

      if (sVar.size() > 3 && sVar.substr(sVar.size() - 3) == "p__" &&
          outline_check_false_deref(sg_func_decl, sg_arg)) {
        sVar = sVar.substr(0, sVar.size() - 3);
        do_reference = 1;
        break;
      }
    }

    // 1 replace the arguments
    for (j = 0; j < vecFunc.size(); j++) {
      SgFunctionDeclaration *sg_func_decl =
          isSgFunctionDeclaration((SgNode *)vecFunc[j]);
      if (GetFuncName(sg_func_decl) != sFuncName)
        continue;
      void *arg = GetFuncParam(sg_func_decl, arg_idx);
      SgInitializedName *sg_arg = isSgInitializedName((SgNode *)arg);
      assert(sg_arg);

#ifdef PROJDEBUG
      printf("Var=%s, Do_ref=%d\n", UnparseToString(sg_arg).c_str(),
             do_reference);
#endif
      if (do_reference) {
        SgType *sg_type = sg_arg->get_type();
        SgPointerType *sg_ptr_type = isSgPointerType(sg_type);
        assert(sg_ptr_type);
        sg_type = sg_ptr_type->get_base_type();
        sg_arg->set_type(sg_type);
        sg_arg->set_name(sVar);
        do_reference = 1;
      }

      // fixed by zhangpeng 2013-05-03, add volatile qualifier to the port
      // variables
      arg = GetFuncParam(sg_func_decl, arg_idx);
      // if (UnparseToString(arg) == sVar)
      {
        // SgInitializedName * sg_arg = isSgInitializedName((SgNode*)arg);
        // assert(sg_arg);
        SgType *sg_type = sg_arg->get_type();
        SgPointerType *sg_ptr_type = isSgPointerType(sg_type);
        if (sg_ptr_type) {
          sg_type = sg_ptr_type->get_base_type();
          // sg_type = trace_base_type(sg_ptr_type);
        }
        sg_type = SageBuilder::buildVolatileType(sg_type);
        // markBuild(* this, sg_type, "Build in " + to_string(__LINE__) + " for
        // " + to_string((long) sg_type));
        if (sg_ptr_type) {
          sg_type = SageBuilder::buildPointerType(sg_type);
          // markBuild(* this, sg_type, "Build in " + to_string(__LINE__) + "
          // for " + to_string((long) sg_type));

          string sg_type_string = UnparseToString(sg_type);
          string opencl_type = "__global " + sg_type_string;
#ifdef PROJDEBUG
          printf("before register type __global%s\n", opencl_type.c_str());
#endif
          RegisterType(opencl_type);
          // sg_type = (SgType*)(GetTypeByString(opencl_type));
        }

        // ZP: 2014-04-14
        //     do not add volatile for parameter and iterators (for the loop
        //     pipeline II issue)
        // sg_arg->set_type(sg_type);
        if (sg_ptr_type)
          sg_arg->set_type(sg_type);
      }
    }
  }

  {
    // 2 replace the references
    void *func_body = GetFuncBody(sg_func_decl_);
    if (nullptr != func_body && do_reference) {
      vector<void *> vecRef;
      GetNodesByType_int(func_body, "preorder", V_SgPointerDerefExp, &vecRef);

      for (j = 0; j < vecRef.size(); j++) {
        SgPointerDerefExp *op = isSgPointerDerefExp((SgNode *)vecRef[j]);
        assert(op);
        if (UnparseToString(op->get_operand_i()) != sVar)
          continue;

        replaceExpressionWithHistory(this, op, op->get_operand_i(), true);
      }
    }
  }

  // 3. replace calling
  vector<void *> vecCalls;
  GetNodesByType_int(GetProject(), "preorder", V_SgFunctionCallExp, &vecCalls);
  for (i = 0; do_reference && i < vecCalls.size(); i++) {
    void *sg_call = vecCalls[i];
    void *sg_decl = GetAssociatedFuncDeclByCall(sg_call);
    if (!sg_decl)
      continue; // if it is statically called

    // std::cout << GetFuncName(sg_func_decl) << " " << sFuncName << endl;
    if (GetFuncName(sg_decl) != sFuncName)
      continue;

    vector<void *> vecRef;
    GetNodesByType_int(sg_call, "preorder", V_SgAddressOfOp, &vecRef);

    for (j = 0; j < vecRef.size(); j++) {
      SgAddressOfOp *op = isSgAddressOfOp((SgNode *)vecRef[j]);
      assert(op);
      if (UnparseToString(op->get_operand_i()) != sVar)
        continue;

      replaceExpressionWithHistory(this, op, op->get_operand_i(), true);
    }
  }
}

int CSageCodeGen::analyze_iteration_domain(void *sg_scope_, void *sg_stmt_,
                                           PolyMatrix &matrix) {
  size_t i;
  vector<string> iterators;
  vector<void *> lower, upper;
  //	printf("-- Level 2: analyze iteration domain : \n");
  int ret =
      analyze_iteration_domain(sg_scope_, sg_stmt_, iterators, lower, upper);
  if (!ret)
    return ret;
  //	printf("-- Level 2 back: analyze iteration domain : \n");
  for (i = 0; i < iterators.size(); i++) {
    PolyVector vec_flag(PolyVector::OP_FLAG_POINTER, PolyVector::OP_GE);
    PolyVector vec_var(iterators[i]);
    PolyVector vec_lb, vec_ub;
    //			printf("[codegen] Level 2: check iterator in iteration
    // domain
    // analysis: %s\n", iterators[i].c_str());
    if (!Expr2Vector(isSgExpression((SgNode *)lower[i]), vec_lb, true)) {

      // ZP: 2014-08-21
      // printf("(%s).\n",  iterators[i].c_str());
      // exit(1);

#ifdef PROJDEBUG
      printf("[codegen] WARNING: unsupported lower bound in iteration domain "
             "analysis: \n\t%s\n",
             UnparseToString(lower[i]).c_str());
#endif
      return 0;
    }
    if (!Expr2Vector(isSgExpression((SgNode *)upper[i]), vec_ub, true)) {

      // ZP: 2014-08-21
      // printf("(%s).\n",  iterators[i].c_str());
      // exit(1);

#ifdef PROJDEBUG
      printf("[codegen] WARNING: unsupported upper bound in iteration domain "
             "analysis: \n\t%s\n",
             UnparseToString(lower[i]).c_str());
#endif
      return 0;
    }
    PolyVector row_lb = vec_var - vec_lb + vec_flag;
    vec_flag.set_coeff(PolyVector::OP_FLAG_POINTER,
                       PolyVector::OP_GT); // Fixed by zhangpeng, 2013-05-19
    PolyVector row_ub = vec_ub - vec_var + vec_flag;
    matrix.append_vector(row_lb);
    matrix.append_vector(row_ub);
  }
  matrix.set_iterators(iterators);
  return ret;
}

#if 1
int CSageCodeGen::analyze_iteration_domain(void *sg_scope_, void *sg_stmt_,
                                           vector<string> &iterators,
                                           vector<string> &lower,
                                           vector<string> &upper) {
  size_t i;
  vector<void *> lower_, upper_;
  //	printf("-- Level 1: analyze iteration domain : \n");
  int ret =
      analyze_iteration_domain(sg_scope_, sg_stmt_, iterators, lower_, upper_);
  //	printf("-- Level 1 back: analyze iteration domain : \n");
  for (i = 0; i < iterators.size(); i++) {
    string lb_str;
    string ub_str;
    vector<string> vec_var;

    //			printf("[codegen] Level 1: check loop bound in iteration
    // domain
    // analysis: iter %s,  %s, %s\n", iterators[i].c_str(),
    // UnparseToString(lower_[i]).c_str(), UnparseToString(upper_[i]).c_str());
    if (!Expr2Vector((SgExpression *)(lower_[i]), lb_str, vec_var)) {
      // printf("Level 1 lb: return 0\n");
      return 0;
    }
    if (!Expr2Vector((SgExpression *)(upper_[i]), ub_str, vec_var)) {
      // printf("Level 1 ub: return 0\n");
      return 0;
    }

    lower.push_back(lb_str);
    upper.push_back(ub_str);
    // lower.push_back(UnparseToString(lower_[i]));
    // upper.push_back(UnparseToString(upper_[i]));
  }
  return ret;
}
#endif

// Mo
int CSageCodeGen::analyze_iteration_domain_order(
    void *sg_scope_, void *sg_stmt_, vector<string> &iterators,
    vector<int> &loop_indices, vector<string> &condition, vector<string> &lower,
    vector<string> &upper, int HGT) {
  vector<void *> lower_, upper_;
  int ret = analyze_iteration_domain_order(sg_scope_, sg_stmt_, iterators,
                                           loop_indices, condition, lower_,
                                           upper_, HGT);
#ifdef MO
  for (i = 0; i < iterators.size(); i++) {
    string lb_str;
    string ub_str;
    vector<string> vec_var;
    if (!Expr2Vector((SgExpression *)(lower_[i]), lb_str, vec_var)) {
      return 0;
    }
    if (!Expr2Vector((SgExpression *)(upper_[i]), ub_str, vec_var)) {
      return 0;
    }

    lower.push_back(lb_str);
    upper.push_back(ub_str);
    // lower.push_back(UnparseToString(lower_[i]));
    // upper.push_back(UnparseToString(upper_[i]));
  }
#endif
  return ret;
}

int CSageCodeGen::analyze_iteration_domain_order(
    void *sg_scope_, void *sg_stmt_, vector<string> &iterators,
    vector<int> &loop_indices, vector<string> &condition, vector<void *> &lower,
    vector<void *> &upper, int HGT) {
  int i;
  vector<void *> sg_loops_, sg_loops;
  vector<int> loop_indices_;
#ifdef MO_VERBOSE
  cout << "Outermost Scope:\n\n"
       << UnparseToString(sg_scope_) << endl; // UnparseToString(sg_scope_);
  cout << "Innermost Scope:\n\n"
       << UnparseToString(sg_stmt_) << endl; // UnparseToString(sg_scope_);
#endif

  // 1. get loops in inverse order
  void *sg_node =
      IsStatement(sg_stmt_)
          ? sg_stmt_
          : GetEnclosingNode("Statement", sg_stmt_); // get enclosing statement
  void *child_node = sg_node;
  while (sg_node) {
    sg_node = GetParent(sg_node);
    // if (isSgExpression((SgNode*)sg_node)) continue;  // excluded by finding
    // the enclosing statement at first

    if (!sg_node) {
      printf("!sg_node!\n");
#ifdef MO_VERBOSE
      cout << "Outermost Scope:\n\n"
           << UnparseToString(sg_scope_) << endl; // UnparseToString(sg_scope_);
      cout << "Innermost Scope:\n\n"
           << UnparseToString(sg_stmt_) << endl; // UnparseToString(sg_scope_);
#endif
      break;
    }
    if (sg_node == sg_scope_) {
#ifdef MO_VERBOSE
      cout << "Final Scope:\n\n" << UnparseToString(sg_node);
      cout << endl << endl;
      cout << "Find Child:\n\n" << UnparseToString(child_node);
      cout << endl << endl;
#endif
      int index = 0;
      bool found = GetChildTaskIdx(sg_node, child_node, index, HGT);
      assert(found && "GetChildTaskIdx Failed!");
      loop_indices_.push_back(index);
#ifdef MO_VERBOSE
      cout << "index = " << index << endl;
#endif
      break;
    }
    if (IsBasicBlock(sg_node)) {
#ifdef MO_VERBOSE
      cout << "BB:\n\n" << UnparseToString(sg_node);
#endif
      continue;
    }

    if (IsForStatement(sg_node)) {
#ifdef MO_VERBOSE
      cout << "Scope:\n\n" << UnparseToString(sg_node);
      cout << endl << endl;
      cout << "Find Child:\n\n" << UnparseToString(child_node);
      cout << endl << endl;
#endif
      sg_loops_.push_back(sg_node);
      int index = 0;
      bool found = GetChildTaskIdx(sg_node, child_node, index, HGT);
      assert(found && "getChildTaskIdx Failed!");
      loop_indices_.push_back(index);
      child_node = sg_node;
#ifdef MO_VERBOSE
      cout << "index = " << index << endl;
#endif
      continue;
    }

#ifdef MO_VERBOSE
    cout << "Others: \n\n" << UnparseToString(sg_node);
#endif
    continue;
    // printf("[codegen] WARNING: unsupported statement in iteration domain
    // analysis: \n\t%s\n", UnparseToString(sg_node).c_str());
    // return 0;

    if (IsFunctionDefinition(sg_node)) {
      assert(0);
    }

    if (IsFunctionDeclaration(sg_node)) {
      assert(0);
    }

    assert(0);
    return 0;
  }

  // 2. reverse loops vector
  assert(loop_indices_.size() == sg_loops_.size() + 1);
  i = sg_loops_.size();
  loop_indices.push_back(loop_indices_[i--]);
  for (; i >= 0; i--) {
    sg_loops.push_back(sg_loops_[i]);
    loop_indices.push_back(loop_indices_[i]);
  }

  // 3. fill information
  for (size_t i = 0; i < sg_loops.size(); i++) {
    void *sg_loop = sg_loops[i];
    void *ivar = nullptr;
    void *lb = nullptr, *ub = nullptr, *step = nullptr;
    void *loop_body = nullptr;
    void *cond_op;
    int ulimit = 0;
#ifdef MO
    int is_canonical = ParseOneForLoop(sg_loop, ivar, lb, ub, step, cond_op,
#else
    ParseOneForLoop(sg_loop, ivar, lb, ub, step, cond_op,
#endif
                                       loop_body, ulimit);
#ifdef MO
    if (is_canonical == 0
        //			|| "0" != UnparseToString(lb)
        || str_remove_space(UnparseToString(ivar) + "++") !=
               str_remove_space(UnparseToString(step))
        //			||
        // remove_space(codegen.UnparseToString(ivar)+"<"+codegen.UnparseToString(ub))
        //!= remove_space(codegen.UnparseToString(cond_op))
    ) {
#ifdef PROJDEBUG
      printf("[codegen] WARNING: unsupported for-loop in iteration domain "
             "analysis: \n\t%s\n",
             UnparseToString(sg_loop).c_str());
#endif
      // assert(0);
      return 0;
    }
#endif

    iterators.push_back(UnparseToString(ivar));
    lower.push_back(lb);
    upper.push_back(ub);
    condition.push_back("1");
  }

  return 1;
}

int CSageCodeGen::analyze_iteration_domain(void *sg_scope_, void *sg_stmt_,
                                           vector<string> &iterators,
                                           vector<void *> &lower,
                                           vector<void *> &upper) {
  int i;
  vector<void *> sg_loops_, sg_loops;

  // 1. get loops in inverse order
  void *sg_node =
      IsStatement(sg_stmt_)
          ? sg_stmt_
          : GetEnclosingNode("Statement", sg_stmt_); // get enclosing statement
  while (sg_node) {
    sg_node = GetParent(sg_node);
    // if (isSgExpression((SgNode*)sg_node)) continue;  // excluded by finding
    // the enclosing statement at first
    if (!sg_node)
      break;
    if (sg_node == sg_scope_)
      break;
    if (IsBasicBlock(sg_node))
      continue;

    if (IsForStatement(sg_node)) {
      sg_loops_.push_back(sg_node);
      continue;
    }

    // 20151123 youxiang, there are some structure we cannot support
    // such as while statement
    return 0;
    // printf("[codegen] WARNING: unsupported statement in iteration domain
    // analysis: \n\t%s\n", UnparseToString(sg_node).c_str());
    // return 0;

    if (IsFunctionDefinition(sg_node)) {
      assert(0);
    }

    if (IsFunctionDeclaration(sg_node)) {
      assert(0);
    }

    assert(0);
  }

  // 2. reverse loops vector
  for (i = sg_loops_.size() - 1; i >= 0; i--) {
    sg_loops.push_back(sg_loops_[i]);
  }

  // 3. fill information

  for (size_t i = 0; i < sg_loops.size(); i++) {
    void *sg_loop = sg_loops[i];
    void *ivar = nullptr;
    void *lb = nullptr, *ub = nullptr, *step = nullptr;
    void *loop_body = nullptr;
    void *cond_op;
    int ulimit = 0;
    int is_canonical = ParseOneForLoop(sg_loop, ivar, lb, ub, step, cond_op,
                                       loop_body, ulimit);
    if (is_canonical == 0
        //			|| "0" != UnparseToString(lb)
        //||
        // str_remove_space(UnparseToString(ivar) + "++") !=
        //    str_remove_space(UnparseToString(step))
        //			||
        // remove_space(codegen.UnparseToString(ivar)+"<"+codegen.UnparseToString(ub))
        //!= remove_space(codegen.UnparseToString(cond_op))
    ) {
      // printf("[codegen] WARNING: unsupported for-loop in iteration domain
      // analysis: \n\t%s\n", UnparseToString(sg_loop).c_str());

      //(added by Hui)
      // if (i == sg_loops.size())
      return 0;
      // assert(0);
    }

    // printf("[codegen] Level 0: check loop bound in iteration domain analysis:
    // iter %s,  %s, %s\n",  UnparseToString(ivar).c_str(),
    // UnparseToString(lb).c_str(), UnparseToString(ub).c_str());
    iterators.push_back(UnparseToString(ivar));
    lower.push_back(lb);
    upper.push_back(ub);
  }

  return 1;
}
#endif
#if 0
int CSageCodeGen::is_merlin_channel_read(void *ref) {

  int param_index = GetFuncCallParamIndex(ref);
  if (-1 == param_index)
    return 0;
  void *sg_call = TraceUpToFuncCall(ref);
  if (!sg_call)
    return 0;
  if (0 == GetFuncNameByCall(sg_call).find("merlin_stream_read"))
    return 1;
  return 0;
}

int CSageCodeGen::is_merlin_channel_write(void *ref) {
  int param_index = GetFuncCallParamIndex(ref);
  if (-1 == param_index)
    return 0;
  void *sg_call = TraceUpToFuncCall(ref);
  if (!sg_call)
    return 0;
  if (0 == GetFuncNameByCall(sg_call).find("merlin_stream_write") &&
      param_index == 0)
    return 1;
  return 0;
}
#endif


/*
// ZP: 20150818
// only work for variable ref or pntr ref
int CSageCodeGen::is_read_conservative(void *ref) {
  SgNode *sg_parent = (SgNode *)GetParent(ref);
  void *sg_left = nullptr;
  void *sg_right = nullptr;
  GetExpOperand(sg_parent, sg_left, sg_right);

  if (isSgAssignOp(sg_parent) && ref == sg_left)
    return 0;
  if (IsOverideAssignOp(sg_parent) && ref == sg_left)
    return 0;
  //////////////////////////////////
  // ZP: 2016-06-13: modified according to bug374
  //if (isSgCompoundAssignOp(sg_parent) && ref == sg_left)
  //  return 0;
  //if (isSgPlusPlusOp(sg_parent) && ref == sg_left)
  //  return 0;
  //if (isSgMinusMinusOp(sg_parent) && ref == sg_left)
  //  return 0;
  if (isSgCompoundAssignOp(sg_parent) && ref == sg_left)
    return 1;
  if (isSgPlusPlusOp(sg_parent) && ref == sg_left)
    return 1;
  if (isSgMinusMinusOp(sg_parent) && ref == sg_left)
    return 1;
  if (isSgUnaryOp(sg_parent)) {
    if (isSgAddressOfOp(sg_parent))
      return is_read_conservative(sg_parent);
    if (isSgPointerDerefExp(sg_parent))
      return is_read_conservative(sg_parent);
  }
  return 1;
}*/

#if 0
// ref is the innermost VarRefExp
void CSageCodeGen::get_pntr_from_var(void *ref, void *&sg_pntr) {
  sg_pntr = isSgPntrArrRefExp((SgNode *)ref);

  while (isSgPntrArrRefExp((SgNode *)GetParent(ref)) &&
         isSgPntrArrRefExp((SgNode *)GetParent(ref))->get_lhs_operand() ==
             ref) {
    ref = GetParent(ref);
    sg_pntr = ref;
  }
}
#endif

// Yuxin: 02/12/2019
// Change the original loop's pointer if it is replaced
// Yuxin: 01/16/2019
// For Intel AOCL 18.1 use, when insert a loop related pragma before a loop with
// label The label cannot be inserted before the loop
void CSageCodeGen::InsertStmtAvoidLabel(void *sg_stmt_, void *&sg_before_) {

  void *parent = GetParent(sg_before_);
  // Yuxin: 05/17/18 after ROSE lib update
  // Label is changed from a normal statement to a scope
  if (parent && IsLabelStatement(parent)) {
    if (IsPragmaDecl(sg_stmt_)) {
      SgLabelStatement *label = isSgLabelStatement((SgNode *)parent);
      void *bb = CreateBasicBlock();
      void *copy_stmt = CopyStmt(sg_before_);
      vector<void *> old_decls;
      vector<void *> new_decls;
      GetNodesByType_int(sg_before_, "preorder", V_SgVariableDeclaration,
                         &old_decls);
      GetNodesByType_int(copy_stmt, "preorder", V_SgVariableDeclaration,
                         &new_decls);
      for (size_t j = 0; j < old_decls.size(); j++) {
        void *new_init = GetVariableInitializedName(new_decls[j]);
        void *old_init = GetVariableInitializedName(old_decls[j]);
        replace_variable_references_in_scope(old_init, new_init, copy_stmt);
      }
      AppendChild(bb, copy_stmt);
      string label_str = GetLabelName(label);
      SgLabelStatement *ls = SageBuilder::buildLabelStatement(
          label_str, (SgBasicBlock *)bb, (SgScopeStatement *)GetScope(label));
      ReplaceStmt(label, ls);
      InsertStmt(sg_stmt_, copy_stmt);
      sg_before_ = copy_stmt;
      return;
    }
  }
  // else
  InsertStmt(sg_stmt_, sg_before_);
}



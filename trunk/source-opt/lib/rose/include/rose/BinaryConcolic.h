#ifndef ROSE_BinaryAnalysis_Concolic_H
#define ROSE_BinaryAnalysis_Concolic_H
#include <featureTests.h>
#ifdef  ROSE_ENABLE_CONCOLIC_TESTING

// Which database implementation should be used
// Version 1 was implemented as part of ROSE in 2019 and supports only SQLite
// Version 2 is from Sawyer and supports SQLite and PostgreSQL
#ifndef ROSE_CONCOLIC_DB_VERSION
#define ROSE_CONCOLIC_DB_VERSION 2
#endif

// ROSE headers
#include <Diagnostics.h>
#include <Partitioner2/BasicTypes.h>
#include <rose_isnan.h>
#include <rose_strtoull.h>
#include <RoseException.h>
#if ROSE_CONCOLIC_DB_VERSION == 1
    #include <SqlDatabase.h>
#else
    #include <Sawyer/Database.h>
#endif

// Non-ROSE headers
#include <boost/filesystem.hpp>

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
#include <boost/serialization/export.hpp>
#include <boost/serialization/access.hpp>
#include <boost/serialization/nvp.hpp>
#include <boost/serialization/base_object.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/xml_iarchive.hpp>
#include <boost/archive/xml_oarchive.hpp>
#endif /* ROSE_HAVE_BOOST_SERIALIZATION_LIB */

#include <boost/numeric/conversion/cast.hpp>
#include <memory>
#include <Sawyer/BiMap.h>
#include <Sawyer/SharedObject.h>
#include <Sawyer/SharedPointer.h>
#include <Sawyer/Synchronization.h>
#include <stdexcept>
#include <string>
#include <vector>

namespace Rose {
namespace BinaryAnalysis {

/** Concolic testing system.
 *
 *  This namespace defines a framework for writing concolic testing systems. A system consists of these main parts:
 *
 *  @li A @em database stores all information about the state of the system.  All state is localized to the database; the
 *      functional parts of the system are stateless. This allows a long-running concolic test to be interrupted and restarted
 *      later.
 *
 *  @li A @em test case describes what to run and how to run it. This includes such things as the command-line, input files,
 *      virtual memory characteristics, system call handling, etc.
 *
 *  @li A @em manager reads the database and runs the other functional parts of the system, perhaps in parallel. The manager is
 *      also responsible for ranking and deduplication of test cases. The ranking uses a user-defined metric computed by the
 *      concrete executer (described below) to decide which test case to run next in the symbolic executer (defined below). The
 *      deduplication removes test cases generated by the symbolic executor if they already exist in the database (perhaps
 *      using approximate comparisons).
 *
 *  @li A <em>concrete executor</em> executes a test case concretely and measures certain user-defined characteristics. The
 *      results are saved in the database.
 *
 *  @li A <em>concolic executor</em> executes a test case both concretely (by emulation) and symbolically and generates new
 *      test cases that are inserted into the database. */
namespace Concolic {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Flags and enums
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace Update {
enum Flag { NO, YES };
} // namespace

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Exceptions, errors, etc.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Diagnostic facility for concolic testing. */
extern Sawyer::Message::Facility mlog;

// Internal: called by Rose::Diagnostics::initialize
void initDiagnostics();

/** Base class for exceptions for concolic testing. */
class Exception: public Rose::Exception {
public:
    explicit Exception(const std::string &mesg): Rose::Exception(mesg) {}
    ~Exception() throw () {}
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Forward references
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class Specimen;
typedef Sawyer::SharedPointer<Specimen> SpecimenPtr;

class TestCase;
typedef Sawyer::SharedPointer<TestCase> TestCasePtr;

class ConcreteExecutor;
typedef Sawyer::SharedPointer<ConcreteExecutor> ConcreteExecutorPtr;

class LinuxExecutor;
typedef Sawyer::SharedPointer<LinuxExecutor> LinuxExecutorPtr;

class ConcolicExecutor;
typedef Sawyer::SharedPointer<ConcolicExecutor> ConcolicExecutorPtr;

class TestSuite;
typedef Sawyer::SharedPointer<TestSuite> TestSuitePtr;

class Database;
typedef Sawyer::SharedPointer<Database> DatabasePtr;

class ExecutionManager;
typedef Sawyer::SharedPointer<ExecutionManager> ExecutionManagerPtr;

class LinuxExitStatus;
typedef Sawyer::SharedPointer<LinuxExitStatus> LinuxExitStatusPtr;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Specimens
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Binary specimen.
 *
 *  The speciment represents the thing that is to be tested, but not how to test it.  In other words, a specimen might be an
 *  executable, but not any specifics about how to run the executable such as which arguments to give it. */
class Specimen: public Sawyer::SharedObject, public Sawyer::SharedFromThis<Specimen> {
public:
    /** Referenc-counting pointer to a @ref Specimen. */
    typedef Sawyer::SharedPointer<Specimen> Ptr;

    /** Binary data, such as for the specimen content. */
    typedef std::vector<uint8_t> BinaryData;

private:
    mutable SAWYER_THREAD_TRAITS::Mutex mutex_;         // protects the following data members
    std::string name_;                                  // name of specimen (e.g., for debugging)
    std::string timestamp_;                             // time of creation
    BinaryData content_;                                // content of the binary executable file
    mutable bool read_only_;                            // safe guards from writing content after it has been shared;
    bool empty_;                                        // indicates if this object is empty

private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        s & BOOST_SERIALIZATION_NVP(name_);
        s & BOOST_SERIALIZATION_NVP(content_);
        s & BOOST_SERIALIZATION_NVP(empty_);
    }

protected:
    Specimen()
        : read_only_(false), empty_(false)
        {}

public:
    /** Allocating constructor.
     * @{ */
    static Ptr instance(const boost::filesystem::path &executableName);
    static Ptr instance();
    /** @} */

    /** Open an executable file.
     *
     *  The contents of the executable file are copied into this object when the file is opened.  After the file is opened
     *  successfully, the @ref isEmpty predicate returns false.  Throws an @ref Exception if the file cannot be opened.
     *
     *  Thread safety: This method is thread-safe. */
    void open(const boost::filesystem::path &executableName);

    /** Close the executable file.
     *
     *  Removes all content from this object, or does nothing if @ref isEmpty returns true. After this call, @ref isEmpty
     *  returns true.
     *
     *  Thread safety: This method is thread-safe. */
    void close();

    /** Test whether this object is empty.
     *
     *  Returns true if no binary executable is associated with this specimen, false otherwise. See also, @ref open and @ref close.
     *
     *  Thread safety: This method is thread-safe. */
    bool isEmpty() const;

    /** Property: Specimen name.
     *
     *  This should be a printable name, such as a file name. It's used mostly for informational purposes such as
     *  debugging. There is no requirement that names be unique or non-empty or contain only printable characters.
     *
     *  Thread safety: This methods is thread-safe.
     *
     * @{ */
    std::string name() const;                           // value return is intentional for thread safety
    void name(const std::string&);
    /** @} */

    /** Returns printable name of specimen for diagnostic output.
     *
     *  Returns a string suitable for printing to a terminal, containing the word "specimen", the database ID if appropriate,
     *  and the specimen name using C-style double-quoted string literal syntax if not empty.  The database ID is shown if a
     *  non-null database is specified and this specimen exists in that database. */
    std::string printableName(const DatabasePtr &db = DatabasePtr());

    /** Property: Database creation timestamp string.
     *
     *  Time stamp string describing when this object was created in the database, initialized the first time the object is
     *  written to the database. If a value is assigned prior to writing to the database, then the assigned value is used
     *  instead. The value is typically specified in ISO-8601 format (except a space is used to separate the date and time for
     *  better readability, as in RFC 3339). This allows dates to be sorted chronologically as strings.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    std::string timestamp() const;
    void timestamp(const std::string&);
    /** @} */

    /** Property: Specimen content.
     *
     *  This property contains the bytes that compose a specimen. For instance, for an ELF executable, the content is the bytes
     *  that compose the executable file.  This property is read-only, initialized when the @ref Specimen is created.
     *
     *  Thread safety: This method is not thread safe since it returns a reference. */
    const std::vector<uint8_t>& content() const;

    // FIXME[Robb Matzke 2019-08-12]: content is read-only, created by constructor. Therefore this member shouldn't be defined,
    // or at least should be private.
    /** The setter helps to conveniently populate a Specimen's properties
     *  from a database query. */
    void content(std::vector<uint8_t> binary_data);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Test cases
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Environment variable and its value. */
typedef std::pair<std::string /*name*/, std::string /*value*/> EnvValue;

/** Information about how to run a specimen.
 *
 *  This object points to a specimen and also contains all the information necessary to run the specimen. */
class TestCase: public Sawyer::SharedObject, public Sawyer::SharedFromThis<TestCase> {
public:
    /** Reference counting pointer to a @ref TestCase. */
    typedef Sawyer::SharedPointer<TestCase> Ptr;

private:
    mutable SAWYER_THREAD_TRAITS::Mutex mutex_;         // protects the following data members
    std::string name_;                                  // name for debugging
    std::string timestamp_;                             // time of creation
    std::string executor_;                              // name of execution environment
    Specimen::Ptr specimen_;                            // the thing to run
    std::vector<std::string> args_;                     // command line arguments
    std::vector<EnvValue> env_;                         // environment variables
    Sawyer::Optional<size_t> concolicResult_;           // non-empty if concolically tested
    Sawyer::Optional<double> concreteRank_;             // rank after testing
    bool concreteIsInteresting_;                        // concrete results present and interesting?

protected:
    TestCase()
        : concreteIsInteresting_(false) {}

public:
    /** Allocating default constructor. */
    static Ptr instance() {
        return Ptr(new TestCase);
    }

    /** Allocating constructor. */
    static Ptr instance(const Specimen::Ptr &specimen);

    /** Property: Test case name.
     *
     *  This should be a printable name, such as a specimen name and/or serial number. It's used mostly for informational
     *  purposes such as debugging. There is no requirement that the name be unique or non-empty.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    std::string name() const;                           // value return is intentional for thread safety
    void name(const std::string&);
    /** @} */

    /** Returns printable name of test case for diagnostic output.
     *
     *  Returns a string suitable for printing to a terminal, containing the words "test case", the database ID if appropriate,
     *  and the test case name using C-style double-quoted string literal syntax if not empty.  The database ID is shown if a
     *  non-null database is specified and this test case exists in that database. */
    std::string printableName(const DatabasePtr &db = DatabasePtr());

    /** Property: Database creation timestamp string.
     *
     *  Time stamp string describing when this object was created in the database, initialized the first time the object is
     *  written to the database. If a value is assigned prior to writing to the database, then the assigned value is used
     *  instead. The value is typically specified in ISO-8601 format (except a space is used to separate the date and time for
     *  better readability, as in RFC 3339). This allows dates to be sorted chronologically as strings.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    std::string timestamp() const;
    void timestamp(const std::string&);
    /** @} */

    /** Property: Specimen.
     *
     *  The specimen that is being examined by this test case.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    Specimen::Ptr specimen() const;
    void specimen(const Specimen::Ptr&);
    /** @} */

    /** Command line arguments.
     *
     *  The arguments exclude <code>argv[0]</code> and <code>argv[argc]</code> and are just the elements in between.
     *
     * @{ */
    std::vector<std::string> args() const;
    void args(std::vector<std::string> arguments);
    /** @} */

    /** Environment variables.
     * @{ */
    std::vector<EnvValue> env() const;
    void env(std::vector<EnvValue> envvars);
    /** @} */

    /** Property: Result of concolic testing.
     *
     *  At this time, the result is meaningless and only used to indicate whether concolic testing has been performed.
     *
     * @{ */
    Sawyer::Optional<size_t> concolicResult() const {
        return concolicResult_;
    }
    void concolicResult(const Sawyer::Optional<size_t> &x) {
        concolicResult_ = x;
    }
    /** @} */

    /** Predicate testing whether this test case has been run concolically. */
    bool hasConcolicTest() const;

    /** Property: Sorting rank resulting from concrete test.
     *
     *  This property is also updated whenever concrete results are attached to this object.
     *
     * @{ */
    Sawyer::Optional<double> concreteRank() const;
    void concreteRank(Sawyer::Optional<double> val);
    /** @} */

    /** Property: Whether concrete results are interesting.
     *
     *  True if concrete results are present and interesting. False if not present or not interesting. Results are generally
     *  not interesting if they're the same as some other test case.
     *
     *  This property is also updated whenever concrete results are attached to this object.
     *
     * @{ */
    bool concreteIsInteresting() const;
    void concreteIsInteresting(bool);
    /** @} */

    /** Predicate testing whether this test case has been run concretely.
     *
     *  Returns true if the test case has any results. */
    bool hasConcreteTest() const;

    /** Property: Name of execution environment.
     *
     * @{ */
    const std::string& executor() const {
        return executor_;
    }
    void executor(const std::string &x) {
        executor_ = x;
    }
    /** @} */

    // We'll need to add additional information about how to run the specimen:
    //   3. Auxilliary vector (auxv)
    //   4. System calls that provide input (e.g., virtual file system, network, etc.)
    // Some of this information might need to be separated into subclasses that support different architectures since the
    // info for testing a Linux ELF executable is different from a Windows PE executable, which is different from how one
    // would run firmware.
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Concrete executors and their results
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

extern const char* const tagConcreteExecutorResult;
extern const char* const tagLinuxExecutorResult;

/** Base class for executing test cases concretely.
 *
 *  The user is expected to subclass this object in order to define the specifics of how to execute a test case concretely,
 *  measure some properties of the execution, and return those properties. A basic @ref LinuxExecutor subclass is already
 *  provided to give an example of how to run a program and measure its exit status. Other more complex executors might do
 *  things like measure code coverage.
 *
 *  ConcreteExecutor objects are expected to be used in single-threaded applications. Supporting multi-threaded concrete
 *  executors would be difficult since calling fork[2] from multi-threaded C++ programs is fraught with danger. Therefore, none
 *  of the methods in this API are thread-safe. */
class ConcreteExecutor: public Sawyer::SharedObject {
public:
    /** Reference counting pointer to a @ref ConcreteExecutor. */
    typedef Sawyer::SharedPointer<ConcreteExecutor> Ptr;

    /** Base class for user-defined concrete execution results.
     *
     *  Regardless of what data a subclass might add, all concrete execution results have a floating-point "rank" used to sort
     *  them when creating the list of test cases that should next run in the concolic (combined concrete and symbolic)
     *  executor. The convention is that those with lower ranks will run before those with higher ranks, although subclasses of
     *  @ref ExecutionManager can override this. The rank should be a real number (not NaN).
     *
     *  The subclasses must provide @c boost::serialization support which is used to store the user-defined results in the
     *  database and to reconstitute results objects from the database. Since this is a relatively expensive operation, the
     *  rank is also stored separately within the database. */
    class Result {
    private:
        double rank_;
        bool isInteresting_;

    public:
        Result()
            : rank_(0.0), isInteresting_(true) {}

        explicit Result(double rank)
            : rank_(rank), isInteresting_(true) {
            ASSERT_forbid(rose_isnan(rank));
        }

        virtual ~Result() {}

        double rank() const { return rank_; }
        void rank(double r) { rank_ = r; }

        bool isInteresting() const { return isInteresting_; }
        void isInteresting(bool b) { isInteresting_ = b; }

    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(rank_);
        }
    };

private:
    DatabasePtr db_;

protected:
    // Allocating constructors should be implemente by the non-abstract subclasses.
    explicit ConcreteExecutor(const DatabasePtr&);

public:
    /** Database provided to constructor. */
    DatabasePtr database() const;

    /** Execute one test case synchronously.
     *
     *  Returns the results from running the test concretely. Results are user-defined. The return value is never a null
     *  pointer. */
    virtual Result* execute(const TestCase::Ptr&) = 0;

    // FIXME[Robb Matzke 2020-07-14]: This should be in a subclass
    /** \brief
     *  Sets an execution monitor for a test run. The execution monitor
     *  observes a test and computes a quality score that can be used to
     *  rank different executions (higher indicates better quality).
     *
     *  \details
     *  The execution monitor (e.g., execmon) needs to understand the
     *  following command line arguments:
     *    execmon -o outfile -- specimen test-arguments..
     *      -o outfile       a file containing two lines:
     *  or  --output=outfile (1) a human-readable integer value,
     *                           the exit code of the child process;
     *                       (2) a human-readable floating point value,
     *                           the quality score of the execution.
     *      --               separator between arguments to execmon
     *                       and test specification.
     *      specimen         the tested specimen
     *      test-arguments.. an arbitrary long argument list passed
     *                       to specimen.
     *
     *  @{
     */
    void executionMonitor(const boost::filesystem::path& executorName)
    {
      execmon = executorName;
    }

    // FIXME[Robb Matzke 2020-07-14]: This should be in a subclass
    boost::filesystem::path executionMonitor() const
    {
      return execmon;
    }
    /** @} */

private:
    // FIXME[Robb Matzke 2020-07-14]: This should be in a subclass
    boost::filesystem::path execmon; // the execution monitor
};

/** Concrete executor to trace a native ELF executable.
 *
 *  Ranks executables by the size of the set of addresses that were executed. */
class LinuxTraceExecutor: public ConcreteExecutor {
public:
    /** Reference counting pointer to a @ref LinuxTraceExecutor. */
    using Ptr = Sawyer::SharedPointer<LinuxTraceExecutor>;

    /** Results of the execution. */
    class Result: public ConcreteExecutor::Result {
    public:
        int exitStatus;                                 // as returned by wait
        AddressSet executedVas;

    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & boost::serialization::make_nvp("base", boost::serialization::base_object<ConcreteExecutor::Result>(*this));
            s & BOOST_SERIALIZATION_NVP(executedVas);
        }
    };

protected:
    explicit LinuxTraceExecutor(const DatabasePtr&);

public:
    /** Allocating constructor. */
    static Ptr instance(const DatabasePtr&);

    /** Specimen exit status, as returned by wait. */
    static int exitStatus(const ConcreteExecutor::Result*);

    /** Executed virtual addresses. */
    const AddressSet& executedVas(const ConcreteExecutor::Result*);

    ConcreteExecutor::Result* execute(const TestCase::Ptr&) override;
};

/** Concrete executor for Linux ELF executables. */
class LinuxExecutor: public ConcreteExecutor {
public:
    /** Reference counting pointer to a @ref LinuxExecutor. */
    typedef Sawyer::SharedPointer<LinuxExecutor> Ptr;

    /** Holds an optional personality-value (i.g., indicating if address randomization should be turned off). */
    typedef Sawyer::Optional<unsigned long> Persona;

    /** Base class for user-defined Linux concrete execution results. */
    class Result: public ConcreteExecutor::Result {
    protected:
        int         exitStatus_;   /**< Exit status as returned by waitpid[2]. */
        std::string exitKind_;     /**< Textual representation how the Result exited */
        std::string capturedOut_;  /**< Output written to STDOUT */
        std::string capturedErr_;  /**< Output written to STDERR */

    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            // was: s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(ConcreteExecutor::Result);
            //      nvp of a base class in a different namespace seems to produce
            //      invalid results.
            s & boost::serialization::make_nvp( tagConcreteExecutorResult,
                                                boost::serialization::base_object<ConcreteExecutor::Result>(*this)
                                              );
            s & BOOST_SERIALIZATION_NVP(exitStatus_);
            s & BOOST_SERIALIZATION_NVP(exitKind_);
            s & BOOST_SERIALIZATION_NVP(capturedOut_);
            s & BOOST_SERIALIZATION_NVP(capturedErr_);
        }

    public:
        Result(double rank, int exitStatus);

        Result() {} // required for boost serialization

        /** Property: Exit status of the executable.
         *
         *  The executable exit status is the value returned by waitpid[2] and contains not only the argument of the program's
         *  "exit" function, but also information about whether the program called exit or was terminated by a signal, and
         *  whether the signal produced a core dump.
         *
         * @{ */
        int exitStatus() const { return exitStatus_; }
        void exitStatus(int x);
        /** @} */

        /** Property: Output to STDOUT and STDERR of the executable
         *
         * @{ */
        std::string out() const             { return capturedOut_; }
        void out(const std::string& output) { capturedOut_ = output; }

        std::string err() const             { return capturedErr_; }
        void err(const std::string& output) { capturedErr_ = output; }
        /** @} */

        /** Property: textual representation of how a test exited.
         *            The property is set together with exitStatus.
         * @{ */
        std::string exitKind() const            { return exitKind_; }
        /* @} */
    };

protected:
    bool useAddressRandomization_;                      // enable/disable address space randomization in the OS

protected:
    explicit LinuxExecutor(const DatabasePtr&);

public:
    /** Allocating constructor. */
    static Ptr instance(const DatabasePtr&);

    /** Property: Address space randomization.
     *
     *  This property controls whether the specimen is executed with or without OS address space randomization. It's usually
     *  better to turn off randomization for repeatable results, and it is therefore off by default.
     *
     * @{ */
    bool useAddressRandomization() const { return useAddressRandomization_; }
    void useAddressRandomization(bool b) { useAddressRandomization_ = b; }
    /** @} */

    virtual
    Result* execute(const TestCase::Ptr&) ROSE_OVERRIDE;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Concolic (concrete + symbolic) executors
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

} // namespace
} // namespace
} // namespace

#include <Concolic/ConcolicExecutor.h>

namespace Rose {
namespace BinaryAnalysis {
namespace Concolic {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Test suites
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Test suite.
 *
 *  A <em>test suite</em> is a coherent collection of test cases. The test suite usually starts with a single "seed" test case
 *  and contains additional test cases generated by the concolic executor. All test cases within a test suite use the same
 *  concrete executor and measure the same user-defined execution properties. For example, the database might contain one test
 *  suite based on "/bin/grep" and another test suite running "/bin/cat".  Or it might have two test suites both running
 *  "/bin/grep" but one always using "--extended-regexp" and the other always using "--basic-regexp".  Or it might have two
 *  test suites both running "/bin/cat" but one measures exit status and the other measures code coverage.
 *
 *  A @ref Database has a "current test suite" set/queried by its @ref Database::testSuite "testSuite" method. Inserting
 *  new objects will insert them into the current test suite, and queries will return objects that belong to the current
 *  test suite. */
class TestSuite: public Sawyer::SharedObject, public Sawyer::SharedFromThis<TestSuite> {
public:
    /** Reference counting pointer to @ref TestSuite. */
    typedef Sawyer::SharedPointer<TestSuite> Ptr;

private:
    mutable SAWYER_THREAD_TRAITS::Mutex mutex_;         // protects the following data members
    std::string name_;                                  // unique and non-empty within a database
    std::string timestamp_;                             // time of creation

protected:
    TestSuite() {}

public:
    /** Allocating constructor. */
    static Ptr instance(const std::string &name = "");

    /** Property: Name.
     *
     *  Within a database, a test suite must have a unique non-empty name. However this is not a requirement when the test
     *  suite exists only in memory. The constraints are enforced when the test suite is added to the database.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    std::string name() const;                           // value return is intentional for thread safety
    void name(const std::string&);
    /** @} */

    /** Returns printable name of test suite for diagnostic output.
     *
     *  Returns a string suitable for printing to a terminal, containing the words "test suite", the database ID if
     *  appropriate, and the test suite name using C-style double-quoted string literal syntax if not empty.  The database ID
     *  is shown if a non-null database is specified and this test suite exists in that database. */
    std::string printableName(const DatabasePtr &db = DatabasePtr());

    /** Property: Database creation timestamp string.
     *
     *  Time stamp string describing when this object was created in the database, initialized the first time the object is
     *  written to the database. If a value is assigned prior to writing to the database, then the assigned value is used
     *  instead. The value is typically specified in ISO-8601 format (except a space is used to separate the date and time for
     *  better readability, as in RFC 3339). This allows dates to be sorted chronologically as strings.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    std::string timestamp() const;
    void timestamp(const std::string&);
    /** @} */
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Databases
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** ID class for database objects. */
template <class Tag>
class ObjectId: public Sawyer::Optional<size_t> {
public:
    typedef size_t                  Value;         /**< Type of ID. */
    typedef Sawyer::Optional<Value> Super;         /**< Supertype of this class. */
    typedef Tag                     Object;        /**< Type of object to which this ID refers. */

    ObjectId() {}

    explicit
    ObjectId(const Value& v)
        : Super(v) {}

    ObjectId(const ObjectId& rhs)
        : Super(rhs) {}

    explicit ObjectId(const Sawyer::Optional<size_t> &id)
        : Super(id) {}

    /** Construct by parsing a string.
     *
     * This constructor creates an object ID by parsing it from a string. The string should consist of optional white space,
     * followed by a non-negative integer in C-style syntax (an optional radix prefix "0x", "0b", or "0", followed by digits
     * followed by optional additional white space. Syntactically incorrect input will result in throwing an @ref Exception. */
    explicit ObjectId(const std::string &s) {
        char *rest = NULL;
        uint64_t id = rose_strtoull(s.c_str(), &rest, 0);
        while (*rest && isspace(*rest)) ++rest;
        if (*rest)
            throw Exception("invalid syntax for object ID: \"" + StringUtility::cEscape(s) + "\"");
        try {
            *this = boost::numeric_cast<Value>(id);
        } catch (const boost::bad_numeric_cast&) {
            throw Exception("parsed object ID out of range: \"" + StringUtility::cEscape(s) + "\"");
        }
    }

    /** Assignment operator to replace default generated one. */
    ObjectId<Tag>& operator=(const ObjectId<Tag>& lhs) {
        this->Super::operator=(lhs);
        return *this;
    }

    /** Assignment overload to allow assignments of Value objects. */
    ObjectId<Tag>& operator=(const Value& v) {
        this->Super::operator=(v);
        return *this;
    }

    explicit operator bool() const {                    // because it's not explicit in the super class due to C++03 support
        return isEqual(Sawyer::Nothing()) ? false : true;
    }

    /** external operator to define ordering. */
    template<class _Tag>
    friend
    bool operator<(const ObjectId<_Tag>& lhs, const ObjectId<_Tag>& rhs);
};

/** defines ordering of ObjectIds. */
template<class Tag>
inline
bool operator<(const ObjectId<Tag>& lhs, const ObjectId<Tag>& rhs)
{
    if (!rhs) return false;
    if (!lhs) return true;

    return lhs.get() < rhs.get();
}

typedef ObjectId<TestSuite> TestSuiteId;                /**< Database ID for test suite objects. */
typedef ObjectId<Specimen>  SpecimenId;                 /**< Database ID for specimen objects. */
typedef ObjectId<TestCase>  TestCaseId;                 /**< Database ID for test case objects. */

/** Object traits.
 *
 *  T is the object type, such as TestSuite. */
template<class T>
struct ObjectTraits {
    using Id = void;
};

template<>
struct ObjectTraits<TestSuite> {
    using Id = TestSuiteId;
};

template<>
struct ObjectTraits<Specimen> {
    using Id = SpecimenId;
};

template<>
struct ObjectTraits<TestCase> {
    using Id = TestCaseId;
};

/** Database.
 *
 *  A database holds the entire state for a concolic testing system consisting of one or more test suites. A @ref Database
 *  object is always connected to exactly one database and limits the scope of its operations to exactly one test suite (except
 *  where noted).
 *
 *  A @ref Database object refers to persistent storage and supports both PostgreSQL databases and SQLite3 databases and the
 *  the possibility of adding other RDMSs later.
 *
 *  Objects within a database have an ID number, and these ID numbers are type-specific. When an object is inserted (copied)
 *  into a database a new ID number is returned. The @ref Database object memoizes the association between object IDs and
 *  objects. */
class Database: public Sawyer::SharedObject, public Sawyer::SharedFromThis<Database>, boost::noncopyable {
public:
    /** Reference counting pointer to @ref Database. */
    typedef Sawyer::SharedPointer<Database> Ptr;

    typedef ::Rose::BinaryAnalysis::Concolic::TestSuiteId TestSuiteId;
    typedef ::Rose::BinaryAnalysis::Concolic::SpecimenId  SpecimenId;
    typedef ::Rose::BinaryAnalysis::Concolic::TestCaseId  TestCaseId;

private:
#if ROSE_CONCOLIC_DB_VERSION == 1
    SqlDatabase::ConnectionPtr dbconn_;                 // connection to database
#else
    Sawyer::Database::Connection connection_;
#endif

    // Memoization of ID to object mappings
    Sawyer::Container::BiMap<SpecimenId, Specimen::Ptr>   specimens_;
    Sawyer::Container::BiMap<TestCaseId, TestCase::Ptr>   testCases_;
    Sawyer::Container::BiMap<TestSuiteId, TestSuite::Ptr> testSuites_;

    TestSuiteId testSuiteId_;                           // database scope is restricted to this single test suite

protected:
    Database() {}

public:
    /** Open an existing database.
     *
     *  The database's current test suite is set to the latest created test suite. It can be reset to no test suite if desired by setting
     *  the @ref testSuite property to nothing.
     *
     *  Throws an @ref Exception if the database does not exist. */
    static Ptr instance(const std::string &url);

    /** Low-level database connection. */
#if ROSE_CONCOLIC_DB_VERSION == 1
    SqlDatabase::ConnectionPtr connection() {
        return dbconn_;
    }
#else
    Sawyer::Database::Connection connection() {
        return connection_;
    }
#endif

    /** Create a new database and test suite.
     *
     *  For database management systems that support it, a new database is created, possibly overwriting any previous data if
     *  the database already existed. SQLite3 databases can be created this way because they're just files in the local
     *  filesystem, but PostgreSQL databases need to be created through the DBMS. Throws an @ref Exception if the new database
     *  could not be created.
     *
     *  Once the database is created, a new test suite with the given name is created.
     * @{
     */
    static Ptr create(const std::string &url);
    static Ptr create(const std::string &url, const std::string &testSuiteName);
    /** @} */
    //------------------------------------------------------------------------------------------------------------------------
    // Test suites
    //------------------------------------------------------------------------------------------------------------------------

    /** All test suites.
     *
     *  Returns information about all the test suites that exist in this database. This is essentially the table of contents
     *  for the database. */
    std::vector<TestSuiteId> testSuites();

    /** Property: the current test suite.
     *
     *  If the database has a current test suite, then queries are limited in scope to return results associated with that test
     *  suite.  Setting the test suite property also updates the database with information about the test suite, creating the
     *  test suite if necessary.
     *
     * @{ */
    TestSuite::Ptr testSuite();
    TestSuiteId testSuite(const TestSuite::Ptr&);
    /** @} */

    //------------------------------------------------------------------------------------------------------------------------
    // Specimens
    //------------------------------------------------------------------------------------------------------------------------

    /** All specimens.
     *
     *  If this database object has a current test suite, then the return value is limited to specimens used by that test
     *  suite, otherwise all specimens are returned. */
    std::vector<SpecimenId> specimens();

    //------------------------------------------------------------------------------------------------------------------------
    // Test cases
    //------------------------------------------------------------------------------------------------------------------------

    /** All test cases.
     *
     *  If this database object has a current test suite, then the return value is limited to test cases used by that test
     *  suite, otherwise all test cases are returned. */
    std::vector<TestCaseId> testCases();

    //------------------------------------------------------------------------------------------------------------------------
    // Overloaded methods for all objects.
    //------------------------------------------------------------------------------------------------------------------------

    /** Reconstitute a object from a database ID.
     *
     *  The association between object and ID is memoized. If @p update is yes and a memoized object is being returned, then
     *  also updates the object with the current values from the database. If the ID is invalid then an exception is thrown.
     *
     * @{ */
    TestSuite::Ptr object(TestSuiteId, Update::Flag update = Update::YES);
    TestCase::Ptr object(TestCaseId, Update::Flag update = Update::YES);
    Specimen::Ptr object(SpecimenId, Update::Flag update = Update::YES);
    /** @} */

#if ROSE_CONCOLIC_DB_VERSION == 1
    /** Reconstitute an object from a database ID as part of a subquery.
     *
     *  Thread safety: not thread safe (assumes that it is called from a thread-safe context)
     */
    Specimen::Ptr object_ns(SqlDatabase::TransactionPtr tx, SpecimenId id);
#endif

    /** Returns an ID number for an object, optionally writing to the database.
     *
     *  If the object exists in the database (i.e., returned as the result of some query) then its ID is returned and the
     *  database is optionally updated. On the other hand, if the object does not exist in the database then it will be created
     *  only if @p update is yes and its new ID is returned. If the object doesn't exist and isn't created then an invalid ID
     *  is returned.
     *
     * @{ */
    TestSuiteId id(const TestSuite::Ptr&, Update::Flag update = Update::YES);
    TestCaseId id(const TestCase::Ptr&, Update::Flag update = Update::YES);
    SpecimenId id(const Specimen::Ptr&, Update::Flag update = Update::YES);
    /** @} */

    /** Saves an object.
     *
     *  This is a more self-documenting name for calling @ref id for the sole purpose of saving (creating or updating) an
     *  object's database representation. */
    template<class ObjectPointer>
    typename ObjectTraits<typename ObjectPointer::Pointee>::Id save(const ObjectPointer &obj) {
        return id(obj);
    }

#if ROSE_CONCOLIC_DB_VERSION == 1
    /** Returns an ID number for an object, optionally writing to the database.
     *
     * The functions are executed in the context of some other transaction.
     *
     *  Thread safety: not thread safe
     */
    TestSuiteId id_ns(SqlDatabase::TransactionPtr, const TestSuite::Ptr&, Update::Flag update = Update::YES);
    TestCaseId id_ns(SqlDatabase::TransactionPtr,  const TestCase::Ptr&, Update::Flag update = Update::YES);
    SpecimenId id_ns(SqlDatabase::TransactionPtr,  const Specimen::Ptr&, Update::Flag update = Update::YES);
#endif

    /** Finds a test suite by name or ID.
     *
     *  Returns the (unique) @ref TestSuite object has the specified name. If no such test suite exists and the specified name
     *  can be parsed as an object ID (see constructors for @ref ObjectId) returns the test suite with the specified ID. If no
     *  matches are found by either mechanism then a null pointer is returned. This method is intended to be used mainly to
     *  convert command-line arguments to test suites. */
    TestSuite::Ptr findTestSuite(const std::string &nameOrId);

    /** Finds all specimens having the specified name.
     *
     *  If the database is restricted to a test suite (see @ref testSuite) then the returned specimens are only those that
     *  are part of the current test suite and have the specified name. Specimen names need not be unique or non-empty. */
    std::vector<SpecimenId> findSpecimensByName(const std::string &name);

    //------------------------------------------------------------------------------------------------------------------------
    // Cached info about disassembly. This is large data. Each specimen has zero or one associated RBA data blob.
    //------------------------------------------------------------------------------------------------------------------------

    /** Check whether a specimen has associated RBA data.
     *
     *  Returns true if the indicated specimen has associated ROSE Binary Analysis (RBA) data, and false if it doesn't. Each
     *  specimen can have zero or one associated RBA data blob. The specimen ID must be valid.
     *
     *  Thread safety: Not thread safe. */
    bool rbaExists(SpecimenId);

    /** Associate new RBA data with a specimen.
     *
     *  The ROSE Binary Analysis (RBA) data is read from the specified existing, readable file and copied into this database to
     *  be associated with the indicated specimen.  If the specimen had previous RBA data, the new data read from the file
     *  replaces the old data.  If any data cannot be copied from the file into the database then an @ref Exception is thrown
     *  and the database is not modified.  The specimen ID must be valid.
     *
     *  Thread safety: Not thread safe. */
    void saveRbaFile(const boost::filesystem::path&, SpecimenId);

    /** Extract RBA data from the database into a file.
     *
     *  The ROSE Binary Analysis (RBA) data associated with the indicated specimen is copied from the database into the
     *  specified file. The file is created if it doesn't exist, or truncated if it does exist. If the specimen does not have
     *  associated RBA data or if any data could not be copied to the file, then an @ref Exception is thrown. The specimen ID
     *  must be valid.
     *
     *  Thread safety: Not thread safe. */
    void extractRbaFile(const boost::filesystem::path&, SpecimenId);

    /** Remove any associated RBA data.
     *
     *  If the indicated specimen has ROSE Binary Analysis (RBA) data, then it is removed from the database.
     *
     *  Thread safety: Not thread safe. */
    void eraseRba(SpecimenId);

    //------------------------------------------------------------------------------------------------------------------------
    // Cached concrete execution results. This is large data. Each test case has zero or one associated concrete results.
    //------------------------------------------------------------------------------------------------------------------------

    /** Check whether a test case has concrete results.
     *
     *  Returns true if the indicated test case has concrete results. Each test case can have zero or one set of concrete
     *  results. */
    bool concreteResultExists(TestCaseId);

    /** Associate concrete results with a test case.
     *
     *  The specified concrete execution results are associated with the specified test case, replacing any previous concrete
     *  results that might have been present for the test case. If the concrete results are null, then any existing concrete
     *  results for this test case are removed.
     *
     *  The concrete results are copied by this function. The caller continues to own the pointer. */
    void saveConcreteResult(const TestCase::Ptr&, const ConcreteExecutor::Result*);

    /** Read concrete results from the database.
     *
     *  Reads concrete results from the database and returns a pointer to them. If the test case has no concrete results then a
     *  null pointer is returned. */
    std::unique_ptr<ConcreteExecutor::Result> readConcreteResult(TestCaseId);

    /** Associate TestCase w/ TestSuite.
     *
     *  Normally a test case is associated with a test suite when the test case is created in the database by virtue of the
     *  database being scoped to a current test suite.  However, this function can be used to assign the test case to a
     *  different test suite. Both IDs must be valid.
     *
     * Thread safety: thread safe
     */
   void assocTestCaseWithTestSuite(TestCaseId, TestSuiteId);

   /** Returns @p n test cases without concrete results.
    *
    * Thread safety: thread safe
    */
   std::vector<TestCaseId> needConcreteTesting(size_t n = UNLIMITED);

   /** Returns @p n test cases without concolic results.
    *
    * Thread safety: thread safe
    */
   std::vector<TestCaseId> needConcolicTesting(size_t n = UNLIMITED);

#if 0 // [Robb Matzke 2020-07-15]
    // Use saveConcreteResults instead, which allows concrete results to also be removed.
   /** Updates a test case and its results.
    *
    * @param testCase a pointer to a test case
    * @param details  a polymorphic object holding results for a concrete execution
    *
    * Thread safety: thread safe
    */
   void insertConcreteResults(const TestCase::Ptr &testCase, const ConcreteExecutor::Result& details);
#endif

   /** Tests if there are more test cases that require concrete testing.
    *
    * Thread safety: thread safe
    */
   bool hasUntested();

private:
#if ROSE_CONCOLIC_DB_VERSION == 2
    static Ptr create(const std::string &url, const Sawyer::Optional<std::string> &testSuiteName);
#endif
};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Execution manager
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Base class for managing an entire concolic testing run.
 *
 *  An @ref ExecutionManager is responsible for running an entire test suite either starting from scratch or restarting from a
 *  previous state that was saved in a database. */
class ExecutionManager: boost::noncopyable, public Sawyer::SharedObject {
public:
    /** Reference counting pointer to an @ref ExecutionManager. */
    typedef Sawyer::SharedPointer<ExecutionManager> Ptr;

private:
    Database::Ptr database_;

protected:
    // Subclasses should implement allocating constructors
    explicit ExecutionManager(const Database::Ptr &db)
        : database_(db) {
        ASSERT_not_null(db);
    }

public:
    virtual ~ExecutionManager() {}

    /** Property: Database.
     *
     *  The database used by this manager.  The database is set in the constructor and cannot be changed later. */
    Database::Ptr database() const;

    /** Next test case for concrete execution.
     *
     *  Returns up to @p n (default unlimited) test cases that need to be run concretely. A test case needs to be run
     *  concretely if it has no results from a previous concrete run.
     *
     * @{ */
    virtual std::vector<Database::TestCaseId> pendingConcreteResults(size_t n = UNLIMITED);
    Database::TestCaseId pendingConcreteResult() /*final*/;
    /** @} */

    /** Insert results of a concrete run.
     *
     *  Inserts into the database the results of a concrete run of a test case. Concrete test results always have two parts: a
     *  floating point number for ranking relative to other concrete results, and the result details.  The detailed results are
     *  user defined and stored in the database in XML format, while the rank is duplicated in a floating point field. */
    virtual void insertConcreteResults(const TestCase::Ptr&, const ConcreteExecutor::Result &details);

    /** Next test case for concolic execution.
     *
     *  Returns up to @p n (default unlimited) test cases that need to be run concolically. A test case needs to be run
     *  concolically if it is not marked as having completed the concolic run.
     *
     * @{ */
    virtual std::vector<Database::TestCaseId> pendingConcolicResults(size_t n = UNLIMITED);
    Database::TestCaseId pendingConcolicResult() /*final*/;
    /** @} */

    /** Insert results from a concolic execution.
     *
     *  When a concolic execution completes it will have produced some number of new test cases that should be inserted into
     *  the database. The subclass is reponsible for pruning the list of produced test cases by removing those that have been
     *  tested already or which wouldn't contribute any new results. */
    virtual void insertConcolicResults(const TestCase::Ptr &original, const std::vector<TestCase::Ptr> &newCases);

    /** Predicate to determine whether testing is completed.
     *
     *  Testing is done when there are no more test cases that need concrete or concolic results. */
    virtual bool isFinished() const;

    /** Start running.
     *
     *  Runs concrete and concolic executors until the application is interrupted or there's nothing left to do. Subclasses
     *  will likely reimplement this method in order to do parallel processing, limit execution time, etc. */
    virtual void run() = 0;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Example execution manager
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Concolic teting of Linux executables.
 *
 *  Tests a single Linux executable. The concrete ranking metric is only whether the executable exited with zero status or
 *  not. */
class LinuxExitStatus: public ExecutionManager {
public:
    /** Reference counting pointer to @ref LinuxExitStatus. */
    typedef Sawyer::SharedPointer<LinuxExitStatus> Ptr;

protected:
    explicit LinuxExitStatus(const Database::Ptr &db): ExecutionManager(db) {}

public:
    /** Start a new round of concolic testing.
     *
     *  Creates a new database that will hold a single new test suite for the specified executable. The single seeding test
     *  case invokes the executable with the specified arguments. The actual run is not commenced until @ref run is called. */
    static Ptr create(const std::string databaseUrl, const boost::filesystem::path &executableName,
                      const std::vector<std::string> &arguments);

    /** Resume concolic testing using the specified database.
     *
     *  If a test suite name is specified then it must exist in the database. If no test suite name is specified then the
     *  database must contain exactly one test suite which is the one that will be used. The actual run is not commenced until
     *  @ref run is called. */
    static Ptr instance(const std::string& databaseUri, const std::string &testSuiteName = "");

    virtual void run() ROSE_OVERRIDE;
};

/** prints all SQL schema statements on @ref os.
 */
void writeDBSchema(std::ostream& os);

/** prints all SQL statements on @ref os.
 */
void writeSqlStmts(std::ostream& os);


} // namespace
} // namespace
} // namespace

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
//~ BOOST_CLASS_EXPORT_GUID(LinuxExecutor::Result, "LinuxExecutor::Result")

//~ BOOST_CLASS_EXPORT_KEY(Rose::BinaryAnalysis::Concolic::ConcreteExecutor::Result)
//~ BOOST_CLASS_EXPORT_KEY(Rose::BinaryAnalysis::Concolic::LinuxExecutor::Result)

BOOST_CLASS_EXPORT_KEY2( Rose::BinaryAnalysis::Concolic::ConcreteExecutor::Result,
                         Rose::BinaryAnalysis::Concolic::tagConcreteExecutorResult
                       )
BOOST_CLASS_EXPORT_KEY2( Rose::BinaryAnalysis::Concolic::LinuxExecutor::Result,
                         Rose::BinaryAnalysis::Concolic::tagLinuxExecutorResult
                       )

BOOST_CLASS_EXPORT_KEY(Rose::BinaryAnalysis::Concolic::LinuxTraceExecutor::Result);
#endif /* ROSE_HAVE_BOOST_SERIALIZATION_LIB */

#endif
#endif

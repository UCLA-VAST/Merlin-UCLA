// MACHINE GENERATED SOURCE FILE --- DO NOT MODIFY! (Grammar.C) 


// generated file
/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNode_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNode* SgNode_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNode_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNode* SgNode_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNode* SgNode_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNode_clearMemoryPool ( );
void SgNode_extendMemoryPoolForFileIO ( );
unsigned long SgNode_initializeStorageClassArray( SgNodeStorageClass *storageArray );
void SgNode_resetValidFreepointers( );
unsigned long SgNode_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSupport_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSupport* SgSupport_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSupport_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSupport* SgSupport_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSupport* SgSupport_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSupport_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSupport_clearMemoryPool ( );
void SgSupport_extendMemoryPoolForFileIO ( );
unsigned long SgSupport_initializeStorageClassArray( SgSupportStorageClass *storageArray );
void SgSupport_resetValidFreepointers( );
unsigned long SgSupport_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModifier* SgModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModifier* SgModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModifier* SgModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModifier_clearMemoryPool ( );
void SgModifier_extendMemoryPoolForFileIO ( );
unsigned long SgModifier_initializeStorageClassArray( SgModifierStorageClass *storageArray );
void SgModifier_resetValidFreepointers( );
unsigned long SgModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModifierNodes_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModifierNodes* SgModifierNodes_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModifierNodes_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModifierNodes* SgModifierNodes_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModifierNodes* SgModifierNodes_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModifierNodes_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModifierNodes_clearMemoryPool ( );
void SgModifierNodes_extendMemoryPoolForFileIO ( );
unsigned long SgModifierNodes_initializeStorageClassArray( SgModifierNodesStorageClass *storageArray );
void SgModifierNodes_resetValidFreepointers( );
unsigned long SgModifierNodes_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgConstVolatileModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgConstVolatileModifier* SgConstVolatileModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgConstVolatileModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgConstVolatileModifier* SgConstVolatileModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgConstVolatileModifier* SgConstVolatileModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgConstVolatileModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgConstVolatileModifier_clearMemoryPool ( );
void SgConstVolatileModifier_extendMemoryPoolForFileIO ( );
unsigned long SgConstVolatileModifier_initializeStorageClassArray( SgConstVolatileModifierStorageClass *storageArray );
void SgConstVolatileModifier_resetValidFreepointers( );
unsigned long SgConstVolatileModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStorageModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStorageModifier* SgStorageModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStorageModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStorageModifier* SgStorageModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStorageModifier* SgStorageModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStorageModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStorageModifier_clearMemoryPool ( );
void SgStorageModifier_extendMemoryPoolForFileIO ( );
unsigned long SgStorageModifier_initializeStorageClassArray( SgStorageModifierStorageClass *storageArray );
void SgStorageModifier_resetValidFreepointers( );
unsigned long SgStorageModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAccessModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAccessModifier* SgAccessModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAccessModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAccessModifier* SgAccessModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAccessModifier* SgAccessModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAccessModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAccessModifier_clearMemoryPool ( );
void SgAccessModifier_extendMemoryPoolForFileIO ( );
unsigned long SgAccessModifier_initializeStorageClassArray( SgAccessModifierStorageClass *storageArray );
void SgAccessModifier_resetValidFreepointers( );
unsigned long SgAccessModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionModifier* SgFunctionModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionModifier* SgFunctionModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionModifier* SgFunctionModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionModifier_clearMemoryPool ( );
void SgFunctionModifier_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionModifier_initializeStorageClassArray( SgFunctionModifierStorageClass *storageArray );
void SgFunctionModifier_resetValidFreepointers( );
unsigned long SgFunctionModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUPC_AccessModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUPC_AccessModifier* SgUPC_AccessModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUPC_AccessModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUPC_AccessModifier* SgUPC_AccessModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUPC_AccessModifier* SgUPC_AccessModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUPC_AccessModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUPC_AccessModifier_clearMemoryPool ( );
void SgUPC_AccessModifier_extendMemoryPoolForFileIO ( );
unsigned long SgUPC_AccessModifier_initializeStorageClassArray( SgUPC_AccessModifierStorageClass *storageArray );
void SgUPC_AccessModifier_resetValidFreepointers( );
unsigned long SgUPC_AccessModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSpecialFunctionModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSpecialFunctionModifier* SgSpecialFunctionModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSpecialFunctionModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSpecialFunctionModifier* SgSpecialFunctionModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSpecialFunctionModifier* SgSpecialFunctionModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSpecialFunctionModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSpecialFunctionModifier_clearMemoryPool ( );
void SgSpecialFunctionModifier_extendMemoryPoolForFileIO ( );
unsigned long SgSpecialFunctionModifier_initializeStorageClassArray( SgSpecialFunctionModifierStorageClass *storageArray );
void SgSpecialFunctionModifier_resetValidFreepointers( );
unsigned long SgSpecialFunctionModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElaboratedTypeModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElaboratedTypeModifier* SgElaboratedTypeModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElaboratedTypeModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElaboratedTypeModifier* SgElaboratedTypeModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElaboratedTypeModifier* SgElaboratedTypeModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElaboratedTypeModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElaboratedTypeModifier_clearMemoryPool ( );
void SgElaboratedTypeModifier_extendMemoryPoolForFileIO ( );
unsigned long SgElaboratedTypeModifier_initializeStorageClassArray( SgElaboratedTypeModifierStorageClass *storageArray );
void SgElaboratedTypeModifier_resetValidFreepointers( );
unsigned long SgElaboratedTypeModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLinkageModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLinkageModifier* SgLinkageModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLinkageModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLinkageModifier* SgLinkageModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLinkageModifier* SgLinkageModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLinkageModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLinkageModifier_clearMemoryPool ( );
void SgLinkageModifier_extendMemoryPoolForFileIO ( );
unsigned long SgLinkageModifier_initializeStorageClassArray( SgLinkageModifierStorageClass *storageArray );
void SgLinkageModifier_resetValidFreepointers( );
unsigned long SgLinkageModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBaseClassModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBaseClassModifier* SgBaseClassModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBaseClassModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBaseClassModifier* SgBaseClassModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBaseClassModifier* SgBaseClassModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBaseClassModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBaseClassModifier_clearMemoryPool ( );
void SgBaseClassModifier_extendMemoryPoolForFileIO ( );
unsigned long SgBaseClassModifier_initializeStorageClassArray( SgBaseClassModifierStorageClass *storageArray );
void SgBaseClassModifier_resetValidFreepointers( );
unsigned long SgBaseClassModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStructureModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStructureModifier* SgStructureModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStructureModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStructureModifier* SgStructureModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStructureModifier* SgStructureModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStructureModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStructureModifier_clearMemoryPool ( );
void SgStructureModifier_extendMemoryPoolForFileIO ( );
unsigned long SgStructureModifier_initializeStorageClassArray( SgStructureModifierStorageClass *storageArray );
void SgStructureModifier_resetValidFreepointers( );
unsigned long SgStructureModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeModifier* SgTypeModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeModifier* SgTypeModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeModifier* SgTypeModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeModifier_clearMemoryPool ( );
void SgTypeModifier_extendMemoryPoolForFileIO ( );
unsigned long SgTypeModifier_initializeStorageClassArray( SgTypeModifierStorageClass *storageArray );
void SgTypeModifier_resetValidFreepointers( );
unsigned long SgTypeModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeclarationModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeclarationModifier* SgDeclarationModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeclarationModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeclarationModifier* SgDeclarationModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeclarationModifier* SgDeclarationModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeclarationModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeclarationModifier_clearMemoryPool ( );
void SgDeclarationModifier_extendMemoryPoolForFileIO ( );
unsigned long SgDeclarationModifier_initializeStorageClassArray( SgDeclarationModifierStorageClass *storageArray );
void SgDeclarationModifier_resetValidFreepointers( );
unsigned long SgDeclarationModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOpenclAccessModeModifier_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOpenclAccessModeModifier* SgOpenclAccessModeModifier_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOpenclAccessModeModifier_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOpenclAccessModeModifier* SgOpenclAccessModeModifier_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOpenclAccessModeModifier* SgOpenclAccessModeModifier_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOpenclAccessModeModifier_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOpenclAccessModeModifier_clearMemoryPool ( );
void SgOpenclAccessModeModifier_extendMemoryPoolForFileIO ( );
unsigned long SgOpenclAccessModeModifier_initializeStorageClassArray( SgOpenclAccessModeModifierStorageClass *storageArray );
void SgOpenclAccessModeModifier_resetValidFreepointers( );
unsigned long SgOpenclAccessModeModifier_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgName_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgName* SgName_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgName_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgName* SgName_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgName* SgName_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgName_clearMemoryPool ( );
void SgName_extendMemoryPoolForFileIO ( );
unsigned long SgName_initializeStorageClassArray( SgNameStorageClass *storageArray );
void SgName_resetValidFreepointers( );
unsigned long SgName_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSymbolTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSymbolTable* SgSymbolTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSymbolTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSymbolTable* SgSymbolTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSymbolTable* SgSymbolTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSymbolTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSymbolTable_clearMemoryPool ( );
void SgSymbolTable_extendMemoryPoolForFileIO ( );
unsigned long SgSymbolTable_initializeStorageClassArray( SgSymbolTableStorageClass *storageArray );
void SgSymbolTable_resetValidFreepointers( );
unsigned long SgSymbolTable_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAttribute_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAttribute* SgAttribute_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAttribute_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAttribute* SgAttribute_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAttribute* SgAttribute_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAttribute_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAttribute_clearMemoryPool ( );
void SgAttribute_extendMemoryPoolForFileIO ( );
unsigned long SgAttribute_initializeStorageClassArray( SgAttributeStorageClass *storageArray );
void SgAttribute_resetValidFreepointers( );
unsigned long SgAttribute_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPragma_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPragma* SgPragma_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPragma_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPragma* SgPragma_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPragma* SgPragma_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPragma_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPragma_clearMemoryPool ( );
void SgPragma_extendMemoryPoolForFileIO ( );
unsigned long SgPragma_initializeStorageClassArray( SgPragmaStorageClass *storageArray );
void SgPragma_resetValidFreepointers( );
unsigned long SgPragma_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitAttribute_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitAttribute* SgBitAttribute_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitAttribute_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitAttribute* SgBitAttribute_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitAttribute* SgBitAttribute_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitAttribute_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitAttribute_clearMemoryPool ( );
void SgBitAttribute_extendMemoryPoolForFileIO ( );
unsigned long SgBitAttribute_initializeStorageClassArray( SgBitAttributeStorageClass *storageArray );
void SgBitAttribute_resetValidFreepointers( );
unsigned long SgBitAttribute_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFuncDecl_attr_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFuncDecl_attr* SgFuncDecl_attr_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFuncDecl_attr_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFuncDecl_attr* SgFuncDecl_attr_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFuncDecl_attr* SgFuncDecl_attr_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFuncDecl_attr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFuncDecl_attr_clearMemoryPool ( );
void SgFuncDecl_attr_extendMemoryPoolForFileIO ( );
unsigned long SgFuncDecl_attr_initializeStorageClassArray( SgFuncDecl_attrStorageClass *storageArray );
void SgFuncDecl_attr_resetValidFreepointers( );
unsigned long SgFuncDecl_attr_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassDecl_attr_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassDecl_attr* SgClassDecl_attr_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassDecl_attr_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassDecl_attr* SgClassDecl_attr_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassDecl_attr* SgClassDecl_attr_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassDecl_attr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassDecl_attr_clearMemoryPool ( );
void SgClassDecl_attr_extendMemoryPoolForFileIO ( );
unsigned long SgClassDecl_attr_initializeStorageClassArray( SgClassDecl_attrStorageClass *storageArray );
void SgClassDecl_attr_resetValidFreepointers( );
unsigned long SgClassDecl_attr_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int Sg_File_Info_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern Sg_File_Info* Sg_File_Info_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > Sg_File_Info_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
Sg_File_Info* Sg_File_Info_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
Sg_File_Info* Sg_File_Info_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long Sg_File_Info_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void Sg_File_Info_clearMemoryPool ( );
void Sg_File_Info_extendMemoryPoolForFileIO ( );
unsigned long Sg_File_Info_initializeStorageClassArray( Sg_File_InfoStorageClass *storageArray );
void Sg_File_Info_resetValidFreepointers( );
unsigned long Sg_File_Info_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFile_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFile* SgFile_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFile_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFile* SgFile_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFile* SgFile_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFile_clearMemoryPool ( );
void SgFile_extendMemoryPoolForFileIO ( );
unsigned long SgFile_initializeStorageClassArray( SgFileStorageClass *storageArray );
void SgFile_resetValidFreepointers( );
unsigned long SgFile_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSourceFile_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSourceFile* SgSourceFile_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSourceFile_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSourceFile* SgSourceFile_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSourceFile* SgSourceFile_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSourceFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSourceFile_clearMemoryPool ( );
void SgSourceFile_extendMemoryPoolForFileIO ( );
unsigned long SgSourceFile_initializeStorageClassArray( SgSourceFileStorageClass *storageArray );
void SgSourceFile_resetValidFreepointers( );
unsigned long SgSourceFile_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnknownFile_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnknownFile* SgUnknownFile_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnknownFile_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnknownFile* SgUnknownFile_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnknownFile* SgUnknownFile_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnknownFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnknownFile_clearMemoryPool ( );
void SgUnknownFile_extendMemoryPoolForFileIO ( );
unsigned long SgUnknownFile_initializeStorageClassArray( SgUnknownFileStorageClass *storageArray );
void SgUnknownFile_resetValidFreepointers( );
unsigned long SgUnknownFile_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgProject_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgProject* SgProject_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgProject_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgProject* SgProject_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgProject* SgProject_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgProject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgProject_clearMemoryPool ( );
void SgProject_extendMemoryPoolForFileIO ( );
unsigned long SgProject_initializeStorageClassArray( SgProjectStorageClass *storageArray );
void SgProject_resetValidFreepointers( );
unsigned long SgProject_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOptions_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOptions* SgOptions_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOptions_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOptions* SgOptions_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOptions* SgOptions_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOptions_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOptions_clearMemoryPool ( );
void SgOptions_extendMemoryPoolForFileIO ( );
unsigned long SgOptions_initializeStorageClassArray( SgOptionsStorageClass *storageArray );
void SgOptions_resetValidFreepointers( );
unsigned long SgOptions_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnparse_Info_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnparse_Info* SgUnparse_Info_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnparse_Info_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnparse_Info* SgUnparse_Info_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnparse_Info* SgUnparse_Info_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnparse_Info_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnparse_Info_clearMemoryPool ( );
void SgUnparse_Info_extendMemoryPoolForFileIO ( );
unsigned long SgUnparse_Info_initializeStorageClassArray( SgUnparse_InfoStorageClass *storageArray );
void SgUnparse_Info_resetValidFreepointers( );
unsigned long SgUnparse_Info_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBaseClass_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBaseClass* SgBaseClass_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBaseClass_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBaseClass* SgBaseClass_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBaseClass* SgBaseClass_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBaseClass_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBaseClass_clearMemoryPool ( );
void SgBaseClass_extendMemoryPoolForFileIO ( );
unsigned long SgBaseClass_initializeStorageClassArray( SgBaseClassStorageClass *storageArray );
void SgBaseClass_resetValidFreepointers( );
unsigned long SgBaseClass_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExpBaseClass_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExpBaseClass* SgExpBaseClass_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExpBaseClass_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExpBaseClass* SgExpBaseClass_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExpBaseClass* SgExpBaseClass_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExpBaseClass_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExpBaseClass_clearMemoryPool ( );
void SgExpBaseClass_extendMemoryPoolForFileIO ( );
unsigned long SgExpBaseClass_initializeStorageClassArray( SgExpBaseClassStorageClass *storageArray );
void SgExpBaseClass_resetValidFreepointers( );
unsigned long SgExpBaseClass_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNonrealBaseClass_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNonrealBaseClass* SgNonrealBaseClass_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNonrealBaseClass_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNonrealBaseClass* SgNonrealBaseClass_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNonrealBaseClass* SgNonrealBaseClass_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNonrealBaseClass_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNonrealBaseClass_clearMemoryPool ( );
void SgNonrealBaseClass_extendMemoryPoolForFileIO ( );
unsigned long SgNonrealBaseClass_initializeStorageClassArray( SgNonrealBaseClassStorageClass *storageArray );
void SgNonrealBaseClass_resetValidFreepointers( );
unsigned long SgNonrealBaseClass_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypedefSeq_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypedefSeq* SgTypedefSeq_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypedefSeq_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypedefSeq* SgTypedefSeq_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypedefSeq* SgTypedefSeq_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypedefSeq_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypedefSeq_clearMemoryPool ( );
void SgTypedefSeq_extendMemoryPoolForFileIO ( );
unsigned long SgTypedefSeq_initializeStorageClassArray( SgTypedefSeqStorageClass *storageArray );
void SgTypedefSeq_resetValidFreepointers( );
unsigned long SgTypedefSeq_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateParameter_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateParameter* SgTemplateParameter_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateParameter_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateParameter* SgTemplateParameter_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateParameter* SgTemplateParameter_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateParameter_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateParameter_clearMemoryPool ( );
void SgTemplateParameter_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateParameter_initializeStorageClassArray( SgTemplateParameterStorageClass *storageArray );
void SgTemplateParameter_resetValidFreepointers( );
unsigned long SgTemplateParameter_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateArgument_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateArgument* SgTemplateArgument_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateArgument_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateArgument* SgTemplateArgument_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateArgument* SgTemplateArgument_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateArgument_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateArgument_clearMemoryPool ( );
void SgTemplateArgument_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateArgument_initializeStorageClassArray( SgTemplateArgumentStorageClass *storageArray );
void SgTemplateArgument_resetValidFreepointers( );
unsigned long SgTemplateArgument_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDirectory_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDirectory* SgDirectory_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDirectory_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDirectory* SgDirectory_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDirectory* SgDirectory_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDirectory_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDirectory_clearMemoryPool ( );
void SgDirectory_extendMemoryPoolForFileIO ( );
unsigned long SgDirectory_initializeStorageClassArray( SgDirectoryStorageClass *storageArray );
void SgDirectory_resetValidFreepointers( );
unsigned long SgDirectory_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFileList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFileList* SgFileList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFileList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFileList* SgFileList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFileList* SgFileList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFileList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFileList_clearMemoryPool ( );
void SgFileList_extendMemoryPoolForFileIO ( );
unsigned long SgFileList_initializeStorageClassArray( SgFileListStorageClass *storageArray );
void SgFileList_resetValidFreepointers( );
unsigned long SgFileList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDirectoryList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDirectoryList* SgDirectoryList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDirectoryList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDirectoryList* SgDirectoryList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDirectoryList* SgDirectoryList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDirectoryList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDirectoryList_clearMemoryPool ( );
void SgDirectoryList_extendMemoryPoolForFileIO ( );
unsigned long SgDirectoryList_initializeStorageClassArray( SgDirectoryListStorageClass *storageArray );
void SgDirectoryList_resetValidFreepointers( );
unsigned long SgDirectoryList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionParameterTypeList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionParameterTypeList* SgFunctionParameterTypeList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionParameterTypeList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionParameterTypeList* SgFunctionParameterTypeList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionParameterTypeList* SgFunctionParameterTypeList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionParameterTypeList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionParameterTypeList_clearMemoryPool ( );
void SgFunctionParameterTypeList_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionParameterTypeList_initializeStorageClassArray( SgFunctionParameterTypeListStorageClass *storageArray );
void SgFunctionParameterTypeList_resetValidFreepointers( );
unsigned long SgFunctionParameterTypeList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgQualifiedName_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgQualifiedName* SgQualifiedName_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgQualifiedName_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgQualifiedName* SgQualifiedName_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgQualifiedName* SgQualifiedName_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgQualifiedName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgQualifiedName_clearMemoryPool ( );
void SgQualifiedName_extendMemoryPoolForFileIO ( );
unsigned long SgQualifiedName_initializeStorageClassArray( SgQualifiedNameStorageClass *storageArray );
void SgQualifiedName_resetValidFreepointers( );
unsigned long SgQualifiedName_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateArgumentList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateArgumentList* SgTemplateArgumentList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateArgumentList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateArgumentList* SgTemplateArgumentList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateArgumentList* SgTemplateArgumentList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateArgumentList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateArgumentList_clearMemoryPool ( );
void SgTemplateArgumentList_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateArgumentList_initializeStorageClassArray( SgTemplateArgumentListStorageClass *storageArray );
void SgTemplateArgumentList_resetValidFreepointers( );
unsigned long SgTemplateArgumentList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateParameterList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateParameterList* SgTemplateParameterList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateParameterList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateParameterList* SgTemplateParameterList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateParameterList* SgTemplateParameterList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateParameterList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateParameterList_clearMemoryPool ( );
void SgTemplateParameterList_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateParameterList_initializeStorageClassArray( SgTemplateParameterListStorageClass *storageArray );
void SgTemplateParameterList_resetValidFreepointers( );
unsigned long SgTemplateParameterList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaTypeConstraint_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaTypeConstraint* SgAdaTypeConstraint_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaTypeConstraint_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaTypeConstraint* SgAdaTypeConstraint_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaTypeConstraint* SgAdaTypeConstraint_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaTypeConstraint_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaTypeConstraint_clearMemoryPool ( );
void SgAdaTypeConstraint_extendMemoryPoolForFileIO ( );
unsigned long SgAdaTypeConstraint_initializeStorageClassArray( SgAdaTypeConstraintStorageClass *storageArray );
void SgAdaTypeConstraint_resetValidFreepointers( );
unsigned long SgAdaTypeConstraint_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaRangeConstraint_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaRangeConstraint* SgAdaRangeConstraint_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaRangeConstraint_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaRangeConstraint* SgAdaRangeConstraint_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaRangeConstraint* SgAdaRangeConstraint_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaRangeConstraint_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaRangeConstraint_clearMemoryPool ( );
void SgAdaRangeConstraint_extendMemoryPoolForFileIO ( );
unsigned long SgAdaRangeConstraint_initializeStorageClassArray( SgAdaRangeConstraintStorageClass *storageArray );
void SgAdaRangeConstraint_resetValidFreepointers( );
unsigned long SgAdaRangeConstraint_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGraph* SgGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGraph* SgGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGraph* SgGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGraph_clearMemoryPool ( );
void SgGraph_extendMemoryPoolForFileIO ( );
unsigned long SgGraph_initializeStorageClassArray( SgGraphStorageClass *storageArray );
void SgGraph_resetValidFreepointers( );
unsigned long SgGraph_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIncidenceDirectedGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIncidenceDirectedGraph* SgIncidenceDirectedGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIncidenceDirectedGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIncidenceDirectedGraph* SgIncidenceDirectedGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIncidenceDirectedGraph* SgIncidenceDirectedGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIncidenceDirectedGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIncidenceDirectedGraph_clearMemoryPool ( );
void SgIncidenceDirectedGraph_extendMemoryPoolForFileIO ( );
unsigned long SgIncidenceDirectedGraph_initializeStorageClassArray( SgIncidenceDirectedGraphStorageClass *storageArray );
void SgIncidenceDirectedGraph_resetValidFreepointers( );
unsigned long SgIncidenceDirectedGraph_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBidirectionalGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBidirectionalGraph* SgBidirectionalGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBidirectionalGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBidirectionalGraph* SgBidirectionalGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBidirectionalGraph* SgBidirectionalGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBidirectionalGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBidirectionalGraph_clearMemoryPool ( );
void SgBidirectionalGraph_extendMemoryPoolForFileIO ( );
unsigned long SgBidirectionalGraph_initializeStorageClassArray( SgBidirectionalGraphStorageClass *storageArray );
void SgBidirectionalGraph_resetValidFreepointers( );
unsigned long SgBidirectionalGraph_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStringKeyedBidirectionalGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStringKeyedBidirectionalGraph* SgStringKeyedBidirectionalGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStringKeyedBidirectionalGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStringKeyedBidirectionalGraph* SgStringKeyedBidirectionalGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStringKeyedBidirectionalGraph* SgStringKeyedBidirectionalGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStringKeyedBidirectionalGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStringKeyedBidirectionalGraph_clearMemoryPool ( );
void SgStringKeyedBidirectionalGraph_extendMemoryPoolForFileIO ( );
unsigned long SgStringKeyedBidirectionalGraph_initializeStorageClassArray( SgStringKeyedBidirectionalGraphStorageClass *storageArray );
void SgStringKeyedBidirectionalGraph_resetValidFreepointers( );
unsigned long SgStringKeyedBidirectionalGraph_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIntKeyedBidirectionalGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIntKeyedBidirectionalGraph* SgIntKeyedBidirectionalGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIntKeyedBidirectionalGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIntKeyedBidirectionalGraph* SgIntKeyedBidirectionalGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIntKeyedBidirectionalGraph* SgIntKeyedBidirectionalGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIntKeyedBidirectionalGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIntKeyedBidirectionalGraph_clearMemoryPool ( );
void SgIntKeyedBidirectionalGraph_extendMemoryPoolForFileIO ( );
unsigned long SgIntKeyedBidirectionalGraph_initializeStorageClassArray( SgIntKeyedBidirectionalGraphStorageClass *storageArray );
void SgIntKeyedBidirectionalGraph_resetValidFreepointers( );
unsigned long SgIntKeyedBidirectionalGraph_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIncidenceUndirectedGraph_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIncidenceUndirectedGraph* SgIncidenceUndirectedGraph_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIncidenceUndirectedGraph_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIncidenceUndirectedGraph* SgIncidenceUndirectedGraph_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIncidenceUndirectedGraph* SgIncidenceUndirectedGraph_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIncidenceUndirectedGraph_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIncidenceUndirectedGraph_clearMemoryPool ( );
void SgIncidenceUndirectedGraph_extendMemoryPoolForFileIO ( );
unsigned long SgIncidenceUndirectedGraph_initializeStorageClassArray( SgIncidenceUndirectedGraphStorageClass *storageArray );
void SgIncidenceUndirectedGraph_resetValidFreepointers( );
unsigned long SgIncidenceUndirectedGraph_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGraphNode_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGraphNode* SgGraphNode_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGraphNode_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGraphNode* SgGraphNode_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGraphNode* SgGraphNode_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGraphNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGraphNode_clearMemoryPool ( );
void SgGraphNode_extendMemoryPoolForFileIO ( );
unsigned long SgGraphNode_initializeStorageClassArray( SgGraphNodeStorageClass *storageArray );
void SgGraphNode_resetValidFreepointers( );
unsigned long SgGraphNode_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGraphEdge_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGraphEdge* SgGraphEdge_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGraphEdge_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGraphEdge* SgGraphEdge_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGraphEdge* SgGraphEdge_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGraphEdge_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGraphEdge_clearMemoryPool ( );
void SgGraphEdge_extendMemoryPoolForFileIO ( );
unsigned long SgGraphEdge_initializeStorageClassArray( SgGraphEdgeStorageClass *storageArray );
void SgGraphEdge_resetValidFreepointers( );
unsigned long SgGraphEdge_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDirectedGraphEdge_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDirectedGraphEdge* SgDirectedGraphEdge_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDirectedGraphEdge_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDirectedGraphEdge* SgDirectedGraphEdge_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDirectedGraphEdge* SgDirectedGraphEdge_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDirectedGraphEdge_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDirectedGraphEdge_clearMemoryPool ( );
void SgDirectedGraphEdge_extendMemoryPoolForFileIO ( );
unsigned long SgDirectedGraphEdge_initializeStorageClassArray( SgDirectedGraphEdgeStorageClass *storageArray );
void SgDirectedGraphEdge_resetValidFreepointers( );
unsigned long SgDirectedGraphEdge_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUndirectedGraphEdge_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUndirectedGraphEdge* SgUndirectedGraphEdge_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUndirectedGraphEdge_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUndirectedGraphEdge* SgUndirectedGraphEdge_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUndirectedGraphEdge* SgUndirectedGraphEdge_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUndirectedGraphEdge_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUndirectedGraphEdge_clearMemoryPool ( );
void SgUndirectedGraphEdge_extendMemoryPoolForFileIO ( );
unsigned long SgUndirectedGraphEdge_initializeStorageClassArray( SgUndirectedGraphEdgeStorageClass *storageArray );
void SgUndirectedGraphEdge_resetValidFreepointers( );
unsigned long SgUndirectedGraphEdge_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGraphNodeList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGraphNodeList* SgGraphNodeList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGraphNodeList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGraphNodeList* SgGraphNodeList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGraphNodeList* SgGraphNodeList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGraphNodeList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGraphNodeList_clearMemoryPool ( );
void SgGraphNodeList_extendMemoryPoolForFileIO ( );
unsigned long SgGraphNodeList_initializeStorageClassArray( SgGraphNodeListStorageClass *storageArray );
void SgGraphNodeList_resetValidFreepointers( );
unsigned long SgGraphNodeList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGraphEdgeList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGraphEdgeList* SgGraphEdgeList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGraphEdgeList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGraphEdgeList* SgGraphEdgeList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGraphEdgeList* SgGraphEdgeList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGraphEdgeList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGraphEdgeList_clearMemoryPool ( );
void SgGraphEdgeList_extendMemoryPoolForFileIO ( );
unsigned long SgGraphEdgeList_initializeStorageClassArray( SgGraphEdgeListStorageClass *storageArray );
void SgGraphEdgeList_resetValidFreepointers( );
unsigned long SgGraphEdgeList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeTable* SgTypeTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeTable* SgTypeTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeTable* SgTypeTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeTable_clearMemoryPool ( );
void SgTypeTable_extendMemoryPoolForFileIO ( );
unsigned long SgTypeTable_initializeStorageClassArray( SgTypeTableStorageClass *storageArray );
void SgTypeTable_resetValidFreepointers( );
unsigned long SgTypeTable_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNameGroup_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNameGroup* SgNameGroup_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNameGroup_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNameGroup* SgNameGroup_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNameGroup* SgNameGroup_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNameGroup_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNameGroup_clearMemoryPool ( );
void SgNameGroup_extendMemoryPoolForFileIO ( );
unsigned long SgNameGroup_initializeStorageClassArray( SgNameGroupStorageClass *storageArray );
void SgNameGroup_resetValidFreepointers( );
unsigned long SgNameGroup_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDimensionObject_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDimensionObject* SgDimensionObject_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDimensionObject_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDimensionObject* SgDimensionObject_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDimensionObject* SgDimensionObject_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDimensionObject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDimensionObject_clearMemoryPool ( );
void SgDimensionObject_extendMemoryPoolForFileIO ( );
unsigned long SgDimensionObject_initializeStorageClassArray( SgDimensionObjectStorageClass *storageArray );
void SgDimensionObject_resetValidFreepointers( );
unsigned long SgDimensionObject_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFormatItem_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFormatItem* SgFormatItem_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFormatItem_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFormatItem* SgFormatItem_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFormatItem* SgFormatItem_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFormatItem_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFormatItem_clearMemoryPool ( );
void SgFormatItem_extendMemoryPoolForFileIO ( );
unsigned long SgFormatItem_initializeStorageClassArray( SgFormatItemStorageClass *storageArray );
void SgFormatItem_resetValidFreepointers( );
unsigned long SgFormatItem_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFormatItemList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFormatItemList* SgFormatItemList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFormatItemList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFormatItemList* SgFormatItemList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFormatItemList* SgFormatItemList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFormatItemList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFormatItemList_clearMemoryPool ( );
void SgFormatItemList_extendMemoryPoolForFileIO ( );
unsigned long SgFormatItemList_initializeStorageClassArray( SgFormatItemListStorageClass *storageArray );
void SgFormatItemList_resetValidFreepointers( );
unsigned long SgFormatItemList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDataStatementGroup_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDataStatementGroup* SgDataStatementGroup_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDataStatementGroup_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDataStatementGroup* SgDataStatementGroup_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDataStatementGroup* SgDataStatementGroup_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDataStatementGroup_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDataStatementGroup_clearMemoryPool ( );
void SgDataStatementGroup_extendMemoryPoolForFileIO ( );
unsigned long SgDataStatementGroup_initializeStorageClassArray( SgDataStatementGroupStorageClass *storageArray );
void SgDataStatementGroup_resetValidFreepointers( );
unsigned long SgDataStatementGroup_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDataStatementObject_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDataStatementObject* SgDataStatementObject_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDataStatementObject_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDataStatementObject* SgDataStatementObject_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDataStatementObject* SgDataStatementObject_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDataStatementObject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDataStatementObject_clearMemoryPool ( );
void SgDataStatementObject_extendMemoryPoolForFileIO ( );
unsigned long SgDataStatementObject_initializeStorageClassArray( SgDataStatementObjectStorageClass *storageArray );
void SgDataStatementObject_resetValidFreepointers( );
unsigned long SgDataStatementObject_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIncludeFile_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIncludeFile* SgIncludeFile_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIncludeFile_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIncludeFile* SgIncludeFile_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIncludeFile* SgIncludeFile_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIncludeFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIncludeFile_clearMemoryPool ( );
void SgIncludeFile_extendMemoryPoolForFileIO ( );
unsigned long SgIncludeFile_initializeStorageClassArray( SgIncludeFileStorageClass *storageArray );
void SgIncludeFile_resetValidFreepointers( );
unsigned long SgIncludeFile_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDataStatementValue_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDataStatementValue* SgDataStatementValue_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDataStatementValue_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDataStatementValue* SgDataStatementValue_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDataStatementValue* SgDataStatementValue_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDataStatementValue_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDataStatementValue_clearMemoryPool ( );
void SgDataStatementValue_extendMemoryPoolForFileIO ( );
unsigned long SgDataStatementValue_initializeStorageClassArray( SgDataStatementValueStorageClass *storageArray );
void SgDataStatementValue_resetValidFreepointers( );
unsigned long SgDataStatementValue_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaImportStatementList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaImportStatementList* SgJavaImportStatementList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaImportStatementList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaImportStatementList* SgJavaImportStatementList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaImportStatementList* SgJavaImportStatementList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaImportStatementList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaImportStatementList_clearMemoryPool ( );
void SgJavaImportStatementList_extendMemoryPoolForFileIO ( );
unsigned long SgJavaImportStatementList_initializeStorageClassArray( SgJavaImportStatementListStorageClass *storageArray );
void SgJavaImportStatementList_resetValidFreepointers( );
unsigned long SgJavaImportStatementList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaClassDeclarationList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaClassDeclarationList* SgJavaClassDeclarationList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaClassDeclarationList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaClassDeclarationList* SgJavaClassDeclarationList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaClassDeclarationList* SgJavaClassDeclarationList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaClassDeclarationList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaClassDeclarationList_clearMemoryPool ( );
void SgJavaClassDeclarationList_extendMemoryPoolForFileIO ( );
unsigned long SgJavaClassDeclarationList_initializeStorageClassArray( SgJavaClassDeclarationListStorageClass *storageArray );
void SgJavaClassDeclarationList_resetValidFreepointers( );
unsigned long SgJavaClassDeclarationList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgHeaderFileReport_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgHeaderFileReport* SgHeaderFileReport_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgHeaderFileReport_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgHeaderFileReport* SgHeaderFileReport_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgHeaderFileReport* SgHeaderFileReport_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgHeaderFileReport_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgHeaderFileReport_clearMemoryPool ( );
void SgHeaderFileReport_extendMemoryPoolForFileIO ( );
unsigned long SgHeaderFileReport_initializeStorageClassArray( SgHeaderFileReportStorageClass *storageArray );
void SgHeaderFileReport_resetValidFreepointers( );
unsigned long SgHeaderFileReport_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgType* SgType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgType* SgType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgType* SgType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgType_clearMemoryPool ( );
void SgType_extendMemoryPoolForFileIO ( );
unsigned long SgType_initializeStorageClassArray( SgTypeStorageClass *storageArray );
void SgType_resetValidFreepointers( );
unsigned long SgType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnknown_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnknown* SgTypeUnknown_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnknown_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnknown* SgTypeUnknown_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnknown* SgTypeUnknown_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnknown_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnknown_clearMemoryPool ( );
void SgTypeUnknown_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnknown_initializeStorageClassArray( SgTypeUnknownStorageClass *storageArray );
void SgTypeUnknown_resetValidFreepointers( );
unsigned long SgTypeUnknown_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeChar_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeChar* SgTypeChar_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeChar_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeChar* SgTypeChar_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeChar* SgTypeChar_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeChar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeChar_clearMemoryPool ( );
void SgTypeChar_extendMemoryPoolForFileIO ( );
unsigned long SgTypeChar_initializeStorageClassArray( SgTypeCharStorageClass *storageArray );
void SgTypeChar_resetValidFreepointers( );
unsigned long SgTypeChar_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSignedChar_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSignedChar* SgTypeSignedChar_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSignedChar_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSignedChar* SgTypeSignedChar_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSignedChar* SgTypeSignedChar_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSignedChar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSignedChar_clearMemoryPool ( );
void SgTypeSignedChar_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSignedChar_initializeStorageClassArray( SgTypeSignedCharStorageClass *storageArray );
void SgTypeSignedChar_resetValidFreepointers( );
unsigned long SgTypeSignedChar_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsignedChar_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsignedChar* SgTypeUnsignedChar_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsignedChar_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsignedChar* SgTypeUnsignedChar_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsignedChar* SgTypeUnsignedChar_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsignedChar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsignedChar_clearMemoryPool ( );
void SgTypeUnsignedChar_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsignedChar_initializeStorageClassArray( SgTypeUnsignedCharStorageClass *storageArray );
void SgTypeUnsignedChar_resetValidFreepointers( );
unsigned long SgTypeUnsignedChar_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeShort_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeShort* SgTypeShort_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeShort_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeShort* SgTypeShort_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeShort* SgTypeShort_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeShort_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeShort_clearMemoryPool ( );
void SgTypeShort_extendMemoryPoolForFileIO ( );
unsigned long SgTypeShort_initializeStorageClassArray( SgTypeShortStorageClass *storageArray );
void SgTypeShort_resetValidFreepointers( );
unsigned long SgTypeShort_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSignedShort_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSignedShort* SgTypeSignedShort_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSignedShort_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSignedShort* SgTypeSignedShort_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSignedShort* SgTypeSignedShort_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSignedShort_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSignedShort_clearMemoryPool ( );
void SgTypeSignedShort_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSignedShort_initializeStorageClassArray( SgTypeSignedShortStorageClass *storageArray );
void SgTypeSignedShort_resetValidFreepointers( );
unsigned long SgTypeSignedShort_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsignedShort_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsignedShort* SgTypeUnsignedShort_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsignedShort_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsignedShort* SgTypeUnsignedShort_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsignedShort* SgTypeUnsignedShort_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsignedShort_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsignedShort_clearMemoryPool ( );
void SgTypeUnsignedShort_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsignedShort_initializeStorageClassArray( SgTypeUnsignedShortStorageClass *storageArray );
void SgTypeUnsignedShort_resetValidFreepointers( );
unsigned long SgTypeUnsignedShort_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeInt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeInt* SgTypeInt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeInt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeInt* SgTypeInt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeInt* SgTypeInt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeInt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeInt_clearMemoryPool ( );
void SgTypeInt_extendMemoryPoolForFileIO ( );
unsigned long SgTypeInt_initializeStorageClassArray( SgTypeIntStorageClass *storageArray );
void SgTypeInt_resetValidFreepointers( );
unsigned long SgTypeInt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSignedInt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSignedInt* SgTypeSignedInt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSignedInt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSignedInt* SgTypeSignedInt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSignedInt* SgTypeSignedInt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSignedInt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSignedInt_clearMemoryPool ( );
void SgTypeSignedInt_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSignedInt_initializeStorageClassArray( SgTypeSignedIntStorageClass *storageArray );
void SgTypeSignedInt_resetValidFreepointers( );
unsigned long SgTypeSignedInt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsignedInt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsignedInt* SgTypeUnsignedInt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsignedInt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsignedInt* SgTypeUnsignedInt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsignedInt* SgTypeUnsignedInt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsignedInt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsignedInt_clearMemoryPool ( );
void SgTypeUnsignedInt_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsignedInt_initializeStorageClassArray( SgTypeUnsignedIntStorageClass *storageArray );
void SgTypeUnsignedInt_resetValidFreepointers( );
unsigned long SgTypeUnsignedInt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeLong* SgTypeLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeLong* SgTypeLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeLong* SgTypeLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeLong_clearMemoryPool ( );
void SgTypeLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeLong_initializeStorageClassArray( SgTypeLongStorageClass *storageArray );
void SgTypeLong_resetValidFreepointers( );
unsigned long SgTypeLong_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSignedLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSignedLong* SgTypeSignedLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSignedLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSignedLong* SgTypeSignedLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSignedLong* SgTypeSignedLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSignedLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSignedLong_clearMemoryPool ( );
void SgTypeSignedLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSignedLong_initializeStorageClassArray( SgTypeSignedLongStorageClass *storageArray );
void SgTypeSignedLong_resetValidFreepointers( );
unsigned long SgTypeSignedLong_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsignedLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsignedLong* SgTypeUnsignedLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsignedLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsignedLong* SgTypeUnsignedLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsignedLong* SgTypeUnsignedLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsignedLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsignedLong_clearMemoryPool ( );
void SgTypeUnsignedLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsignedLong_initializeStorageClassArray( SgTypeUnsignedLongStorageClass *storageArray );
void SgTypeUnsignedLong_resetValidFreepointers( );
unsigned long SgTypeUnsignedLong_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeVoid_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeVoid* SgTypeVoid_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeVoid_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeVoid* SgTypeVoid_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeVoid* SgTypeVoid_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeVoid_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeVoid_clearMemoryPool ( );
void SgTypeVoid_extendMemoryPoolForFileIO ( );
unsigned long SgTypeVoid_initializeStorageClassArray( SgTypeVoidStorageClass *storageArray );
void SgTypeVoid_resetValidFreepointers( );
unsigned long SgTypeVoid_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeGlobalVoid_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeGlobalVoid* SgTypeGlobalVoid_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeGlobalVoid_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeGlobalVoid* SgTypeGlobalVoid_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeGlobalVoid* SgTypeGlobalVoid_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeGlobalVoid_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeGlobalVoid_clearMemoryPool ( );
void SgTypeGlobalVoid_extendMemoryPoolForFileIO ( );
unsigned long SgTypeGlobalVoid_initializeStorageClassArray( SgTypeGlobalVoidStorageClass *storageArray );
void SgTypeGlobalVoid_resetValidFreepointers( );
unsigned long SgTypeGlobalVoid_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeWchar_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeWchar* SgTypeWchar_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeWchar_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeWchar* SgTypeWchar_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeWchar* SgTypeWchar_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeWchar_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeWchar_clearMemoryPool ( );
void SgTypeWchar_extendMemoryPoolForFileIO ( );
unsigned long SgTypeWchar_initializeStorageClassArray( SgTypeWcharStorageClass *storageArray );
void SgTypeWchar_resetValidFreepointers( );
unsigned long SgTypeWchar_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeFloat_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeFloat* SgTypeFloat_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeFloat_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeFloat* SgTypeFloat_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeFloat* SgTypeFloat_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeFloat_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeFloat_clearMemoryPool ( );
void SgTypeFloat_extendMemoryPoolForFileIO ( );
unsigned long SgTypeFloat_initializeStorageClassArray( SgTypeFloatStorageClass *storageArray );
void SgTypeFloat_resetValidFreepointers( );
unsigned long SgTypeFloat_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeDouble_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeDouble* SgTypeDouble_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeDouble_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeDouble* SgTypeDouble_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeDouble* SgTypeDouble_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeDouble_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeDouble_clearMemoryPool ( );
void SgTypeDouble_extendMemoryPoolForFileIO ( );
unsigned long SgTypeDouble_initializeStorageClassArray( SgTypeDoubleStorageClass *storageArray );
void SgTypeDouble_resetValidFreepointers( );
unsigned long SgTypeDouble_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeLongLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeLongLong* SgTypeLongLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeLongLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeLongLong* SgTypeLongLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeLongLong* SgTypeLongLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeLongLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeLongLong_clearMemoryPool ( );
void SgTypeLongLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeLongLong_initializeStorageClassArray( SgTypeLongLongStorageClass *storageArray );
void SgTypeLongLong_resetValidFreepointers( );
unsigned long SgTypeLongLong_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSignedLongLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSignedLongLong* SgTypeSignedLongLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSignedLongLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSignedLongLong* SgTypeSignedLongLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSignedLongLong* SgTypeSignedLongLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSignedLongLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSignedLongLong_clearMemoryPool ( );
void SgTypeSignedLongLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSignedLongLong_initializeStorageClassArray( SgTypeSignedLongLongStorageClass *storageArray );
void SgTypeSignedLongLong_resetValidFreepointers( );
unsigned long SgTypeSignedLongLong_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsignedLongLong_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsignedLongLong* SgTypeUnsignedLongLong_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsignedLongLong_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsignedLongLong* SgTypeUnsignedLongLong_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsignedLongLong* SgTypeUnsignedLongLong_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsignedLongLong_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsignedLongLong_clearMemoryPool ( );
void SgTypeUnsignedLongLong_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsignedLongLong_initializeStorageClassArray( SgTypeUnsignedLongLongStorageClass *storageArray );
void SgTypeUnsignedLongLong_resetValidFreepointers( );
unsigned long SgTypeUnsignedLongLong_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeSigned128bitInteger_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeSigned128bitInteger* SgTypeSigned128bitInteger_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeSigned128bitInteger_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeSigned128bitInteger* SgTypeSigned128bitInteger_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeSigned128bitInteger* SgTypeSigned128bitInteger_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeSigned128bitInteger_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeSigned128bitInteger_clearMemoryPool ( );
void SgTypeSigned128bitInteger_extendMemoryPoolForFileIO ( );
unsigned long SgTypeSigned128bitInteger_initializeStorageClassArray( SgTypeSigned128bitIntegerStorageClass *storageArray );
void SgTypeSigned128bitInteger_resetValidFreepointers( );
unsigned long SgTypeSigned128bitInteger_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeUnsigned128bitInteger_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeUnsigned128bitInteger* SgTypeUnsigned128bitInteger_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeUnsigned128bitInteger_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeUnsigned128bitInteger* SgTypeUnsigned128bitInteger_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeUnsigned128bitInteger* SgTypeUnsigned128bitInteger_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeUnsigned128bitInteger_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeUnsigned128bitInteger_clearMemoryPool ( );
void SgTypeUnsigned128bitInteger_extendMemoryPoolForFileIO ( );
unsigned long SgTypeUnsigned128bitInteger_initializeStorageClassArray( SgTypeUnsigned128bitIntegerStorageClass *storageArray );
void SgTypeUnsigned128bitInteger_resetValidFreepointers( );
unsigned long SgTypeUnsigned128bitInteger_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeFloat80_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeFloat80* SgTypeFloat80_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeFloat80_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeFloat80* SgTypeFloat80_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeFloat80* SgTypeFloat80_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeFloat80_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeFloat80_clearMemoryPool ( );
void SgTypeFloat80_extendMemoryPoolForFileIO ( );
unsigned long SgTypeFloat80_initializeStorageClassArray( SgTypeFloat80StorageClass *storageArray );
void SgTypeFloat80_resetValidFreepointers( );
unsigned long SgTypeFloat80_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeLongDouble_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeLongDouble* SgTypeLongDouble_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeLongDouble_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeLongDouble* SgTypeLongDouble_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeLongDouble* SgTypeLongDouble_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeLongDouble_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeLongDouble_clearMemoryPool ( );
void SgTypeLongDouble_extendMemoryPoolForFileIO ( );
unsigned long SgTypeLongDouble_initializeStorageClassArray( SgTypeLongDoubleStorageClass *storageArray );
void SgTypeLongDouble_resetValidFreepointers( );
unsigned long SgTypeLongDouble_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeString_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeString* SgTypeString_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeString_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeString* SgTypeString_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeString* SgTypeString_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeString_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeString_clearMemoryPool ( );
void SgTypeString_extendMemoryPoolForFileIO ( );
unsigned long SgTypeString_initializeStorageClassArray( SgTypeStringStorageClass *storageArray );
void SgTypeString_resetValidFreepointers( );
unsigned long SgTypeString_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeBool_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeBool* SgTypeBool_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeBool_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeBool* SgTypeBool_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeBool* SgTypeBool_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeBool_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeBool_clearMemoryPool ( );
void SgTypeBool_extendMemoryPoolForFileIO ( );
unsigned long SgTypeBool_initializeStorageClassArray( SgTypeBoolStorageClass *storageArray );
void SgTypeBool_resetValidFreepointers( );
unsigned long SgTypeBool_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPointerType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPointerType* SgPointerType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPointerType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPointerType* SgPointerType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPointerType* SgPointerType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPointerType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPointerType_clearMemoryPool ( );
void SgPointerType_extendMemoryPoolForFileIO ( );
unsigned long SgPointerType_initializeStorageClassArray( SgPointerTypeStorageClass *storageArray );
void SgPointerType_resetValidFreepointers( );
unsigned long SgPointerType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPointerMemberType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPointerMemberType* SgPointerMemberType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPointerMemberType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPointerMemberType* SgPointerMemberType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPointerMemberType* SgPointerMemberType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPointerMemberType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPointerMemberType_clearMemoryPool ( );
void SgPointerMemberType_extendMemoryPoolForFileIO ( );
unsigned long SgPointerMemberType_initializeStorageClassArray( SgPointerMemberTypeStorageClass *storageArray );
void SgPointerMemberType_resetValidFreepointers( );
unsigned long SgPointerMemberType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgReferenceType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgReferenceType* SgReferenceType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgReferenceType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgReferenceType* SgReferenceType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgReferenceType* SgReferenceType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgReferenceType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgReferenceType_clearMemoryPool ( );
void SgReferenceType_extendMemoryPoolForFileIO ( );
unsigned long SgReferenceType_initializeStorageClassArray( SgReferenceTypeStorageClass *storageArray );
void SgReferenceType_resetValidFreepointers( );
unsigned long SgReferenceType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamedType* SgNamedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamedType* SgNamedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamedType* SgNamedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamedType_clearMemoryPool ( );
void SgNamedType_extendMemoryPoolForFileIO ( );
unsigned long SgNamedType_initializeStorageClassArray( SgNamedTypeStorageClass *storageArray );
void SgNamedType_resetValidFreepointers( );
unsigned long SgNamedType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassType* SgClassType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassType* SgClassType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassType* SgClassType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassType_clearMemoryPool ( );
void SgClassType_extendMemoryPoolForFileIO ( );
unsigned long SgClassType_initializeStorageClassArray( SgClassTypeStorageClass *storageArray );
void SgClassType_resetValidFreepointers( );
unsigned long SgClassType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaParameterType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaParameterType* SgJavaParameterType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaParameterType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaParameterType* SgJavaParameterType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaParameterType* SgJavaParameterType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaParameterType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaParameterType_clearMemoryPool ( );
void SgJavaParameterType_extendMemoryPoolForFileIO ( );
unsigned long SgJavaParameterType_initializeStorageClassArray( SgJavaParameterTypeStorageClass *storageArray );
void SgJavaParameterType_resetValidFreepointers( );
unsigned long SgJavaParameterType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJovialTableType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJovialTableType* SgJovialTableType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJovialTableType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJovialTableType* SgJovialTableType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJovialTableType* SgJovialTableType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJovialTableType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJovialTableType_clearMemoryPool ( );
void SgJovialTableType_extendMemoryPoolForFileIO ( );
unsigned long SgJovialTableType_initializeStorageClassArray( SgJovialTableTypeStorageClass *storageArray );
void SgJovialTableType_resetValidFreepointers( );
unsigned long SgJovialTableType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEnumType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEnumType* SgEnumType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEnumType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEnumType* SgEnumType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEnumType* SgEnumType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEnumType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEnumType_clearMemoryPool ( );
void SgEnumType_extendMemoryPoolForFileIO ( );
unsigned long SgEnumType_initializeStorageClassArray( SgEnumTypeStorageClass *storageArray );
void SgEnumType_resetValidFreepointers( );
unsigned long SgEnumType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypedefType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypedefType* SgTypedefType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypedefType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypedefType* SgTypedefType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypedefType* SgTypedefType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypedefType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypedefType_clearMemoryPool ( );
void SgTypedefType_extendMemoryPoolForFileIO ( );
unsigned long SgTypedefType_initializeStorageClassArray( SgTypedefTypeStorageClass *storageArray );
void SgTypedefType_resetValidFreepointers( );
unsigned long SgTypedefType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNonrealType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNonrealType* SgNonrealType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNonrealType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNonrealType* SgNonrealType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNonrealType* SgNonrealType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNonrealType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNonrealType_clearMemoryPool ( );
void SgNonrealType_extendMemoryPoolForFileIO ( );
unsigned long SgNonrealType_initializeStorageClassArray( SgNonrealTypeStorageClass *storageArray );
void SgNonrealType_resetValidFreepointers( );
unsigned long SgNonrealType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaParameterizedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaParameterizedType* SgJavaParameterizedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaParameterizedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaParameterizedType* SgJavaParameterizedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaParameterizedType* SgJavaParameterizedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaParameterizedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaParameterizedType_clearMemoryPool ( );
void SgJavaParameterizedType_extendMemoryPoolForFileIO ( );
unsigned long SgJavaParameterizedType_initializeStorageClassArray( SgJavaParameterizedTypeStorageClass *storageArray );
void SgJavaParameterizedType_resetValidFreepointers( );
unsigned long SgJavaParameterizedType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaQualifiedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaQualifiedType* SgJavaQualifiedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaQualifiedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaQualifiedType* SgJavaQualifiedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaQualifiedType* SgJavaQualifiedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaQualifiedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaQualifiedType_clearMemoryPool ( );
void SgJavaQualifiedType_extendMemoryPoolForFileIO ( );
unsigned long SgJavaQualifiedType_initializeStorageClassArray( SgJavaQualifiedTypeStorageClass *storageArray );
void SgJavaQualifiedType_resetValidFreepointers( );
unsigned long SgJavaQualifiedType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaWildcardType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaWildcardType* SgJavaWildcardType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaWildcardType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaWildcardType* SgJavaWildcardType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaWildcardType* SgJavaWildcardType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaWildcardType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaWildcardType_clearMemoryPool ( );
void SgJavaWildcardType_extendMemoryPoolForFileIO ( );
unsigned long SgJavaWildcardType_initializeStorageClassArray( SgJavaWildcardTypeStorageClass *storageArray );
void SgJavaWildcardType_resetValidFreepointers( );
unsigned long SgJavaWildcardType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaTaskType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaTaskType* SgAdaTaskType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaTaskType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaTaskType* SgAdaTaskType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaTaskType* SgAdaTaskType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaTaskType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaTaskType_clearMemoryPool ( );
void SgAdaTaskType_extendMemoryPoolForFileIO ( );
unsigned long SgAdaTaskType_initializeStorageClassArray( SgAdaTaskTypeStorageClass *storageArray );
void SgAdaTaskType_resetValidFreepointers( );
unsigned long SgAdaTaskType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModifierType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModifierType* SgModifierType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModifierType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModifierType* SgModifierType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModifierType* SgModifierType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModifierType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModifierType_clearMemoryPool ( );
void SgModifierType_extendMemoryPoolForFileIO ( );
unsigned long SgModifierType_initializeStorageClassArray( SgModifierTypeStorageClass *storageArray );
void SgModifierType_resetValidFreepointers( );
unsigned long SgModifierType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionType* SgFunctionType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionType* SgFunctionType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionType* SgFunctionType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionType_clearMemoryPool ( );
void SgFunctionType_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionType_initializeStorageClassArray( SgFunctionTypeStorageClass *storageArray );
void SgFunctionType_resetValidFreepointers( );
unsigned long SgFunctionType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMemberFunctionType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMemberFunctionType* SgMemberFunctionType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMemberFunctionType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMemberFunctionType* SgMemberFunctionType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMemberFunctionType* SgMemberFunctionType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMemberFunctionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMemberFunctionType_clearMemoryPool ( );
void SgMemberFunctionType_extendMemoryPoolForFileIO ( );
unsigned long SgMemberFunctionType_initializeStorageClassArray( SgMemberFunctionTypeStorageClass *storageArray );
void SgMemberFunctionType_resetValidFreepointers( );
unsigned long SgMemberFunctionType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPartialFunctionType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPartialFunctionType* SgPartialFunctionType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPartialFunctionType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPartialFunctionType* SgPartialFunctionType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPartialFunctionType* SgPartialFunctionType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPartialFunctionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPartialFunctionType_clearMemoryPool ( );
void SgPartialFunctionType_extendMemoryPoolForFileIO ( );
unsigned long SgPartialFunctionType_initializeStorageClassArray( SgPartialFunctionTypeStorageClass *storageArray );
void SgPartialFunctionType_resetValidFreepointers( );
unsigned long SgPartialFunctionType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPartialFunctionModifierType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPartialFunctionModifierType* SgPartialFunctionModifierType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPartialFunctionModifierType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPartialFunctionModifierType* SgPartialFunctionModifierType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPartialFunctionModifierType* SgPartialFunctionModifierType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPartialFunctionModifierType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPartialFunctionModifierType_clearMemoryPool ( );
void SgPartialFunctionModifierType_extendMemoryPoolForFileIO ( );
unsigned long SgPartialFunctionModifierType_initializeStorageClassArray( SgPartialFunctionModifierTypeStorageClass *storageArray );
void SgPartialFunctionModifierType_resetValidFreepointers( );
unsigned long SgPartialFunctionModifierType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgArrayType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgArrayType* SgArrayType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgArrayType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgArrayType* SgArrayType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgArrayType* SgArrayType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgArrayType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgArrayType_clearMemoryPool ( );
void SgArrayType_extendMemoryPoolForFileIO ( );
unsigned long SgArrayType_initializeStorageClassArray( SgArrayTypeStorageClass *storageArray );
void SgArrayType_resetValidFreepointers( );
unsigned long SgArrayType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeEllipse_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeEllipse* SgTypeEllipse_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeEllipse_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeEllipse* SgTypeEllipse_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeEllipse* SgTypeEllipse_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeEllipse_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeEllipse_clearMemoryPool ( );
void SgTypeEllipse_extendMemoryPoolForFileIO ( );
unsigned long SgTypeEllipse_initializeStorageClassArray( SgTypeEllipseStorageClass *storageArray );
void SgTypeEllipse_resetValidFreepointers( );
unsigned long SgTypeEllipse_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateType* SgTemplateType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateType* SgTemplateType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateType* SgTemplateType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateType_clearMemoryPool ( );
void SgTemplateType_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateType_initializeStorageClassArray( SgTemplateTypeStorageClass *storageArray );
void SgTemplateType_resetValidFreepointers( );
unsigned long SgTemplateType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgQualifiedNameType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgQualifiedNameType* SgQualifiedNameType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgQualifiedNameType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgQualifiedNameType* SgQualifiedNameType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgQualifiedNameType* SgQualifiedNameType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgQualifiedNameType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgQualifiedNameType_clearMemoryPool ( );
void SgQualifiedNameType_extendMemoryPoolForFileIO ( );
unsigned long SgQualifiedNameType_initializeStorageClassArray( SgQualifiedNameTypeStorageClass *storageArray );
void SgQualifiedNameType_resetValidFreepointers( );
unsigned long SgQualifiedNameType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeComplex_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeComplex* SgTypeComplex_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeComplex_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeComplex* SgTypeComplex_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeComplex* SgTypeComplex_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeComplex_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeComplex_clearMemoryPool ( );
void SgTypeComplex_extendMemoryPoolForFileIO ( );
unsigned long SgTypeComplex_initializeStorageClassArray( SgTypeComplexStorageClass *storageArray );
void SgTypeComplex_resetValidFreepointers( );
unsigned long SgTypeComplex_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeImaginary_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeImaginary* SgTypeImaginary_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeImaginary_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeImaginary* SgTypeImaginary_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeImaginary* SgTypeImaginary_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeImaginary_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeImaginary_clearMemoryPool ( );
void SgTypeImaginary_extendMemoryPoolForFileIO ( );
unsigned long SgTypeImaginary_initializeStorageClassArray( SgTypeImaginaryStorageClass *storageArray );
void SgTypeImaginary_resetValidFreepointers( );
unsigned long SgTypeImaginary_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeDefault_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeDefault* SgTypeDefault_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeDefault_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeDefault* SgTypeDefault_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeDefault* SgTypeDefault_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeDefault_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeDefault_clearMemoryPool ( );
void SgTypeDefault_extendMemoryPoolForFileIO ( );
unsigned long SgTypeDefault_initializeStorageClassArray( SgTypeDefaultStorageClass *storageArray );
void SgTypeDefault_resetValidFreepointers( );
unsigned long SgTypeDefault_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeCAFTeam_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeCAFTeam* SgTypeCAFTeam_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeCAFTeam_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeCAFTeam* SgTypeCAFTeam_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeCAFTeam* SgTypeCAFTeam_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeCAFTeam_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeCAFTeam_clearMemoryPool ( );
void SgTypeCAFTeam_extendMemoryPoolForFileIO ( );
unsigned long SgTypeCAFTeam_initializeStorageClassArray( SgTypeCAFTeamStorageClass *storageArray );
void SgTypeCAFTeam_resetValidFreepointers( );
unsigned long SgTypeCAFTeam_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeCrayPointer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeCrayPointer* SgTypeCrayPointer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeCrayPointer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeCrayPointer* SgTypeCrayPointer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeCrayPointer* SgTypeCrayPointer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeCrayPointer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeCrayPointer_clearMemoryPool ( );
void SgTypeCrayPointer_extendMemoryPoolForFileIO ( );
unsigned long SgTypeCrayPointer_initializeStorageClassArray( SgTypeCrayPointerStorageClass *storageArray );
void SgTypeCrayPointer_resetValidFreepointers( );
unsigned long SgTypeCrayPointer_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeLabel_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeLabel* SgTypeLabel_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeLabel_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeLabel* SgTypeLabel_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeLabel* SgTypeLabel_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeLabel_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeLabel_clearMemoryPool ( );
void SgTypeLabel_extendMemoryPoolForFileIO ( );
unsigned long SgTypeLabel_initializeStorageClassArray( SgTypeLabelStorageClass *storageArray );
void SgTypeLabel_resetValidFreepointers( );
unsigned long SgTypeLabel_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaUnionType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaUnionType* SgJavaUnionType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaUnionType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaUnionType* SgJavaUnionType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaUnionType* SgJavaUnionType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaUnionType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaUnionType_clearMemoryPool ( );
void SgJavaUnionType_extendMemoryPoolForFileIO ( );
unsigned long SgJavaUnionType_initializeStorageClassArray( SgJavaUnionTypeStorageClass *storageArray );
void SgJavaUnionType_resetValidFreepointers( );
unsigned long SgJavaUnionType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRvalueReferenceType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRvalueReferenceType* SgRvalueReferenceType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRvalueReferenceType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRvalueReferenceType* SgRvalueReferenceType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRvalueReferenceType* SgRvalueReferenceType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRvalueReferenceType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRvalueReferenceType_clearMemoryPool ( );
void SgRvalueReferenceType_extendMemoryPoolForFileIO ( );
unsigned long SgRvalueReferenceType_initializeStorageClassArray( SgRvalueReferenceTypeStorageClass *storageArray );
void SgRvalueReferenceType_resetValidFreepointers( );
unsigned long SgRvalueReferenceType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeNullptr_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeNullptr* SgTypeNullptr_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeNullptr_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeNullptr* SgTypeNullptr_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeNullptr* SgTypeNullptr_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeNullptr_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeNullptr_clearMemoryPool ( );
void SgTypeNullptr_extendMemoryPoolForFileIO ( );
unsigned long SgTypeNullptr_initializeStorageClassArray( SgTypeNullptrStorageClass *storageArray );
void SgTypeNullptr_resetValidFreepointers( );
unsigned long SgTypeNullptr_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeclType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeclType* SgDeclType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeclType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeclType* SgDeclType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeclType* SgDeclType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeclType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeclType_clearMemoryPool ( );
void SgDeclType_extendMemoryPoolForFileIO ( );
unsigned long SgDeclType_initializeStorageClassArray( SgDeclTypeStorageClass *storageArray );
void SgDeclType_resetValidFreepointers( );
unsigned long SgDeclType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeOfType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeOfType* SgTypeOfType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeOfType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeOfType* SgTypeOfType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeOfType* SgTypeOfType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeOfType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeOfType_clearMemoryPool ( );
void SgTypeOfType_extendMemoryPoolForFileIO ( );
unsigned long SgTypeOfType_initializeStorageClassArray( SgTypeOfTypeStorageClass *storageArray );
void SgTypeOfType_resetValidFreepointers( );
unsigned long SgTypeOfType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeMatrix_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeMatrix* SgTypeMatrix_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeMatrix_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeMatrix* SgTypeMatrix_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeMatrix* SgTypeMatrix_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeMatrix_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeMatrix_clearMemoryPool ( );
void SgTypeMatrix_extendMemoryPoolForFileIO ( );
unsigned long SgTypeMatrix_initializeStorageClassArray( SgTypeMatrixStorageClass *storageArray );
void SgTypeMatrix_resetValidFreepointers( );
unsigned long SgTypeMatrix_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeTuple_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeTuple* SgTypeTuple_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeTuple_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeTuple* SgTypeTuple_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeTuple* SgTypeTuple_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeTuple_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeTuple_clearMemoryPool ( );
void SgTypeTuple_extendMemoryPoolForFileIO ( );
unsigned long SgTypeTuple_initializeStorageClassArray( SgTypeTupleStorageClass *storageArray );
void SgTypeTuple_resetValidFreepointers( );
unsigned long SgTypeTuple_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeChar16_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeChar16* SgTypeChar16_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeChar16_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeChar16* SgTypeChar16_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeChar16* SgTypeChar16_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeChar16_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeChar16_clearMemoryPool ( );
void SgTypeChar16_extendMemoryPoolForFileIO ( );
unsigned long SgTypeChar16_initializeStorageClassArray( SgTypeChar16StorageClass *storageArray );
void SgTypeChar16_resetValidFreepointers( );
unsigned long SgTypeChar16_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeChar32_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeChar32* SgTypeChar32_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeChar32_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeChar32* SgTypeChar32_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeChar32* SgTypeChar32_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeChar32_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeChar32_clearMemoryPool ( );
void SgTypeChar32_extendMemoryPoolForFileIO ( );
unsigned long SgTypeChar32_initializeStorageClassArray( SgTypeChar32StorageClass *storageArray );
void SgTypeChar32_resetValidFreepointers( );
unsigned long SgTypeChar32_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeFloat128_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeFloat128* SgTypeFloat128_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeFloat128_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeFloat128* SgTypeFloat128_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeFloat128* SgTypeFloat128_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeFloat128_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeFloat128_clearMemoryPool ( );
void SgTypeFloat128_extendMemoryPoolForFileIO ( );
unsigned long SgTypeFloat128_initializeStorageClassArray( SgTypeFloat128StorageClass *storageArray );
void SgTypeFloat128_resetValidFreepointers( );
unsigned long SgTypeFloat128_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeFixed_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeFixed* SgTypeFixed_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeFixed_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeFixed* SgTypeFixed_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeFixed* SgTypeFixed_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeFixed_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeFixed_clearMemoryPool ( );
void SgTypeFixed_extendMemoryPoolForFileIO ( );
unsigned long SgTypeFixed_initializeStorageClassArray( SgTypeFixedStorageClass *storageArray );
void SgTypeFixed_resetValidFreepointers( );
unsigned long SgTypeFixed_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAutoType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAutoType* SgAutoType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAutoType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAutoType* SgAutoType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAutoType* SgAutoType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAutoType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAutoType_clearMemoryPool ( );
void SgAutoType_extendMemoryPoolForFileIO ( );
unsigned long SgAutoType_initializeStorageClassArray( SgAutoTypeStorageClass *storageArray );
void SgAutoType_resetValidFreepointers( );
unsigned long SgAutoType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaAccessType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaAccessType* SgAdaAccessType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaAccessType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaAccessType* SgAdaAccessType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaAccessType* SgAdaAccessType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaAccessType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaAccessType_clearMemoryPool ( );
void SgAdaAccessType_extendMemoryPoolForFileIO ( );
unsigned long SgAdaAccessType_initializeStorageClassArray( SgAdaAccessTypeStorageClass *storageArray );
void SgAdaAccessType_resetValidFreepointers( );
unsigned long SgAdaAccessType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaSubtype_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaSubtype* SgAdaSubtype_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaSubtype_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaSubtype* SgAdaSubtype_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaSubtype* SgAdaSubtype_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaSubtype_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaSubtype_clearMemoryPool ( );
void SgAdaSubtype_extendMemoryPoolForFileIO ( );
unsigned long SgAdaSubtype_initializeStorageClassArray( SgAdaSubtypeStorageClass *storageArray );
void SgAdaSubtype_resetValidFreepointers( );
unsigned long SgAdaSubtype_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaFloatType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaFloatType* SgAdaFloatType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaFloatType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaFloatType* SgAdaFloatType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaFloatType* SgAdaFloatType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaFloatType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaFloatType_clearMemoryPool ( );
void SgAdaFloatType_extendMemoryPoolForFileIO ( );
unsigned long SgAdaFloatType_initializeStorageClassArray( SgAdaFloatTypeStorageClass *storageArray );
void SgAdaFloatType_resetValidFreepointers( );
unsigned long SgAdaFloatType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJovialBitType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJovialBitType* SgJovialBitType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJovialBitType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJovialBitType* SgJovialBitType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJovialBitType* SgJovialBitType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJovialBitType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJovialBitType_clearMemoryPool ( );
void SgJovialBitType_extendMemoryPoolForFileIO ( );
unsigned long SgJovialBitType_initializeStorageClassArray( SgJovialBitTypeStorageClass *storageArray );
void SgJovialBitType_resetValidFreepointers( );
unsigned long SgJovialBitType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLocatedNode_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLocatedNode* SgLocatedNode_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLocatedNode_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLocatedNode* SgLocatedNode_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLocatedNode* SgLocatedNode_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLocatedNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLocatedNode_clearMemoryPool ( );
void SgLocatedNode_extendMemoryPoolForFileIO ( );
unsigned long SgLocatedNode_initializeStorageClassArray( SgLocatedNodeStorageClass *storageArray );
void SgLocatedNode_resetValidFreepointers( );
unsigned long SgLocatedNode_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgToken_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgToken* SgToken_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgToken_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgToken* SgToken_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgToken* SgToken_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgToken_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgToken_clearMemoryPool ( );
void SgToken_extendMemoryPoolForFileIO ( );
unsigned long SgToken_initializeStorageClassArray( SgTokenStorageClass *storageArray );
void SgToken_resetValidFreepointers( );
unsigned long SgToken_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLocatedNodeSupport_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLocatedNodeSupport* SgLocatedNodeSupport_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLocatedNodeSupport_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLocatedNodeSupport* SgLocatedNodeSupport_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLocatedNodeSupport* SgLocatedNodeSupport_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLocatedNodeSupport_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLocatedNodeSupport_clearMemoryPool ( );
void SgLocatedNodeSupport_extendMemoryPoolForFileIO ( );
unsigned long SgLocatedNodeSupport_initializeStorageClassArray( SgLocatedNodeSupportStorageClass *storageArray );
void SgLocatedNodeSupport_resetValidFreepointers( );
unsigned long SgLocatedNodeSupport_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCommonBlockObject_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCommonBlockObject* SgCommonBlockObject_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCommonBlockObject_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCommonBlockObject* SgCommonBlockObject_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCommonBlockObject* SgCommonBlockObject_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCommonBlockObject_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCommonBlockObject_clearMemoryPool ( );
void SgCommonBlockObject_extendMemoryPoolForFileIO ( );
unsigned long SgCommonBlockObject_initializeStorageClassArray( SgCommonBlockObjectStorageClass *storageArray );
void SgCommonBlockObject_resetValidFreepointers( );
unsigned long SgCommonBlockObject_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInitializedName_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInitializedName* SgInitializedName_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInitializedName_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInitializedName* SgInitializedName_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInitializedName* SgInitializedName_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInitializedName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInitializedName_clearMemoryPool ( );
void SgInitializedName_extendMemoryPoolForFileIO ( );
unsigned long SgInitializedName_initializeStorageClassArray( SgInitializedNameStorageClass *storageArray );
void SgInitializedName_resetValidFreepointers( );
unsigned long SgInitializedName_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInterfaceBody_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInterfaceBody* SgInterfaceBody_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInterfaceBody_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInterfaceBody* SgInterfaceBody_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInterfaceBody* SgInterfaceBody_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInterfaceBody_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInterfaceBody_clearMemoryPool ( );
void SgInterfaceBody_extendMemoryPoolForFileIO ( );
unsigned long SgInterfaceBody_initializeStorageClassArray( SgInterfaceBodyStorageClass *storageArray );
void SgInterfaceBody_resetValidFreepointers( );
unsigned long SgInterfaceBody_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgHeaderFileBody_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgHeaderFileBody* SgHeaderFileBody_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgHeaderFileBody_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgHeaderFileBody* SgHeaderFileBody_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgHeaderFileBody* SgHeaderFileBody_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgHeaderFileBody_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgHeaderFileBody_clearMemoryPool ( );
void SgHeaderFileBody_extendMemoryPoolForFileIO ( );
unsigned long SgHeaderFileBody_initializeStorageClassArray( SgHeaderFileBodyStorageClass *storageArray );
void SgHeaderFileBody_resetValidFreepointers( );
unsigned long SgHeaderFileBody_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRenamePair_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRenamePair* SgRenamePair_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRenamePair_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRenamePair* SgRenamePair_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRenamePair* SgRenamePair_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRenamePair_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRenamePair_clearMemoryPool ( );
void SgRenamePair_extendMemoryPoolForFileIO ( );
unsigned long SgRenamePair_initializeStorageClassArray( SgRenamePairStorageClass *storageArray );
void SgRenamePair_resetValidFreepointers( );
unsigned long SgRenamePair_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaMemberValuePair_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaMemberValuePair* SgJavaMemberValuePair_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaMemberValuePair_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaMemberValuePair* SgJavaMemberValuePair_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaMemberValuePair* SgJavaMemberValuePair_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaMemberValuePair_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaMemberValuePair_clearMemoryPool ( );
void SgJavaMemberValuePair_extendMemoryPoolForFileIO ( );
unsigned long SgJavaMemberValuePair_initializeStorageClassArray( SgJavaMemberValuePairStorageClass *storageArray );
void SgJavaMemberValuePair_resetValidFreepointers( );
unsigned long SgJavaMemberValuePair_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpClause* SgOmpClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpClause* SgOmpClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpClause* SgOmpClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpClause_clearMemoryPool ( );
void SgOmpClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpClause_initializeStorageClassArray( SgOmpClauseStorageClass *storageArray );
void SgOmpClause_resetValidFreepointers( );
unsigned long SgOmpClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpNowaitClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpNowaitClause* SgOmpNowaitClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpNowaitClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpNowaitClause* SgOmpNowaitClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpNowaitClause* SgOmpNowaitClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpNowaitClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpNowaitClause_clearMemoryPool ( );
void SgOmpNowaitClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpNowaitClause_initializeStorageClassArray( SgOmpNowaitClauseStorageClass *storageArray );
void SgOmpNowaitClause_resetValidFreepointers( );
unsigned long SgOmpNowaitClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpBeginClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpBeginClause* SgOmpBeginClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpBeginClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpBeginClause* SgOmpBeginClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpBeginClause* SgOmpBeginClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpBeginClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpBeginClause_clearMemoryPool ( );
void SgOmpBeginClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpBeginClause_initializeStorageClassArray( SgOmpBeginClauseStorageClass *storageArray );
void SgOmpBeginClause_resetValidFreepointers( );
unsigned long SgOmpBeginClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpEndClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpEndClause* SgOmpEndClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpEndClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpEndClause* SgOmpEndClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpEndClause* SgOmpEndClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpEndClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpEndClause_clearMemoryPool ( );
void SgOmpEndClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpEndClause_initializeStorageClassArray( SgOmpEndClauseStorageClass *storageArray );
void SgOmpEndClause_resetValidFreepointers( );
unsigned long SgOmpEndClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpUntiedClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpUntiedClause* SgOmpUntiedClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpUntiedClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpUntiedClause* SgOmpUntiedClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpUntiedClause* SgOmpUntiedClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpUntiedClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpUntiedClause_clearMemoryPool ( );
void SgOmpUntiedClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpUntiedClause_initializeStorageClassArray( SgOmpUntiedClauseStorageClass *storageArray );
void SgOmpUntiedClause_resetValidFreepointers( );
unsigned long SgOmpUntiedClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpDefaultClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpDefaultClause* SgOmpDefaultClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpDefaultClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpDefaultClause* SgOmpDefaultClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpDefaultClause* SgOmpDefaultClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpDefaultClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpDefaultClause_clearMemoryPool ( );
void SgOmpDefaultClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpDefaultClause_initializeStorageClassArray( SgOmpDefaultClauseStorageClass *storageArray );
void SgOmpDefaultClause_resetValidFreepointers( );
unsigned long SgOmpDefaultClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpAtomicClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpAtomicClause* SgOmpAtomicClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpAtomicClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpAtomicClause* SgOmpAtomicClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpAtomicClause* SgOmpAtomicClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpAtomicClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpAtomicClause_clearMemoryPool ( );
void SgOmpAtomicClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpAtomicClause_initializeStorageClassArray( SgOmpAtomicClauseStorageClass *storageArray );
void SgOmpAtomicClause_resetValidFreepointers( );
unsigned long SgOmpAtomicClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpProcBindClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpProcBindClause* SgOmpProcBindClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpProcBindClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpProcBindClause* SgOmpProcBindClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpProcBindClause* SgOmpProcBindClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpProcBindClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpProcBindClause_clearMemoryPool ( );
void SgOmpProcBindClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpProcBindClause_initializeStorageClassArray( SgOmpProcBindClauseStorageClass *storageArray );
void SgOmpProcBindClause_resetValidFreepointers( );
unsigned long SgOmpProcBindClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpExpressionClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpExpressionClause* SgOmpExpressionClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpExpressionClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpExpressionClause* SgOmpExpressionClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpExpressionClause* SgOmpExpressionClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpExpressionClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpExpressionClause_clearMemoryPool ( );
void SgOmpExpressionClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpExpressionClause_initializeStorageClassArray( SgOmpExpressionClauseStorageClass *storageArray );
void SgOmpExpressionClause_resetValidFreepointers( );
unsigned long SgOmpExpressionClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpOrderedClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpOrderedClause* SgOmpOrderedClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpOrderedClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpOrderedClause* SgOmpOrderedClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpOrderedClause* SgOmpOrderedClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpOrderedClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpOrderedClause_clearMemoryPool ( );
void SgOmpOrderedClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpOrderedClause_initializeStorageClassArray( SgOmpOrderedClauseStorageClass *storageArray );
void SgOmpOrderedClause_resetValidFreepointers( );
unsigned long SgOmpOrderedClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpCollapseClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpCollapseClause* SgOmpCollapseClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpCollapseClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpCollapseClause* SgOmpCollapseClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpCollapseClause* SgOmpCollapseClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpCollapseClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpCollapseClause_clearMemoryPool ( );
void SgOmpCollapseClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpCollapseClause_initializeStorageClassArray( SgOmpCollapseClauseStorageClass *storageArray );
void SgOmpCollapseClause_resetValidFreepointers( );
unsigned long SgOmpCollapseClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpIfClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpIfClause* SgOmpIfClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpIfClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpIfClause* SgOmpIfClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpIfClause* SgOmpIfClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpIfClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpIfClause_clearMemoryPool ( );
void SgOmpIfClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpIfClause_initializeStorageClassArray( SgOmpIfClauseStorageClass *storageArray );
void SgOmpIfClause_resetValidFreepointers( );
unsigned long SgOmpIfClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpNumThreadsClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpNumThreadsClause* SgOmpNumThreadsClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpNumThreadsClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpNumThreadsClause* SgOmpNumThreadsClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpNumThreadsClause* SgOmpNumThreadsClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpNumThreadsClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpNumThreadsClause_clearMemoryPool ( );
void SgOmpNumThreadsClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpNumThreadsClause_initializeStorageClassArray( SgOmpNumThreadsClauseStorageClass *storageArray );
void SgOmpNumThreadsClause_resetValidFreepointers( );
unsigned long SgOmpNumThreadsClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpDeviceClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpDeviceClause* SgOmpDeviceClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpDeviceClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpDeviceClause* SgOmpDeviceClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpDeviceClause* SgOmpDeviceClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpDeviceClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpDeviceClause_clearMemoryPool ( );
void SgOmpDeviceClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpDeviceClause_initializeStorageClassArray( SgOmpDeviceClauseStorageClass *storageArray );
void SgOmpDeviceClause_resetValidFreepointers( );
unsigned long SgOmpDeviceClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSafelenClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSafelenClause* SgOmpSafelenClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSafelenClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSafelenClause* SgOmpSafelenClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSafelenClause* SgOmpSafelenClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSafelenClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSafelenClause_clearMemoryPool ( );
void SgOmpSafelenClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSafelenClause_initializeStorageClassArray( SgOmpSafelenClauseStorageClass *storageArray );
void SgOmpSafelenClause_resetValidFreepointers( );
unsigned long SgOmpSafelenClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSimdlenClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSimdlenClause* SgOmpSimdlenClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSimdlenClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSimdlenClause* SgOmpSimdlenClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSimdlenClause* SgOmpSimdlenClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSimdlenClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSimdlenClause_clearMemoryPool ( );
void SgOmpSimdlenClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSimdlenClause_initializeStorageClassArray( SgOmpSimdlenClauseStorageClass *storageArray );
void SgOmpSimdlenClause_resetValidFreepointers( );
unsigned long SgOmpSimdlenClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpFinalClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpFinalClause* SgOmpFinalClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpFinalClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpFinalClause* SgOmpFinalClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpFinalClause* SgOmpFinalClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpFinalClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpFinalClause_clearMemoryPool ( );
void SgOmpFinalClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpFinalClause_initializeStorageClassArray( SgOmpFinalClauseStorageClass *storageArray );
void SgOmpFinalClause_resetValidFreepointers( );
unsigned long SgOmpFinalClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpPriorityClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpPriorityClause* SgOmpPriorityClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpPriorityClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpPriorityClause* SgOmpPriorityClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpPriorityClause* SgOmpPriorityClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpPriorityClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpPriorityClause_clearMemoryPool ( );
void SgOmpPriorityClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpPriorityClause_initializeStorageClassArray( SgOmpPriorityClauseStorageClass *storageArray );
void SgOmpPriorityClause_resetValidFreepointers( );
unsigned long SgOmpPriorityClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpInbranchClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpInbranchClause* SgOmpInbranchClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpInbranchClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpInbranchClause* SgOmpInbranchClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpInbranchClause* SgOmpInbranchClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpInbranchClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpInbranchClause_clearMemoryPool ( );
void SgOmpInbranchClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpInbranchClause_initializeStorageClassArray( SgOmpInbranchClauseStorageClass *storageArray );
void SgOmpInbranchClause_resetValidFreepointers( );
unsigned long SgOmpInbranchClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpNotinbranchClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpNotinbranchClause* SgOmpNotinbranchClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpNotinbranchClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpNotinbranchClause* SgOmpNotinbranchClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpNotinbranchClause* SgOmpNotinbranchClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpNotinbranchClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpNotinbranchClause_clearMemoryPool ( );
void SgOmpNotinbranchClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpNotinbranchClause_initializeStorageClassArray( SgOmpNotinbranchClauseStorageClass *storageArray );
void SgOmpNotinbranchClause_resetValidFreepointers( );
unsigned long SgOmpNotinbranchClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpVariablesClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpVariablesClause* SgOmpVariablesClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpVariablesClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpVariablesClause* SgOmpVariablesClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpVariablesClause* SgOmpVariablesClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpVariablesClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpVariablesClause_clearMemoryPool ( );
void SgOmpVariablesClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpVariablesClause_initializeStorageClassArray( SgOmpVariablesClauseStorageClass *storageArray );
void SgOmpVariablesClause_resetValidFreepointers( );
unsigned long SgOmpVariablesClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpCopyprivateClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpCopyprivateClause* SgOmpCopyprivateClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpCopyprivateClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpCopyprivateClause* SgOmpCopyprivateClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpCopyprivateClause* SgOmpCopyprivateClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpCopyprivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpCopyprivateClause_clearMemoryPool ( );
void SgOmpCopyprivateClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpCopyprivateClause_initializeStorageClassArray( SgOmpCopyprivateClauseStorageClass *storageArray );
void SgOmpCopyprivateClause_resetValidFreepointers( );
unsigned long SgOmpCopyprivateClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpPrivateClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpPrivateClause* SgOmpPrivateClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpPrivateClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpPrivateClause* SgOmpPrivateClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpPrivateClause* SgOmpPrivateClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpPrivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpPrivateClause_clearMemoryPool ( );
void SgOmpPrivateClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpPrivateClause_initializeStorageClassArray( SgOmpPrivateClauseStorageClass *storageArray );
void SgOmpPrivateClause_resetValidFreepointers( );
unsigned long SgOmpPrivateClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpFirstprivateClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpFirstprivateClause* SgOmpFirstprivateClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpFirstprivateClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpFirstprivateClause* SgOmpFirstprivateClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpFirstprivateClause* SgOmpFirstprivateClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpFirstprivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpFirstprivateClause_clearMemoryPool ( );
void SgOmpFirstprivateClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpFirstprivateClause_initializeStorageClassArray( SgOmpFirstprivateClauseStorageClass *storageArray );
void SgOmpFirstprivateClause_resetValidFreepointers( );
unsigned long SgOmpFirstprivateClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSharedClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSharedClause* SgOmpSharedClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSharedClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSharedClause* SgOmpSharedClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSharedClause* SgOmpSharedClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSharedClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSharedClause_clearMemoryPool ( );
void SgOmpSharedClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSharedClause_initializeStorageClassArray( SgOmpSharedClauseStorageClass *storageArray );
void SgOmpSharedClause_resetValidFreepointers( );
unsigned long SgOmpSharedClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpCopyinClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpCopyinClause* SgOmpCopyinClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpCopyinClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpCopyinClause* SgOmpCopyinClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpCopyinClause* SgOmpCopyinClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpCopyinClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpCopyinClause_clearMemoryPool ( );
void SgOmpCopyinClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpCopyinClause_initializeStorageClassArray( SgOmpCopyinClauseStorageClass *storageArray );
void SgOmpCopyinClause_resetValidFreepointers( );
unsigned long SgOmpCopyinClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpLastprivateClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpLastprivateClause* SgOmpLastprivateClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpLastprivateClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpLastprivateClause* SgOmpLastprivateClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpLastprivateClause* SgOmpLastprivateClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpLastprivateClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpLastprivateClause_clearMemoryPool ( );
void SgOmpLastprivateClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpLastprivateClause_initializeStorageClassArray( SgOmpLastprivateClauseStorageClass *storageArray );
void SgOmpLastprivateClause_resetValidFreepointers( );
unsigned long SgOmpLastprivateClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpReductionClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpReductionClause* SgOmpReductionClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpReductionClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpReductionClause* SgOmpReductionClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpReductionClause* SgOmpReductionClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpReductionClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpReductionClause_clearMemoryPool ( );
void SgOmpReductionClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpReductionClause_initializeStorageClassArray( SgOmpReductionClauseStorageClass *storageArray );
void SgOmpReductionClause_resetValidFreepointers( );
unsigned long SgOmpReductionClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpMapClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpMapClause* SgOmpMapClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpMapClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpMapClause* SgOmpMapClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpMapClause* SgOmpMapClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpMapClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpMapClause_clearMemoryPool ( );
void SgOmpMapClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpMapClause_initializeStorageClassArray( SgOmpMapClauseStorageClass *storageArray );
void SgOmpMapClause_resetValidFreepointers( );
unsigned long SgOmpMapClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpUniformClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpUniformClause* SgOmpUniformClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpUniformClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpUniformClause* SgOmpUniformClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpUniformClause* SgOmpUniformClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpUniformClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpUniformClause_clearMemoryPool ( );
void SgOmpUniformClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpUniformClause_initializeStorageClassArray( SgOmpUniformClauseStorageClass *storageArray );
void SgOmpUniformClause_resetValidFreepointers( );
unsigned long SgOmpUniformClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpAlignedClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpAlignedClause* SgOmpAlignedClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpAlignedClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpAlignedClause* SgOmpAlignedClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpAlignedClause* SgOmpAlignedClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpAlignedClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpAlignedClause_clearMemoryPool ( );
void SgOmpAlignedClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpAlignedClause_initializeStorageClassArray( SgOmpAlignedClauseStorageClass *storageArray );
void SgOmpAlignedClause_resetValidFreepointers( );
unsigned long SgOmpAlignedClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpLinearClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpLinearClause* SgOmpLinearClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpLinearClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpLinearClause* SgOmpLinearClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpLinearClause* SgOmpLinearClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpLinearClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpLinearClause_clearMemoryPool ( );
void SgOmpLinearClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpLinearClause_initializeStorageClassArray( SgOmpLinearClauseStorageClass *storageArray );
void SgOmpLinearClause_resetValidFreepointers( );
unsigned long SgOmpLinearClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpDependClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpDependClause* SgOmpDependClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpDependClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpDependClause* SgOmpDependClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpDependClause* SgOmpDependClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpDependClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpDependClause_clearMemoryPool ( );
void SgOmpDependClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpDependClause_initializeStorageClassArray( SgOmpDependClauseStorageClass *storageArray );
void SgOmpDependClause_resetValidFreepointers( );
unsigned long SgOmpDependClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpScheduleClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpScheduleClause* SgOmpScheduleClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpScheduleClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpScheduleClause* SgOmpScheduleClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpScheduleClause* SgOmpScheduleClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpScheduleClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpScheduleClause_clearMemoryPool ( );
void SgOmpScheduleClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpScheduleClause_initializeStorageClassArray( SgOmpScheduleClauseStorageClass *storageArray );
void SgOmpScheduleClause_resetValidFreepointers( );
unsigned long SgOmpScheduleClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpMergeableClause_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpMergeableClause* SgOmpMergeableClause_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpMergeableClause_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpMergeableClause* SgOmpMergeableClause_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpMergeableClause* SgOmpMergeableClause_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpMergeableClause_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpMergeableClause_clearMemoryPool ( );
void SgOmpMergeableClause_extendMemoryPoolForFileIO ( );
unsigned long SgOmpMergeableClause_initializeStorageClassArray( SgOmpMergeableClauseStorageClass *storageArray );
void SgOmpMergeableClause_resetValidFreepointers( );
unsigned long SgOmpMergeableClause_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedNode_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedNode* SgUntypedNode_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedNode_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedNode* SgUntypedNode_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedNode* SgUntypedNode_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedNode_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedNode_clearMemoryPool ( );
void SgUntypedNode_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedNode_initializeStorageClassArray( SgUntypedNodeStorageClass *storageArray );
void SgUntypedNode_resetValidFreepointers( );
unsigned long SgUntypedNode_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedExpression* SgUntypedExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedExpression* SgUntypedExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedExpression* SgUntypedExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedExpression_clearMemoryPool ( );
void SgUntypedExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedExpression_initializeStorageClassArray( SgUntypedExpressionStorageClass *storageArray );
void SgUntypedExpression_resetValidFreepointers( );
unsigned long SgUntypedExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedUnaryOperator_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedUnaryOperator* SgUntypedUnaryOperator_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedUnaryOperator_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedUnaryOperator* SgUntypedUnaryOperator_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedUnaryOperator* SgUntypedUnaryOperator_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedUnaryOperator_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedUnaryOperator_clearMemoryPool ( );
void SgUntypedUnaryOperator_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedUnaryOperator_initializeStorageClassArray( SgUntypedUnaryOperatorStorageClass *storageArray );
void SgUntypedUnaryOperator_resetValidFreepointers( );
unsigned long SgUntypedUnaryOperator_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedBinaryOperator_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedBinaryOperator* SgUntypedBinaryOperator_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedBinaryOperator_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedBinaryOperator* SgUntypedBinaryOperator_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedBinaryOperator* SgUntypedBinaryOperator_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedBinaryOperator_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedBinaryOperator_clearMemoryPool ( );
void SgUntypedBinaryOperator_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedBinaryOperator_initializeStorageClassArray( SgUntypedBinaryOperatorStorageClass *storageArray );
void SgUntypedBinaryOperator_resetValidFreepointers( );
unsigned long SgUntypedBinaryOperator_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedExprListExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedExprListExpression* SgUntypedExprListExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedExprListExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedExprListExpression* SgUntypedExprListExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedExprListExpression* SgUntypedExprListExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedExprListExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedExprListExpression_clearMemoryPool ( );
void SgUntypedExprListExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedExprListExpression_initializeStorageClassArray( SgUntypedExprListExpressionStorageClass *storageArray );
void SgUntypedExprListExpression_resetValidFreepointers( );
unsigned long SgUntypedExprListExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedValueExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedValueExpression* SgUntypedValueExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedValueExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedValueExpression* SgUntypedValueExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedValueExpression* SgUntypedValueExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedValueExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedValueExpression_clearMemoryPool ( );
void SgUntypedValueExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedValueExpression_initializeStorageClassArray( SgUntypedValueExpressionStorageClass *storageArray );
void SgUntypedValueExpression_resetValidFreepointers( );
unsigned long SgUntypedValueExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedArrayReferenceExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedArrayReferenceExpression* SgUntypedArrayReferenceExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedArrayReferenceExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedArrayReferenceExpression* SgUntypedArrayReferenceExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedArrayReferenceExpression* SgUntypedArrayReferenceExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedArrayReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedArrayReferenceExpression_clearMemoryPool ( );
void SgUntypedArrayReferenceExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedArrayReferenceExpression_initializeStorageClassArray( SgUntypedArrayReferenceExpressionStorageClass *storageArray );
void SgUntypedArrayReferenceExpression_resetValidFreepointers( );
unsigned long SgUntypedArrayReferenceExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedOtherExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedOtherExpression* SgUntypedOtherExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedOtherExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedOtherExpression* SgUntypedOtherExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedOtherExpression* SgUntypedOtherExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedOtherExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedOtherExpression_clearMemoryPool ( );
void SgUntypedOtherExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedOtherExpression_initializeStorageClassArray( SgUntypedOtherExpressionStorageClass *storageArray );
void SgUntypedOtherExpression_resetValidFreepointers( );
unsigned long SgUntypedOtherExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedFunctionCallOrArrayReferenceExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedFunctionCallOrArrayReferenceExpression* SgUntypedFunctionCallOrArrayReferenceExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedFunctionCallOrArrayReferenceExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedFunctionCallOrArrayReferenceExpression* SgUntypedFunctionCallOrArrayReferenceExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedFunctionCallOrArrayReferenceExpression* SgUntypedFunctionCallOrArrayReferenceExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedFunctionCallOrArrayReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedFunctionCallOrArrayReferenceExpression_clearMemoryPool ( );
void SgUntypedFunctionCallOrArrayReferenceExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedFunctionCallOrArrayReferenceExpression_initializeStorageClassArray( SgUntypedFunctionCallOrArrayReferenceExpressionStorageClass *storageArray );
void SgUntypedFunctionCallOrArrayReferenceExpression_resetValidFreepointers( );
unsigned long SgUntypedFunctionCallOrArrayReferenceExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedSubscriptExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedSubscriptExpression* SgUntypedSubscriptExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedSubscriptExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedSubscriptExpression* SgUntypedSubscriptExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedSubscriptExpression* SgUntypedSubscriptExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedSubscriptExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedSubscriptExpression_clearMemoryPool ( );
void SgUntypedSubscriptExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedSubscriptExpression_initializeStorageClassArray( SgUntypedSubscriptExpressionStorageClass *storageArray );
void SgUntypedSubscriptExpression_resetValidFreepointers( );
unsigned long SgUntypedSubscriptExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedNamedExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedNamedExpression* SgUntypedNamedExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedNamedExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedNamedExpression* SgUntypedNamedExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedNamedExpression* SgUntypedNamedExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedNamedExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedNamedExpression_clearMemoryPool ( );
void SgUntypedNamedExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedNamedExpression_initializeStorageClassArray( SgUntypedNamedExpressionStorageClass *storageArray );
void SgUntypedNamedExpression_resetValidFreepointers( );
unsigned long SgUntypedNamedExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedNullExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedNullExpression* SgUntypedNullExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedNullExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedNullExpression* SgUntypedNullExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedNullExpression* SgUntypedNullExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedNullExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedNullExpression_clearMemoryPool ( );
void SgUntypedNullExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedNullExpression_initializeStorageClassArray( SgUntypedNullExpressionStorageClass *storageArray );
void SgUntypedNullExpression_resetValidFreepointers( );
unsigned long SgUntypedNullExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedReferenceExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedReferenceExpression* SgUntypedReferenceExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedReferenceExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedReferenceExpression* SgUntypedReferenceExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedReferenceExpression* SgUntypedReferenceExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedReferenceExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedReferenceExpression_clearMemoryPool ( );
void SgUntypedReferenceExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedReferenceExpression_initializeStorageClassArray( SgUntypedReferenceExpressionStorageClass *storageArray );
void SgUntypedReferenceExpression_resetValidFreepointers( );
unsigned long SgUntypedReferenceExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedStatement* SgUntypedStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedStatement* SgUntypedStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedStatement* SgUntypedStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedStatement_clearMemoryPool ( );
void SgUntypedStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedStatement_initializeStorageClassArray( SgUntypedStatementStorageClass *storageArray );
void SgUntypedStatement_resetValidFreepointers( );
unsigned long SgUntypedStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedDeclarationStatement* SgUntypedDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedDeclarationStatement* SgUntypedDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedDeclarationStatement* SgUntypedDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedDeclarationStatement_clearMemoryPool ( );
void SgUntypedDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedDeclarationStatement_initializeStorageClassArray( SgUntypedDeclarationStatementStorageClass *storageArray );
void SgUntypedDeclarationStatement_resetValidFreepointers( );
unsigned long SgUntypedDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedNullDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedNullDeclaration* SgUntypedNullDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedNullDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedNullDeclaration* SgUntypedNullDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedNullDeclaration* SgUntypedNullDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedNullDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedNullDeclaration_clearMemoryPool ( );
void SgUntypedNullDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedNullDeclaration_initializeStorageClassArray( SgUntypedNullDeclarationStorageClass *storageArray );
void SgUntypedNullDeclaration_resetValidFreepointers( );
unsigned long SgUntypedNullDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedNameListDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedNameListDeclaration* SgUntypedNameListDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedNameListDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedNameListDeclaration* SgUntypedNameListDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedNameListDeclaration* SgUntypedNameListDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedNameListDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedNameListDeclaration_clearMemoryPool ( );
void SgUntypedNameListDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedNameListDeclaration_initializeStorageClassArray( SgUntypedNameListDeclarationStorageClass *storageArray );
void SgUntypedNameListDeclaration_resetValidFreepointers( );
unsigned long SgUntypedNameListDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedUseStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedUseStatement* SgUntypedUseStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedUseStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedUseStatement* SgUntypedUseStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedUseStatement* SgUntypedUseStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedUseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedUseStatement_clearMemoryPool ( );
void SgUntypedUseStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedUseStatement_initializeStorageClassArray( SgUntypedUseStatementStorageClass *storageArray );
void SgUntypedUseStatement_resetValidFreepointers( );
unsigned long SgUntypedUseStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedImplicitDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedImplicitDeclaration* SgUntypedImplicitDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedImplicitDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedImplicitDeclaration* SgUntypedImplicitDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedImplicitDeclaration* SgUntypedImplicitDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedImplicitDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedImplicitDeclaration_clearMemoryPool ( );
void SgUntypedImplicitDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedImplicitDeclaration_initializeStorageClassArray( SgUntypedImplicitDeclarationStorageClass *storageArray );
void SgUntypedImplicitDeclaration_resetValidFreepointers( );
unsigned long SgUntypedImplicitDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedVariableDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedVariableDeclaration* SgUntypedVariableDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedVariableDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedVariableDeclaration* SgUntypedVariableDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedVariableDeclaration* SgUntypedVariableDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedVariableDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedVariableDeclaration_clearMemoryPool ( );
void SgUntypedVariableDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedVariableDeclaration_initializeStorageClassArray( SgUntypedVariableDeclarationStorageClass *storageArray );
void SgUntypedVariableDeclaration_resetValidFreepointers( );
unsigned long SgUntypedVariableDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedFunctionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedFunctionDeclaration* SgUntypedFunctionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedFunctionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedFunctionDeclaration* SgUntypedFunctionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedFunctionDeclaration* SgUntypedFunctionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedFunctionDeclaration_clearMemoryPool ( );
void SgUntypedFunctionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedFunctionDeclaration_initializeStorageClassArray( SgUntypedFunctionDeclarationStorageClass *storageArray );
void SgUntypedFunctionDeclaration_resetValidFreepointers( );
unsigned long SgUntypedFunctionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedProgramHeaderDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedProgramHeaderDeclaration* SgUntypedProgramHeaderDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedProgramHeaderDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedProgramHeaderDeclaration* SgUntypedProgramHeaderDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedProgramHeaderDeclaration* SgUntypedProgramHeaderDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedProgramHeaderDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedProgramHeaderDeclaration_clearMemoryPool ( );
void SgUntypedProgramHeaderDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedProgramHeaderDeclaration_initializeStorageClassArray( SgUntypedProgramHeaderDeclarationStorageClass *storageArray );
void SgUntypedProgramHeaderDeclaration_resetValidFreepointers( );
unsigned long SgUntypedProgramHeaderDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedSubroutineDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedSubroutineDeclaration* SgUntypedSubroutineDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedSubroutineDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedSubroutineDeclaration* SgUntypedSubroutineDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedSubroutineDeclaration* SgUntypedSubroutineDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedSubroutineDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedSubroutineDeclaration_clearMemoryPool ( );
void SgUntypedSubroutineDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedSubroutineDeclaration_initializeStorageClassArray( SgUntypedSubroutineDeclarationStorageClass *storageArray );
void SgUntypedSubroutineDeclaration_resetValidFreepointers( );
unsigned long SgUntypedSubroutineDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedInterfaceDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedInterfaceDeclaration* SgUntypedInterfaceDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedInterfaceDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedInterfaceDeclaration* SgUntypedInterfaceDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedInterfaceDeclaration* SgUntypedInterfaceDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedInterfaceDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedInterfaceDeclaration_clearMemoryPool ( );
void SgUntypedInterfaceDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedInterfaceDeclaration_initializeStorageClassArray( SgUntypedInterfaceDeclarationStorageClass *storageArray );
void SgUntypedInterfaceDeclaration_resetValidFreepointers( );
unsigned long SgUntypedInterfaceDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedModuleDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedModuleDeclaration* SgUntypedModuleDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedModuleDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedModuleDeclaration* SgUntypedModuleDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedModuleDeclaration* SgUntypedModuleDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedModuleDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedModuleDeclaration_clearMemoryPool ( );
void SgUntypedModuleDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedModuleDeclaration_initializeStorageClassArray( SgUntypedModuleDeclarationStorageClass *storageArray );
void SgUntypedModuleDeclaration_resetValidFreepointers( );
unsigned long SgUntypedModuleDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedSubmoduleDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedSubmoduleDeclaration* SgUntypedSubmoduleDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedSubmoduleDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedSubmoduleDeclaration* SgUntypedSubmoduleDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedSubmoduleDeclaration* SgUntypedSubmoduleDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedSubmoduleDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedSubmoduleDeclaration_clearMemoryPool ( );
void SgUntypedSubmoduleDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedSubmoduleDeclaration_initializeStorageClassArray( SgUntypedSubmoduleDeclarationStorageClass *storageArray );
void SgUntypedSubmoduleDeclaration_resetValidFreepointers( );
unsigned long SgUntypedSubmoduleDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedBlockDataDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedBlockDataDeclaration* SgUntypedBlockDataDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedBlockDataDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedBlockDataDeclaration* SgUntypedBlockDataDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedBlockDataDeclaration* SgUntypedBlockDataDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedBlockDataDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedBlockDataDeclaration_clearMemoryPool ( );
void SgUntypedBlockDataDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedBlockDataDeclaration_initializeStorageClassArray( SgUntypedBlockDataDeclarationStorageClass *storageArray );
void SgUntypedBlockDataDeclaration_resetValidFreepointers( );
unsigned long SgUntypedBlockDataDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedPackageDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedPackageDeclaration* SgUntypedPackageDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedPackageDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedPackageDeclaration* SgUntypedPackageDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedPackageDeclaration* SgUntypedPackageDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedPackageDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedPackageDeclaration_clearMemoryPool ( );
void SgUntypedPackageDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedPackageDeclaration_initializeStorageClassArray( SgUntypedPackageDeclarationStorageClass *storageArray );
void SgUntypedPackageDeclaration_resetValidFreepointers( );
unsigned long SgUntypedPackageDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedStructureDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedStructureDeclaration* SgUntypedStructureDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedStructureDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedStructureDeclaration* SgUntypedStructureDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedStructureDeclaration* SgUntypedStructureDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedStructureDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedStructureDeclaration_clearMemoryPool ( );
void SgUntypedStructureDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedStructureDeclaration_initializeStorageClassArray( SgUntypedStructureDeclarationStorageClass *storageArray );
void SgUntypedStructureDeclaration_resetValidFreepointers( );
unsigned long SgUntypedStructureDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedExceptionHandlerDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedExceptionHandlerDeclaration* SgUntypedExceptionHandlerDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedExceptionHandlerDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedExceptionHandlerDeclaration* SgUntypedExceptionHandlerDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedExceptionHandlerDeclaration* SgUntypedExceptionHandlerDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedExceptionHandlerDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedExceptionHandlerDeclaration_clearMemoryPool ( );
void SgUntypedExceptionHandlerDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedExceptionHandlerDeclaration_initializeStorageClassArray( SgUntypedExceptionHandlerDeclarationStorageClass *storageArray );
void SgUntypedExceptionHandlerDeclaration_resetValidFreepointers( );
unsigned long SgUntypedExceptionHandlerDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedExceptionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedExceptionDeclaration* SgUntypedExceptionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedExceptionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedExceptionDeclaration* SgUntypedExceptionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedExceptionDeclaration* SgUntypedExceptionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedExceptionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedExceptionDeclaration_clearMemoryPool ( );
void SgUntypedExceptionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedExceptionDeclaration_initializeStorageClassArray( SgUntypedExceptionDeclarationStorageClass *storageArray );
void SgUntypedExceptionDeclaration_resetValidFreepointers( );
unsigned long SgUntypedExceptionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedTaskDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedTaskDeclaration* SgUntypedTaskDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedTaskDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedTaskDeclaration* SgUntypedTaskDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedTaskDeclaration* SgUntypedTaskDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedTaskDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedTaskDeclaration_clearMemoryPool ( );
void SgUntypedTaskDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedTaskDeclaration_initializeStorageClassArray( SgUntypedTaskDeclarationStorageClass *storageArray );
void SgUntypedTaskDeclaration_resetValidFreepointers( );
unsigned long SgUntypedTaskDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedUnitDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedUnitDeclaration* SgUntypedUnitDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedUnitDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedUnitDeclaration* SgUntypedUnitDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedUnitDeclaration* SgUntypedUnitDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedUnitDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedUnitDeclaration_clearMemoryPool ( );
void SgUntypedUnitDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedUnitDeclaration_initializeStorageClassArray( SgUntypedUnitDeclarationStorageClass *storageArray );
void SgUntypedUnitDeclaration_resetValidFreepointers( );
unsigned long SgUntypedUnitDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedDirectiveDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedDirectiveDeclaration* SgUntypedDirectiveDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedDirectiveDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedDirectiveDeclaration* SgUntypedDirectiveDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedDirectiveDeclaration* SgUntypedDirectiveDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedDirectiveDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedDirectiveDeclaration_clearMemoryPool ( );
void SgUntypedDirectiveDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedDirectiveDeclaration_initializeStorageClassArray( SgUntypedDirectiveDeclarationStorageClass *storageArray );
void SgUntypedDirectiveDeclaration_resetValidFreepointers( );
unsigned long SgUntypedDirectiveDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedEnumDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedEnumDeclaration* SgUntypedEnumDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedEnumDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedEnumDeclaration* SgUntypedEnumDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedEnumDeclaration* SgUntypedEnumDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedEnumDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedEnumDeclaration_clearMemoryPool ( );
void SgUntypedEnumDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedEnumDeclaration_initializeStorageClassArray( SgUntypedEnumDeclarationStorageClass *storageArray );
void SgUntypedEnumDeclaration_resetValidFreepointers( );
unsigned long SgUntypedEnumDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedTypedefDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedTypedefDeclaration* SgUntypedTypedefDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedTypedefDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedTypedefDeclaration* SgUntypedTypedefDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedTypedefDeclaration* SgUntypedTypedefDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedTypedefDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedTypedefDeclaration_clearMemoryPool ( );
void SgUntypedTypedefDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedTypedefDeclaration_initializeStorageClassArray( SgUntypedTypedefDeclarationStorageClass *storageArray );
void SgUntypedTypedefDeclaration_resetValidFreepointers( );
unsigned long SgUntypedTypedefDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedInitializedNameListDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedInitializedNameListDeclaration* SgUntypedInitializedNameListDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedInitializedNameListDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedInitializedNameListDeclaration* SgUntypedInitializedNameListDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedInitializedNameListDeclaration* SgUntypedInitializedNameListDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedInitializedNameListDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedInitializedNameListDeclaration_clearMemoryPool ( );
void SgUntypedInitializedNameListDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedInitializedNameListDeclaration_initializeStorageClassArray( SgUntypedInitializedNameListDeclarationStorageClass *storageArray );
void SgUntypedInitializedNameListDeclaration_resetValidFreepointers( );
unsigned long SgUntypedInitializedNameListDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedAssignmentStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedAssignmentStatement* SgUntypedAssignmentStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedAssignmentStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedAssignmentStatement* SgUntypedAssignmentStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedAssignmentStatement* SgUntypedAssignmentStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedAssignmentStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedAssignmentStatement_clearMemoryPool ( );
void SgUntypedAssignmentStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedAssignmentStatement_initializeStorageClassArray( SgUntypedAssignmentStatementStorageClass *storageArray );
void SgUntypedAssignmentStatement_resetValidFreepointers( );
unsigned long SgUntypedAssignmentStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedBlockStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedBlockStatement* SgUntypedBlockStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedBlockStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedBlockStatement* SgUntypedBlockStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedBlockStatement* SgUntypedBlockStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedBlockStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedBlockStatement_clearMemoryPool ( );
void SgUntypedBlockStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedBlockStatement_initializeStorageClassArray( SgUntypedBlockStatementStorageClass *storageArray );
void SgUntypedBlockStatement_resetValidFreepointers( );
unsigned long SgUntypedBlockStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedExpressionStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedExpressionStatement* SgUntypedExpressionStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedExpressionStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedExpressionStatement* SgUntypedExpressionStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedExpressionStatement* SgUntypedExpressionStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedExpressionStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedExpressionStatement_clearMemoryPool ( );
void SgUntypedExpressionStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedExpressionStatement_initializeStorageClassArray( SgUntypedExpressionStatementStorageClass *storageArray );
void SgUntypedExpressionStatement_resetValidFreepointers( );
unsigned long SgUntypedExpressionStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedFunctionCallStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedFunctionCallStatement* SgUntypedFunctionCallStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedFunctionCallStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedFunctionCallStatement* SgUntypedFunctionCallStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedFunctionCallStatement* SgUntypedFunctionCallStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedFunctionCallStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedFunctionCallStatement_clearMemoryPool ( );
void SgUntypedFunctionCallStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedFunctionCallStatement_initializeStorageClassArray( SgUntypedFunctionCallStatementStorageClass *storageArray );
void SgUntypedFunctionCallStatement_resetValidFreepointers( );
unsigned long SgUntypedFunctionCallStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedImageControlStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedImageControlStatement* SgUntypedImageControlStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedImageControlStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedImageControlStatement* SgUntypedImageControlStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedImageControlStatement* SgUntypedImageControlStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedImageControlStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedImageControlStatement_clearMemoryPool ( );
void SgUntypedImageControlStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedImageControlStatement_initializeStorageClassArray( SgUntypedImageControlStatementStorageClass *storageArray );
void SgUntypedImageControlStatement_resetValidFreepointers( );
unsigned long SgUntypedImageControlStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedNamedStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedNamedStatement* SgUntypedNamedStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedNamedStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedNamedStatement* SgUntypedNamedStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedNamedStatement* SgUntypedNamedStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedNamedStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedNamedStatement_clearMemoryPool ( );
void SgUntypedNamedStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedNamedStatement_initializeStorageClassArray( SgUntypedNamedStatementStorageClass *storageArray );
void SgUntypedNamedStatement_resetValidFreepointers( );
unsigned long SgUntypedNamedStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedOtherStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedOtherStatement* SgUntypedOtherStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedOtherStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedOtherStatement* SgUntypedOtherStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedOtherStatement* SgUntypedOtherStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedOtherStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedOtherStatement_clearMemoryPool ( );
void SgUntypedOtherStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedOtherStatement_initializeStorageClassArray( SgUntypedOtherStatementStorageClass *storageArray );
void SgUntypedOtherStatement_resetValidFreepointers( );
unsigned long SgUntypedOtherStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedScope_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedScope* SgUntypedScope_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedScope_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedScope* SgUntypedScope_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedScope* SgUntypedScope_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedScope_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedScope_clearMemoryPool ( );
void SgUntypedScope_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedScope_initializeStorageClassArray( SgUntypedScopeStorageClass *storageArray );
void SgUntypedScope_resetValidFreepointers( );
unsigned long SgUntypedScope_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedFunctionScope_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedFunctionScope* SgUntypedFunctionScope_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedFunctionScope_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedFunctionScope* SgUntypedFunctionScope_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedFunctionScope* SgUntypedFunctionScope_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedFunctionScope_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedFunctionScope_clearMemoryPool ( );
void SgUntypedFunctionScope_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedFunctionScope_initializeStorageClassArray( SgUntypedFunctionScopeStorageClass *storageArray );
void SgUntypedFunctionScope_resetValidFreepointers( );
unsigned long SgUntypedFunctionScope_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedModuleScope_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedModuleScope* SgUntypedModuleScope_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedModuleScope_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedModuleScope* SgUntypedModuleScope_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedModuleScope* SgUntypedModuleScope_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedModuleScope_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedModuleScope_clearMemoryPool ( );
void SgUntypedModuleScope_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedModuleScope_initializeStorageClassArray( SgUntypedModuleScopeStorageClass *storageArray );
void SgUntypedModuleScope_resetValidFreepointers( );
unsigned long SgUntypedModuleScope_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedGlobalScope_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedGlobalScope* SgUntypedGlobalScope_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedGlobalScope_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedGlobalScope* SgUntypedGlobalScope_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedGlobalScope* SgUntypedGlobalScope_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedGlobalScope_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedGlobalScope_clearMemoryPool ( );
void SgUntypedGlobalScope_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedGlobalScope_initializeStorageClassArray( SgUntypedGlobalScopeStorageClass *storageArray );
void SgUntypedGlobalScope_resetValidFreepointers( );
unsigned long SgUntypedGlobalScope_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedStructureDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedStructureDefinition* SgUntypedStructureDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedStructureDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedStructureDefinition* SgUntypedStructureDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedStructureDefinition* SgUntypedStructureDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedStructureDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedStructureDefinition_clearMemoryPool ( );
void SgUntypedStructureDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedStructureDefinition_initializeStorageClassArray( SgUntypedStructureDefinitionStorageClass *storageArray );
void SgUntypedStructureDefinition_resetValidFreepointers( );
unsigned long SgUntypedStructureDefinition_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedNullStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedNullStatement* SgUntypedNullStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedNullStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedNullStatement* SgUntypedNullStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedNullStatement* SgUntypedNullStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedNullStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedNullStatement_clearMemoryPool ( );
void SgUntypedNullStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedNullStatement_initializeStorageClassArray( SgUntypedNullStatementStorageClass *storageArray );
void SgUntypedNullStatement_resetValidFreepointers( );
unsigned long SgUntypedNullStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedIfStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedIfStatement* SgUntypedIfStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedIfStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedIfStatement* SgUntypedIfStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedIfStatement* SgUntypedIfStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedIfStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedIfStatement_clearMemoryPool ( );
void SgUntypedIfStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedIfStatement_initializeStorageClassArray( SgUntypedIfStatementStorageClass *storageArray );
void SgUntypedIfStatement_resetValidFreepointers( );
unsigned long SgUntypedIfStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedCaseStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedCaseStatement* SgUntypedCaseStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedCaseStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedCaseStatement* SgUntypedCaseStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedCaseStatement* SgUntypedCaseStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedCaseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedCaseStatement_clearMemoryPool ( );
void SgUntypedCaseStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedCaseStatement_initializeStorageClassArray( SgUntypedCaseStatementStorageClass *storageArray );
void SgUntypedCaseStatement_resetValidFreepointers( );
unsigned long SgUntypedCaseStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedLabelStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedLabelStatement* SgUntypedLabelStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedLabelStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedLabelStatement* SgUntypedLabelStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedLabelStatement* SgUntypedLabelStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedLabelStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedLabelStatement_clearMemoryPool ( );
void SgUntypedLabelStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedLabelStatement_initializeStorageClassArray( SgUntypedLabelStatementStorageClass *storageArray );
void SgUntypedLabelStatement_resetValidFreepointers( );
unsigned long SgUntypedLabelStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedLoopStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedLoopStatement* SgUntypedLoopStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedLoopStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedLoopStatement* SgUntypedLoopStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedLoopStatement* SgUntypedLoopStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedLoopStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedLoopStatement_clearMemoryPool ( );
void SgUntypedLoopStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedLoopStatement_initializeStorageClassArray( SgUntypedLoopStatementStorageClass *storageArray );
void SgUntypedLoopStatement_resetValidFreepointers( );
unsigned long SgUntypedLoopStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedWhileStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedWhileStatement* SgUntypedWhileStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedWhileStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedWhileStatement* SgUntypedWhileStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedWhileStatement* SgUntypedWhileStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedWhileStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedWhileStatement_clearMemoryPool ( );
void SgUntypedWhileStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedWhileStatement_initializeStorageClassArray( SgUntypedWhileStatementStorageClass *storageArray );
void SgUntypedWhileStatement_resetValidFreepointers( );
unsigned long SgUntypedWhileStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedForStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedForStatement* SgUntypedForStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedForStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedForStatement* SgUntypedForStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedForStatement* SgUntypedForStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedForStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedForStatement_clearMemoryPool ( );
void SgUntypedForStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedForStatement_initializeStorageClassArray( SgUntypedForStatementStorageClass *storageArray );
void SgUntypedForStatement_resetValidFreepointers( );
unsigned long SgUntypedForStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedExitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedExitStatement* SgUntypedExitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedExitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedExitStatement* SgUntypedExitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedExitStatement* SgUntypedExitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedExitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedExitStatement_clearMemoryPool ( );
void SgUntypedExitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedExitStatement_initializeStorageClassArray( SgUntypedExitStatementStorageClass *storageArray );
void SgUntypedExitStatement_resetValidFreepointers( );
unsigned long SgUntypedExitStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedGotoStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedGotoStatement* SgUntypedGotoStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedGotoStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedGotoStatement* SgUntypedGotoStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedGotoStatement* SgUntypedGotoStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedGotoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedGotoStatement_clearMemoryPool ( );
void SgUntypedGotoStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedGotoStatement_initializeStorageClassArray( SgUntypedGotoStatementStorageClass *storageArray );
void SgUntypedGotoStatement_resetValidFreepointers( );
unsigned long SgUntypedGotoStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedProcedureCallStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedProcedureCallStatement* SgUntypedProcedureCallStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedProcedureCallStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedProcedureCallStatement* SgUntypedProcedureCallStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedProcedureCallStatement* SgUntypedProcedureCallStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedProcedureCallStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedProcedureCallStatement_clearMemoryPool ( );
void SgUntypedProcedureCallStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedProcedureCallStatement_initializeStorageClassArray( SgUntypedProcedureCallStatementStorageClass *storageArray );
void SgUntypedProcedureCallStatement_resetValidFreepointers( );
unsigned long SgUntypedProcedureCallStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedReturnStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedReturnStatement* SgUntypedReturnStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedReturnStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedReturnStatement* SgUntypedReturnStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedReturnStatement* SgUntypedReturnStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedReturnStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedReturnStatement_clearMemoryPool ( );
void SgUntypedReturnStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedReturnStatement_initializeStorageClassArray( SgUntypedReturnStatementStorageClass *storageArray );
void SgUntypedReturnStatement_resetValidFreepointers( );
unsigned long SgUntypedReturnStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedExtendedReturnStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedExtendedReturnStatement* SgUntypedExtendedReturnStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedExtendedReturnStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedExtendedReturnStatement* SgUntypedExtendedReturnStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedExtendedReturnStatement* SgUntypedExtendedReturnStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedExtendedReturnStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedExtendedReturnStatement_clearMemoryPool ( );
void SgUntypedExtendedReturnStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedExtendedReturnStatement_initializeStorageClassArray( SgUntypedExtendedReturnStatementStorageClass *storageArray );
void SgUntypedExtendedReturnStatement_resetValidFreepointers( );
unsigned long SgUntypedExtendedReturnStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedAcceptStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedAcceptStatement* SgUntypedAcceptStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedAcceptStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedAcceptStatement* SgUntypedAcceptStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedAcceptStatement* SgUntypedAcceptStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedAcceptStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedAcceptStatement_clearMemoryPool ( );
void SgUntypedAcceptStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedAcceptStatement_initializeStorageClassArray( SgUntypedAcceptStatementStorageClass *storageArray );
void SgUntypedAcceptStatement_resetValidFreepointers( );
unsigned long SgUntypedAcceptStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedEntryCallStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedEntryCallStatement* SgUntypedEntryCallStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedEntryCallStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedEntryCallStatement* SgUntypedEntryCallStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedEntryCallStatement* SgUntypedEntryCallStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedEntryCallStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedEntryCallStatement_clearMemoryPool ( );
void SgUntypedEntryCallStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedEntryCallStatement_initializeStorageClassArray( SgUntypedEntryCallStatementStorageClass *storageArray );
void SgUntypedEntryCallStatement_resetValidFreepointers( );
unsigned long SgUntypedEntryCallStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedRequeueStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedRequeueStatement* SgUntypedRequeueStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedRequeueStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedRequeueStatement* SgUntypedRequeueStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedRequeueStatement* SgUntypedRequeueStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedRequeueStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedRequeueStatement_clearMemoryPool ( );
void SgUntypedRequeueStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedRequeueStatement_initializeStorageClassArray( SgUntypedRequeueStatementStorageClass *storageArray );
void SgUntypedRequeueStatement_resetValidFreepointers( );
unsigned long SgUntypedRequeueStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedDelayUntilStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedDelayUntilStatement* SgUntypedDelayUntilStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedDelayUntilStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedDelayUntilStatement* SgUntypedDelayUntilStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedDelayUntilStatement* SgUntypedDelayUntilStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedDelayUntilStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedDelayUntilStatement_clearMemoryPool ( );
void SgUntypedDelayUntilStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedDelayUntilStatement_initializeStorageClassArray( SgUntypedDelayUntilStatementStorageClass *storageArray );
void SgUntypedDelayUntilStatement_resetValidFreepointers( );
unsigned long SgUntypedDelayUntilStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedDelayRelativeStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedDelayRelativeStatement* SgUntypedDelayRelativeStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedDelayRelativeStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedDelayRelativeStatement* SgUntypedDelayRelativeStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedDelayRelativeStatement* SgUntypedDelayRelativeStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedDelayRelativeStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedDelayRelativeStatement_clearMemoryPool ( );
void SgUntypedDelayRelativeStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedDelayRelativeStatement_initializeStorageClassArray( SgUntypedDelayRelativeStatementStorageClass *storageArray );
void SgUntypedDelayRelativeStatement_resetValidFreepointers( );
unsigned long SgUntypedDelayRelativeStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedTerminateAlternativeStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedTerminateAlternativeStatement* SgUntypedTerminateAlternativeStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedTerminateAlternativeStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedTerminateAlternativeStatement* SgUntypedTerminateAlternativeStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedTerminateAlternativeStatement* SgUntypedTerminateAlternativeStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedTerminateAlternativeStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedTerminateAlternativeStatement_clearMemoryPool ( );
void SgUntypedTerminateAlternativeStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedTerminateAlternativeStatement_initializeStorageClassArray( SgUntypedTerminateAlternativeStatementStorageClass *storageArray );
void SgUntypedTerminateAlternativeStatement_resetValidFreepointers( );
unsigned long SgUntypedTerminateAlternativeStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedSelectiveAcceptStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedSelectiveAcceptStatement* SgUntypedSelectiveAcceptStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedSelectiveAcceptStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedSelectiveAcceptStatement* SgUntypedSelectiveAcceptStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedSelectiveAcceptStatement* SgUntypedSelectiveAcceptStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedSelectiveAcceptStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedSelectiveAcceptStatement_clearMemoryPool ( );
void SgUntypedSelectiveAcceptStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedSelectiveAcceptStatement_initializeStorageClassArray( SgUntypedSelectiveAcceptStatementStorageClass *storageArray );
void SgUntypedSelectiveAcceptStatement_resetValidFreepointers( );
unsigned long SgUntypedSelectiveAcceptStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedTimedEntryCallStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedTimedEntryCallStatement* SgUntypedTimedEntryCallStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedTimedEntryCallStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedTimedEntryCallStatement* SgUntypedTimedEntryCallStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedTimedEntryCallStatement* SgUntypedTimedEntryCallStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedTimedEntryCallStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedTimedEntryCallStatement_clearMemoryPool ( );
void SgUntypedTimedEntryCallStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedTimedEntryCallStatement_initializeStorageClassArray( SgUntypedTimedEntryCallStatementStorageClass *storageArray );
void SgUntypedTimedEntryCallStatement_resetValidFreepointers( );
unsigned long SgUntypedTimedEntryCallStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedConditionalEntryCallStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedConditionalEntryCallStatement* SgUntypedConditionalEntryCallStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedConditionalEntryCallStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedConditionalEntryCallStatement* SgUntypedConditionalEntryCallStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedConditionalEntryCallStatement* SgUntypedConditionalEntryCallStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedConditionalEntryCallStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedConditionalEntryCallStatement_clearMemoryPool ( );
void SgUntypedConditionalEntryCallStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedConditionalEntryCallStatement_initializeStorageClassArray( SgUntypedConditionalEntryCallStatementStorageClass *storageArray );
void SgUntypedConditionalEntryCallStatement_resetValidFreepointers( );
unsigned long SgUntypedConditionalEntryCallStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedAsynchronousSelectStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedAsynchronousSelectStatement* SgUntypedAsynchronousSelectStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedAsynchronousSelectStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedAsynchronousSelectStatement* SgUntypedAsynchronousSelectStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedAsynchronousSelectStatement* SgUntypedAsynchronousSelectStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedAsynchronousSelectStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedAsynchronousSelectStatement_clearMemoryPool ( );
void SgUntypedAsynchronousSelectStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedAsynchronousSelectStatement_initializeStorageClassArray( SgUntypedAsynchronousSelectStatementStorageClass *storageArray );
void SgUntypedAsynchronousSelectStatement_resetValidFreepointers( );
unsigned long SgUntypedAsynchronousSelectStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedAbortStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedAbortStatement* SgUntypedAbortStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedAbortStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedAbortStatement* SgUntypedAbortStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedAbortStatement* SgUntypedAbortStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedAbortStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedAbortStatement_clearMemoryPool ( );
void SgUntypedAbortStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedAbortStatement_initializeStorageClassArray( SgUntypedAbortStatementStorageClass *storageArray );
void SgUntypedAbortStatement_resetValidFreepointers( );
unsigned long SgUntypedAbortStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedRaiseStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedRaiseStatement* SgUntypedRaiseStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedRaiseStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedRaiseStatement* SgUntypedRaiseStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedRaiseStatement* SgUntypedRaiseStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedRaiseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedRaiseStatement_clearMemoryPool ( );
void SgUntypedRaiseStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedRaiseStatement_initializeStorageClassArray( SgUntypedRaiseStatementStorageClass *storageArray );
void SgUntypedRaiseStatement_resetValidFreepointers( );
unsigned long SgUntypedRaiseStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedStopStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedStopStatement* SgUntypedStopStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedStopStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedStopStatement* SgUntypedStopStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedStopStatement* SgUntypedStopStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedStopStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedStopStatement_clearMemoryPool ( );
void SgUntypedStopStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedStopStatement_initializeStorageClassArray( SgUntypedStopStatementStorageClass *storageArray );
void SgUntypedStopStatement_resetValidFreepointers( );
unsigned long SgUntypedStopStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedCodeStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedCodeStatement* SgUntypedCodeStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedCodeStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedCodeStatement* SgUntypedCodeStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedCodeStatement* SgUntypedCodeStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedCodeStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedCodeStatement_clearMemoryPool ( );
void SgUntypedCodeStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedCodeStatement_initializeStorageClassArray( SgUntypedCodeStatementStorageClass *storageArray );
void SgUntypedCodeStatement_resetValidFreepointers( );
unsigned long SgUntypedCodeStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedForAllStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedForAllStatement* SgUntypedForAllStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedForAllStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedForAllStatement* SgUntypedForAllStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedForAllStatement* SgUntypedForAllStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedForAllStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedForAllStatement_clearMemoryPool ( );
void SgUntypedForAllStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedForAllStatement_initializeStorageClassArray( SgUntypedForAllStatementStorageClass *storageArray );
void SgUntypedForAllStatement_resetValidFreepointers( );
unsigned long SgUntypedForAllStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedName_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedName* SgUntypedName_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedName_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedName* SgUntypedName_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedName* SgUntypedName_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedName_clearMemoryPool ( );
void SgUntypedName_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedName_initializeStorageClassArray( SgUntypedNameStorageClass *storageArray );
void SgUntypedName_resetValidFreepointers( );
unsigned long SgUntypedName_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedToken_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedToken* SgUntypedToken_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedToken_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedToken* SgUntypedToken_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedToken* SgUntypedToken_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedToken_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedToken_clearMemoryPool ( );
void SgUntypedToken_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedToken_initializeStorageClassArray( SgUntypedTokenStorageClass *storageArray );
void SgUntypedToken_resetValidFreepointers( );
unsigned long SgUntypedToken_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedTokenPair_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedTokenPair* SgUntypedTokenPair_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedTokenPair_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedTokenPair* SgUntypedTokenPair_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedTokenPair* SgUntypedTokenPair_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedTokenPair_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedTokenPair_clearMemoryPool ( );
void SgUntypedTokenPair_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedTokenPair_initializeStorageClassArray( SgUntypedTokenPairStorageClass *storageArray );
void SgUntypedTokenPair_resetValidFreepointers( );
unsigned long SgUntypedTokenPair_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedType* SgUntypedType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedType* SgUntypedType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedType* SgUntypedType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedType_clearMemoryPool ( );
void SgUntypedType_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedType_initializeStorageClassArray( SgUntypedTypeStorageClass *storageArray );
void SgUntypedType_resetValidFreepointers( );
unsigned long SgUntypedType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedArrayType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedArrayType* SgUntypedArrayType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedArrayType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedArrayType* SgUntypedArrayType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedArrayType* SgUntypedArrayType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedArrayType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedArrayType_clearMemoryPool ( );
void SgUntypedArrayType_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedArrayType_initializeStorageClassArray( SgUntypedArrayTypeStorageClass *storageArray );
void SgUntypedArrayType_resetValidFreepointers( );
unsigned long SgUntypedArrayType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedTableType_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedTableType* SgUntypedTableType_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedTableType_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedTableType* SgUntypedTableType_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedTableType* SgUntypedTableType_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedTableType_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedTableType_clearMemoryPool ( );
void SgUntypedTableType_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedTableType_initializeStorageClassArray( SgUntypedTableTypeStorageClass *storageArray );
void SgUntypedTableType_resetValidFreepointers( );
unsigned long SgUntypedTableType_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedAttribute_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedAttribute* SgUntypedAttribute_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedAttribute_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedAttribute* SgUntypedAttribute_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedAttribute* SgUntypedAttribute_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedAttribute_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedAttribute_clearMemoryPool ( );
void SgUntypedAttribute_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedAttribute_initializeStorageClassArray( SgUntypedAttributeStorageClass *storageArray );
void SgUntypedAttribute_resetValidFreepointers( );
unsigned long SgUntypedAttribute_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedInitializedName_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedInitializedName* SgUntypedInitializedName_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedInitializedName_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedInitializedName* SgUntypedInitializedName_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedInitializedName* SgUntypedInitializedName_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedInitializedName_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedInitializedName_clearMemoryPool ( );
void SgUntypedInitializedName_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedInitializedName_initializeStorageClassArray( SgUntypedInitializedNameStorageClass *storageArray );
void SgUntypedInitializedName_resetValidFreepointers( );
unsigned long SgUntypedInitializedName_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedFile_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedFile* SgUntypedFile_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedFile_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedFile* SgUntypedFile_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedFile* SgUntypedFile_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedFile_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedFile_clearMemoryPool ( );
void SgUntypedFile_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedFile_initializeStorageClassArray( SgUntypedFileStorageClass *storageArray );
void SgUntypedFile_resetValidFreepointers( );
unsigned long SgUntypedFile_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedStatementList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedStatementList* SgUntypedStatementList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedStatementList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedStatementList* SgUntypedStatementList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedStatementList* SgUntypedStatementList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedStatementList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedStatementList_clearMemoryPool ( );
void SgUntypedStatementList_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedStatementList_initializeStorageClassArray( SgUntypedStatementListStorageClass *storageArray );
void SgUntypedStatementList_resetValidFreepointers( );
unsigned long SgUntypedStatementList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedDeclarationStatementList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedDeclarationStatementList* SgUntypedDeclarationStatementList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedDeclarationStatementList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedDeclarationStatementList* SgUntypedDeclarationStatementList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedDeclarationStatementList* SgUntypedDeclarationStatementList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedDeclarationStatementList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedDeclarationStatementList_clearMemoryPool ( );
void SgUntypedDeclarationStatementList_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedDeclarationStatementList_initializeStorageClassArray( SgUntypedDeclarationStatementListStorageClass *storageArray );
void SgUntypedDeclarationStatementList_resetValidFreepointers( );
unsigned long SgUntypedDeclarationStatementList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedFunctionDeclarationList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedFunctionDeclarationList* SgUntypedFunctionDeclarationList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedFunctionDeclarationList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedFunctionDeclarationList* SgUntypedFunctionDeclarationList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedFunctionDeclarationList* SgUntypedFunctionDeclarationList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedFunctionDeclarationList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedFunctionDeclarationList_clearMemoryPool ( );
void SgUntypedFunctionDeclarationList_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedFunctionDeclarationList_initializeStorageClassArray( SgUntypedFunctionDeclarationListStorageClass *storageArray );
void SgUntypedFunctionDeclarationList_resetValidFreepointers( );
unsigned long SgUntypedFunctionDeclarationList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedInitializedNameList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedInitializedNameList* SgUntypedInitializedNameList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedInitializedNameList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedInitializedNameList* SgUntypedInitializedNameList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedInitializedNameList* SgUntypedInitializedNameList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedInitializedNameList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedInitializedNameList_clearMemoryPool ( );
void SgUntypedInitializedNameList_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedInitializedNameList_initializeStorageClassArray( SgUntypedInitializedNameListStorageClass *storageArray );
void SgUntypedInitializedNameList_resetValidFreepointers( );
unsigned long SgUntypedInitializedNameList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedNameList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedNameList* SgUntypedNameList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedNameList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedNameList* SgUntypedNameList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedNameList* SgUntypedNameList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedNameList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedNameList_clearMemoryPool ( );
void SgUntypedNameList_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedNameList_initializeStorageClassArray( SgUntypedNameListStorageClass *storageArray );
void SgUntypedNameList_resetValidFreepointers( );
unsigned long SgUntypedNameList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedTokenList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedTokenList* SgUntypedTokenList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedTokenList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedTokenList* SgUntypedTokenList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedTokenList* SgUntypedTokenList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedTokenList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedTokenList_clearMemoryPool ( );
void SgUntypedTokenList_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedTokenList_initializeStorageClassArray( SgUntypedTokenListStorageClass *storageArray );
void SgUntypedTokenList_resetValidFreepointers( );
unsigned long SgUntypedTokenList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUntypedTokenPairList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUntypedTokenPairList* SgUntypedTokenPairList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUntypedTokenPairList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUntypedTokenPairList* SgUntypedTokenPairList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUntypedTokenPairList* SgUntypedTokenPairList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUntypedTokenPairList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUntypedTokenPairList_clearMemoryPool ( );
void SgUntypedTokenPairList_extendMemoryPoolForFileIO ( );
unsigned long SgUntypedTokenPairList_initializeStorageClassArray( SgUntypedTokenPairListStorageClass *storageArray );
void SgUntypedTokenPairList_resetValidFreepointers( );
unsigned long SgUntypedTokenPairList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLambdaCapture_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLambdaCapture* SgLambdaCapture_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLambdaCapture_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLambdaCapture* SgLambdaCapture_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLambdaCapture* SgLambdaCapture_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLambdaCapture_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLambdaCapture_clearMemoryPool ( );
void SgLambdaCapture_extendMemoryPoolForFileIO ( );
unsigned long SgLambdaCapture_initializeStorageClassArray( SgLambdaCaptureStorageClass *storageArray );
void SgLambdaCapture_resetValidFreepointers( );
unsigned long SgLambdaCapture_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLambdaCaptureList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLambdaCaptureList* SgLambdaCaptureList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLambdaCaptureList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLambdaCaptureList* SgLambdaCaptureList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLambdaCaptureList* SgLambdaCaptureList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLambdaCaptureList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLambdaCaptureList_clearMemoryPool ( );
void SgLambdaCaptureList_extendMemoryPoolForFileIO ( );
unsigned long SgLambdaCaptureList_initializeStorageClassArray( SgLambdaCaptureListStorageClass *storageArray );
void SgLambdaCaptureList_resetValidFreepointers( );
unsigned long SgLambdaCaptureList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStatement* SgStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStatement* SgStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStatement* SgStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStatement_clearMemoryPool ( );
void SgStatement_extendMemoryPoolForFileIO ( );
unsigned long SgStatement_initializeStorageClassArray( SgStatementStorageClass *storageArray );
void SgStatement_resetValidFreepointers( );
unsigned long SgStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgScopeStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgScopeStatement* SgScopeStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgScopeStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgScopeStatement* SgScopeStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgScopeStatement* SgScopeStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgScopeStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgScopeStatement_clearMemoryPool ( );
void SgScopeStatement_extendMemoryPoolForFileIO ( );
unsigned long SgScopeStatement_initializeStorageClassArray( SgScopeStatementStorageClass *storageArray );
void SgScopeStatement_resetValidFreepointers( );
unsigned long SgScopeStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGlobal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGlobal* SgGlobal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGlobal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGlobal* SgGlobal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGlobal* SgGlobal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGlobal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGlobal_clearMemoryPool ( );
void SgGlobal_extendMemoryPoolForFileIO ( );
unsigned long SgGlobal_initializeStorageClassArray( SgGlobalStorageClass *storageArray );
void SgGlobal_resetValidFreepointers( );
unsigned long SgGlobal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBasicBlock_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBasicBlock* SgBasicBlock_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBasicBlock_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBasicBlock* SgBasicBlock_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBasicBlock* SgBasicBlock_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBasicBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBasicBlock_clearMemoryPool ( );
void SgBasicBlock_extendMemoryPoolForFileIO ( );
unsigned long SgBasicBlock_initializeStorageClassArray( SgBasicBlockStorageClass *storageArray );
void SgBasicBlock_resetValidFreepointers( );
unsigned long SgBasicBlock_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIfStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIfStmt* SgIfStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIfStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIfStmt* SgIfStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIfStmt* SgIfStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIfStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIfStmt_clearMemoryPool ( );
void SgIfStmt_extendMemoryPoolForFileIO ( );
unsigned long SgIfStmt_initializeStorageClassArray( SgIfStmtStorageClass *storageArray );
void SgIfStmt_resetValidFreepointers( );
unsigned long SgIfStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgForStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgForStatement* SgForStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgForStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgForStatement* SgForStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgForStatement* SgForStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgForStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgForStatement_clearMemoryPool ( );
void SgForStatement_extendMemoryPoolForFileIO ( );
unsigned long SgForStatement_initializeStorageClassArray( SgForStatementStorageClass *storageArray );
void SgForStatement_resetValidFreepointers( );
unsigned long SgForStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionDefinition* SgFunctionDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionDefinition* SgFunctionDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionDefinition* SgFunctionDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionDefinition_clearMemoryPool ( );
void SgFunctionDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionDefinition_initializeStorageClassArray( SgFunctionDefinitionStorageClass *storageArray );
void SgFunctionDefinition_resetValidFreepointers( );
unsigned long SgFunctionDefinition_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateFunctionDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateFunctionDefinition* SgTemplateFunctionDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateFunctionDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateFunctionDefinition* SgTemplateFunctionDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateFunctionDefinition* SgTemplateFunctionDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateFunctionDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateFunctionDefinition_clearMemoryPool ( );
void SgTemplateFunctionDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateFunctionDefinition_initializeStorageClassArray( SgTemplateFunctionDefinitionStorageClass *storageArray );
void SgTemplateFunctionDefinition_resetValidFreepointers( );
unsigned long SgTemplateFunctionDefinition_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassDefinition* SgClassDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassDefinition* SgClassDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassDefinition* SgClassDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassDefinition_clearMemoryPool ( );
void SgClassDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgClassDefinition_initializeStorageClassArray( SgClassDefinitionStorageClass *storageArray );
void SgClassDefinition_resetValidFreepointers( );
unsigned long SgClassDefinition_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationDefn_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationDefn* SgTemplateInstantiationDefn_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationDefn_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationDefn* SgTemplateInstantiationDefn_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationDefn* SgTemplateInstantiationDefn_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationDefn_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationDefn_clearMemoryPool ( );
void SgTemplateInstantiationDefn_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationDefn_initializeStorageClassArray( SgTemplateInstantiationDefnStorageClass *storageArray );
void SgTemplateInstantiationDefn_resetValidFreepointers( );
unsigned long SgTemplateInstantiationDefn_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateClassDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateClassDefinition* SgTemplateClassDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateClassDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateClassDefinition* SgTemplateClassDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateClassDefinition* SgTemplateClassDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateClassDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateClassDefinition_clearMemoryPool ( );
void SgTemplateClassDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateClassDefinition_initializeStorageClassArray( SgTemplateClassDefinitionStorageClass *storageArray );
void SgTemplateClassDefinition_resetValidFreepointers( );
unsigned long SgTemplateClassDefinition_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWhileStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWhileStmt* SgWhileStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWhileStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWhileStmt* SgWhileStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWhileStmt* SgWhileStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWhileStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWhileStmt_clearMemoryPool ( );
void SgWhileStmt_extendMemoryPoolForFileIO ( );
unsigned long SgWhileStmt_initializeStorageClassArray( SgWhileStmtStorageClass *storageArray );
void SgWhileStmt_resetValidFreepointers( );
unsigned long SgWhileStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDoWhileStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDoWhileStmt* SgDoWhileStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDoWhileStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDoWhileStmt* SgDoWhileStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDoWhileStmt* SgDoWhileStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDoWhileStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDoWhileStmt_clearMemoryPool ( );
void SgDoWhileStmt_extendMemoryPoolForFileIO ( );
unsigned long SgDoWhileStmt_initializeStorageClassArray( SgDoWhileStmtStorageClass *storageArray );
void SgDoWhileStmt_resetValidFreepointers( );
unsigned long SgDoWhileStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSwitchStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSwitchStatement* SgSwitchStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSwitchStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSwitchStatement* SgSwitchStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSwitchStatement* SgSwitchStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSwitchStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSwitchStatement_clearMemoryPool ( );
void SgSwitchStatement_extendMemoryPoolForFileIO ( );
unsigned long SgSwitchStatement_initializeStorageClassArray( SgSwitchStatementStorageClass *storageArray );
void SgSwitchStatement_resetValidFreepointers( );
unsigned long SgSwitchStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCatchOptionStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCatchOptionStmt* SgCatchOptionStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCatchOptionStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCatchOptionStmt* SgCatchOptionStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCatchOptionStmt* SgCatchOptionStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCatchOptionStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCatchOptionStmt_clearMemoryPool ( );
void SgCatchOptionStmt_extendMemoryPoolForFileIO ( );
unsigned long SgCatchOptionStmt_initializeStorageClassArray( SgCatchOptionStmtStorageClass *storageArray );
void SgCatchOptionStmt_resetValidFreepointers( );
unsigned long SgCatchOptionStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamespaceDefinitionStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamespaceDefinitionStatement* SgNamespaceDefinitionStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamespaceDefinitionStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamespaceDefinitionStatement* SgNamespaceDefinitionStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamespaceDefinitionStatement* SgNamespaceDefinitionStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamespaceDefinitionStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamespaceDefinitionStatement_clearMemoryPool ( );
void SgNamespaceDefinitionStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNamespaceDefinitionStatement_initializeStorageClassArray( SgNamespaceDefinitionStatementStorageClass *storageArray );
void SgNamespaceDefinitionStatement_resetValidFreepointers( );
unsigned long SgNamespaceDefinitionStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBlockDataStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBlockDataStatement* SgBlockDataStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBlockDataStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBlockDataStatement* SgBlockDataStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBlockDataStatement* SgBlockDataStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBlockDataStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBlockDataStatement_clearMemoryPool ( );
void SgBlockDataStatement_extendMemoryPoolForFileIO ( );
unsigned long SgBlockDataStatement_initializeStorageClassArray( SgBlockDataStatementStorageClass *storageArray );
void SgBlockDataStatement_resetValidFreepointers( );
unsigned long SgBlockDataStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssociateStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssociateStatement* SgAssociateStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssociateStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssociateStatement* SgAssociateStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssociateStatement* SgAssociateStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssociateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssociateStatement_clearMemoryPool ( );
void SgAssociateStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAssociateStatement_initializeStorageClassArray( SgAssociateStatementStorageClass *storageArray );
void SgAssociateStatement_resetValidFreepointers( );
unsigned long SgAssociateStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFortranDo_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFortranDo* SgFortranDo_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFortranDo_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFortranDo* SgFortranDo_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFortranDo* SgFortranDo_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFortranDo_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFortranDo_clearMemoryPool ( );
void SgFortranDo_extendMemoryPoolForFileIO ( );
unsigned long SgFortranDo_initializeStorageClassArray( SgFortranDoStorageClass *storageArray );
void SgFortranDo_resetValidFreepointers( );
unsigned long SgFortranDo_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFortranNonblockedDo_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFortranNonblockedDo* SgFortranNonblockedDo_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFortranNonblockedDo_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFortranNonblockedDo* SgFortranNonblockedDo_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFortranNonblockedDo* SgFortranNonblockedDo_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFortranNonblockedDo_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFortranNonblockedDo_clearMemoryPool ( );
void SgFortranNonblockedDo_extendMemoryPoolForFileIO ( );
unsigned long SgFortranNonblockedDo_initializeStorageClassArray( SgFortranNonblockedDoStorageClass *storageArray );
void SgFortranNonblockedDo_resetValidFreepointers( );
unsigned long SgFortranNonblockedDo_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgForAllStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgForAllStatement* SgForAllStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgForAllStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgForAllStatement* SgForAllStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgForAllStatement* SgForAllStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgForAllStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgForAllStatement_clearMemoryPool ( );
void SgForAllStatement_extendMemoryPoolForFileIO ( );
unsigned long SgForAllStatement_initializeStorageClassArray( SgForAllStatementStorageClass *storageArray );
void SgForAllStatement_resetValidFreepointers( );
unsigned long SgForAllStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcForAllStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcForAllStatement* SgUpcForAllStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcForAllStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcForAllStatement* SgUpcForAllStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcForAllStatement* SgUpcForAllStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcForAllStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcForAllStatement_clearMemoryPool ( );
void SgUpcForAllStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUpcForAllStatement_initializeStorageClassArray( SgUpcForAllStatementStorageClass *storageArray );
void SgUpcForAllStatement_resetValidFreepointers( );
unsigned long SgUpcForAllStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCAFWithTeamStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCAFWithTeamStatement* SgCAFWithTeamStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCAFWithTeamStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCAFWithTeamStatement* SgCAFWithTeamStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCAFWithTeamStatement* SgCAFWithTeamStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCAFWithTeamStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCAFWithTeamStatement_clearMemoryPool ( );
void SgCAFWithTeamStatement_extendMemoryPoolForFileIO ( );
unsigned long SgCAFWithTeamStatement_initializeStorageClassArray( SgCAFWithTeamStatementStorageClass *storageArray );
void SgCAFWithTeamStatement_resetValidFreepointers( );
unsigned long SgCAFWithTeamStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaForEachStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaForEachStatement* SgJavaForEachStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaForEachStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaForEachStatement* SgJavaForEachStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaForEachStatement* SgJavaForEachStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaForEachStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaForEachStatement_clearMemoryPool ( );
void SgJavaForEachStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaForEachStatement_initializeStorageClassArray( SgJavaForEachStatementStorageClass *storageArray );
void SgJavaForEachStatement_resetValidFreepointers( );
unsigned long SgJavaForEachStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaLabelStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaLabelStatement* SgJavaLabelStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaLabelStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaLabelStatement* SgJavaLabelStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaLabelStatement* SgJavaLabelStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaLabelStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaLabelStatement_clearMemoryPool ( );
void SgJavaLabelStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaLabelStatement_initializeStorageClassArray( SgJavaLabelStatementStorageClass *storageArray );
void SgJavaLabelStatement_resetValidFreepointers( );
unsigned long SgJavaLabelStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMatlabForStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMatlabForStatement* SgMatlabForStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMatlabForStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMatlabForStatement* SgMatlabForStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMatlabForStatement* SgMatlabForStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMatlabForStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMatlabForStatement_clearMemoryPool ( );
void SgMatlabForStatement_extendMemoryPoolForFileIO ( );
unsigned long SgMatlabForStatement_initializeStorageClassArray( SgMatlabForStatementStorageClass *storageArray );
void SgMatlabForStatement_resetValidFreepointers( );
unsigned long SgMatlabForStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionParameterScope_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionParameterScope* SgFunctionParameterScope_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionParameterScope_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionParameterScope* SgFunctionParameterScope_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionParameterScope* SgFunctionParameterScope_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionParameterScope_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionParameterScope_clearMemoryPool ( );
void SgFunctionParameterScope_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionParameterScope_initializeStorageClassArray( SgFunctionParameterScopeStorageClass *storageArray );
void SgFunctionParameterScope_resetValidFreepointers( );
unsigned long SgFunctionParameterScope_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeclarationScope_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeclarationScope* SgDeclarationScope_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeclarationScope_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeclarationScope* SgDeclarationScope_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeclarationScope* SgDeclarationScope_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeclarationScope_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeclarationScope_clearMemoryPool ( );
void SgDeclarationScope_extendMemoryPoolForFileIO ( );
unsigned long SgDeclarationScope_initializeStorageClassArray( SgDeclarationScopeStorageClass *storageArray );
void SgDeclarationScope_resetValidFreepointers( );
unsigned long SgDeclarationScope_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRangeBasedForStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRangeBasedForStatement* SgRangeBasedForStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRangeBasedForStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRangeBasedForStatement* SgRangeBasedForStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRangeBasedForStatement* SgRangeBasedForStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRangeBasedForStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRangeBasedForStatement_clearMemoryPool ( );
void SgRangeBasedForStatement_extendMemoryPoolForFileIO ( );
unsigned long SgRangeBasedForStatement_initializeStorageClassArray( SgRangeBasedForStatementStorageClass *storageArray );
void SgRangeBasedForStatement_resetValidFreepointers( );
unsigned long SgRangeBasedForStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJovialForThenStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJovialForThenStatement* SgJovialForThenStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJovialForThenStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJovialForThenStatement* SgJovialForThenStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJovialForThenStatement* SgJovialForThenStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJovialForThenStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJovialForThenStatement_clearMemoryPool ( );
void SgJovialForThenStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJovialForThenStatement_initializeStorageClassArray( SgJovialForThenStatementStorageClass *storageArray );
void SgJovialForThenStatement_resetValidFreepointers( );
unsigned long SgJovialForThenStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaAcceptStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaAcceptStmt* SgAdaAcceptStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaAcceptStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaAcceptStmt* SgAdaAcceptStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaAcceptStmt* SgAdaAcceptStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaAcceptStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaAcceptStmt_clearMemoryPool ( );
void SgAdaAcceptStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAdaAcceptStmt_initializeStorageClassArray( SgAdaAcceptStmtStorageClass *storageArray );
void SgAdaAcceptStmt_resetValidFreepointers( );
unsigned long SgAdaAcceptStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaPackageSpec_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaPackageSpec* SgAdaPackageSpec_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaPackageSpec_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaPackageSpec* SgAdaPackageSpec_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaPackageSpec* SgAdaPackageSpec_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaPackageSpec_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaPackageSpec_clearMemoryPool ( );
void SgAdaPackageSpec_extendMemoryPoolForFileIO ( );
unsigned long SgAdaPackageSpec_initializeStorageClassArray( SgAdaPackageSpecStorageClass *storageArray );
void SgAdaPackageSpec_resetValidFreepointers( );
unsigned long SgAdaPackageSpec_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaPackageBody_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaPackageBody* SgAdaPackageBody_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaPackageBody_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaPackageBody* SgAdaPackageBody_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaPackageBody* SgAdaPackageBody_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaPackageBody_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaPackageBody_clearMemoryPool ( );
void SgAdaPackageBody_extendMemoryPoolForFileIO ( );
unsigned long SgAdaPackageBody_initializeStorageClassArray( SgAdaPackageBodyStorageClass *storageArray );
void SgAdaPackageBody_resetValidFreepointers( );
unsigned long SgAdaPackageBody_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaTaskSpec_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaTaskSpec* SgAdaTaskSpec_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaTaskSpec_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaTaskSpec* SgAdaTaskSpec_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaTaskSpec* SgAdaTaskSpec_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaTaskSpec_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaTaskSpec_clearMemoryPool ( );
void SgAdaTaskSpec_extendMemoryPoolForFileIO ( );
unsigned long SgAdaTaskSpec_initializeStorageClassArray( SgAdaTaskSpecStorageClass *storageArray );
void SgAdaTaskSpec_resetValidFreepointers( );
unsigned long SgAdaTaskSpec_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaTaskBody_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaTaskBody* SgAdaTaskBody_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaTaskBody_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaTaskBody* SgAdaTaskBody_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaTaskBody* SgAdaTaskBody_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaTaskBody_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaTaskBody_clearMemoryPool ( );
void SgAdaTaskBody_extendMemoryPoolForFileIO ( );
unsigned long SgAdaTaskBody_initializeStorageClassArray( SgAdaTaskBodyStorageClass *storageArray );
void SgAdaTaskBody_resetValidFreepointers( );
unsigned long SgAdaTaskBody_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionTypeTable_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionTypeTable* SgFunctionTypeTable_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionTypeTable_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionTypeTable* SgFunctionTypeTable_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionTypeTable* SgFunctionTypeTable_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionTypeTable_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionTypeTable_clearMemoryPool ( );
void SgFunctionTypeTable_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionTypeTable_initializeStorageClassArray( SgFunctionTypeTableStorageClass *storageArray );
void SgFunctionTypeTable_resetValidFreepointers( );
unsigned long SgFunctionTypeTable_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeclarationStatement* SgDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeclarationStatement* SgDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeclarationStatement* SgDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeclarationStatement_clearMemoryPool ( );
void SgDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgDeclarationStatement_initializeStorageClassArray( SgDeclarationStatementStorageClass *storageArray );
void SgDeclarationStatement_resetValidFreepointers( );
unsigned long SgDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionParameterList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionParameterList* SgFunctionParameterList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionParameterList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionParameterList* SgFunctionParameterList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionParameterList* SgFunctionParameterList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionParameterList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionParameterList_clearMemoryPool ( );
void SgFunctionParameterList_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionParameterList_initializeStorageClassArray( SgFunctionParameterListStorageClass *storageArray );
void SgFunctionParameterList_resetValidFreepointers( );
unsigned long SgFunctionParameterList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVariableDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVariableDeclaration* SgVariableDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVariableDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVariableDeclaration* SgVariableDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVariableDeclaration* SgVariableDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVariableDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVariableDeclaration_clearMemoryPool ( );
void SgVariableDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgVariableDeclaration_initializeStorageClassArray( SgVariableDeclarationStorageClass *storageArray );
void SgVariableDeclaration_resetValidFreepointers( );
unsigned long SgVariableDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateVariableDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateVariableDeclaration* SgTemplateVariableDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateVariableDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateVariableDeclaration* SgTemplateVariableDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateVariableDeclaration* SgTemplateVariableDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateVariableDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateVariableDeclaration_clearMemoryPool ( );
void SgTemplateVariableDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateVariableDeclaration_initializeStorageClassArray( SgTemplateVariableDeclarationStorageClass *storageArray );
void SgTemplateVariableDeclaration_resetValidFreepointers( );
unsigned long SgTemplateVariableDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVariableDefinition_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVariableDefinition* SgVariableDefinition_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVariableDefinition_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVariableDefinition* SgVariableDefinition_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVariableDefinition* SgVariableDefinition_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVariableDefinition_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVariableDefinition_clearMemoryPool ( );
void SgVariableDefinition_extendMemoryPoolForFileIO ( );
unsigned long SgVariableDefinition_initializeStorageClassArray( SgVariableDefinitionStorageClass *storageArray );
void SgVariableDefinition_resetValidFreepointers( );
unsigned long SgVariableDefinition_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClinkageDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClinkageDeclarationStatement* SgClinkageDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClinkageDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClinkageDeclarationStatement* SgClinkageDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClinkageDeclarationStatement* SgClinkageDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClinkageDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClinkageDeclarationStatement_clearMemoryPool ( );
void SgClinkageDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgClinkageDeclarationStatement_initializeStorageClassArray( SgClinkageDeclarationStatementStorageClass *storageArray );
void SgClinkageDeclarationStatement_resetValidFreepointers( );
unsigned long SgClinkageDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClinkageStartStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClinkageStartStatement* SgClinkageStartStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClinkageStartStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClinkageStartStatement* SgClinkageStartStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClinkageStartStatement* SgClinkageStartStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClinkageStartStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClinkageStartStatement_clearMemoryPool ( );
void SgClinkageStartStatement_extendMemoryPoolForFileIO ( );
unsigned long SgClinkageStartStatement_initializeStorageClassArray( SgClinkageStartStatementStorageClass *storageArray );
void SgClinkageStartStatement_resetValidFreepointers( );
unsigned long SgClinkageStartStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClinkageEndStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClinkageEndStatement* SgClinkageEndStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClinkageEndStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClinkageEndStatement* SgClinkageEndStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClinkageEndStatement* SgClinkageEndStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClinkageEndStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClinkageEndStatement_clearMemoryPool ( );
void SgClinkageEndStatement_extendMemoryPoolForFileIO ( );
unsigned long SgClinkageEndStatement_initializeStorageClassArray( SgClinkageEndStatementStorageClass *storageArray );
void SgClinkageEndStatement_resetValidFreepointers( );
unsigned long SgClinkageEndStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEnumDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEnumDeclaration* SgEnumDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEnumDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEnumDeclaration* SgEnumDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEnumDeclaration* SgEnumDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEnumDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEnumDeclaration_clearMemoryPool ( );
void SgEnumDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgEnumDeclaration_initializeStorageClassArray( SgEnumDeclarationStorageClass *storageArray );
void SgEnumDeclaration_resetValidFreepointers( );
unsigned long SgEnumDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmStmt* SgAsmStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmStmt* SgAsmStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmStmt* SgAsmStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmStmt_clearMemoryPool ( );
void SgAsmStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAsmStmt_initializeStorageClassArray( SgAsmStmtStorageClass *storageArray );
void SgAsmStmt_resetValidFreepointers( );
unsigned long SgAsmStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAttributeSpecificationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAttributeSpecificationStatement* SgAttributeSpecificationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAttributeSpecificationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAttributeSpecificationStatement* SgAttributeSpecificationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAttributeSpecificationStatement* SgAttributeSpecificationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAttributeSpecificationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAttributeSpecificationStatement_clearMemoryPool ( );
void SgAttributeSpecificationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAttributeSpecificationStatement_initializeStorageClassArray( SgAttributeSpecificationStatementStorageClass *storageArray );
void SgAttributeSpecificationStatement_resetValidFreepointers( );
unsigned long SgAttributeSpecificationStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFormatStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFormatStatement* SgFormatStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFormatStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFormatStatement* SgFormatStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFormatStatement* SgFormatStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFormatStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFormatStatement_clearMemoryPool ( );
void SgFormatStatement_extendMemoryPoolForFileIO ( );
unsigned long SgFormatStatement_initializeStorageClassArray( SgFormatStatementStorageClass *storageArray );
void SgFormatStatement_resetValidFreepointers( );
unsigned long SgFormatStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateDeclaration* SgTemplateDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateDeclaration* SgTemplateDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateDeclaration* SgTemplateDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateDeclaration_clearMemoryPool ( );
void SgTemplateDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateDeclaration_initializeStorageClassArray( SgTemplateDeclarationStorageClass *storageArray );
void SgTemplateDeclaration_resetValidFreepointers( );
unsigned long SgTemplateDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationDirectiveStatement* SgTemplateInstantiationDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationDirectiveStatement* SgTemplateInstantiationDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationDirectiveStatement* SgTemplateInstantiationDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationDirectiveStatement_clearMemoryPool ( );
void SgTemplateInstantiationDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationDirectiveStatement_initializeStorageClassArray( SgTemplateInstantiationDirectiveStatementStorageClass *storageArray );
void SgTemplateInstantiationDirectiveStatement_resetValidFreepointers( );
unsigned long SgTemplateInstantiationDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUseStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUseStatement* SgUseStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUseStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUseStatement* SgUseStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUseStatement* SgUseStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUseStatement_clearMemoryPool ( );
void SgUseStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUseStatement_initializeStorageClassArray( SgUseStatementStorageClass *storageArray );
void SgUseStatement_resetValidFreepointers( );
unsigned long SgUseStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgParameterStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgParameterStatement* SgParameterStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgParameterStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgParameterStatement* SgParameterStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgParameterStatement* SgParameterStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgParameterStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgParameterStatement_clearMemoryPool ( );
void SgParameterStatement_extendMemoryPoolForFileIO ( );
unsigned long SgParameterStatement_initializeStorageClassArray( SgParameterStatementStorageClass *storageArray );
void SgParameterStatement_resetValidFreepointers( );
unsigned long SgParameterStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamespaceDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamespaceDeclarationStatement* SgNamespaceDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamespaceDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamespaceDeclarationStatement* SgNamespaceDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamespaceDeclarationStatement* SgNamespaceDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamespaceDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamespaceDeclarationStatement_clearMemoryPool ( );
void SgNamespaceDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNamespaceDeclarationStatement_initializeStorageClassArray( SgNamespaceDeclarationStatementStorageClass *storageArray );
void SgNamespaceDeclarationStatement_resetValidFreepointers( );
unsigned long SgNamespaceDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEquivalenceStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEquivalenceStatement* SgEquivalenceStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEquivalenceStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEquivalenceStatement* SgEquivalenceStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEquivalenceStatement* SgEquivalenceStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEquivalenceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEquivalenceStatement_clearMemoryPool ( );
void SgEquivalenceStatement_extendMemoryPoolForFileIO ( );
unsigned long SgEquivalenceStatement_initializeStorageClassArray( SgEquivalenceStatementStorageClass *storageArray );
void SgEquivalenceStatement_resetValidFreepointers( );
unsigned long SgEquivalenceStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInterfaceStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInterfaceStatement* SgInterfaceStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInterfaceStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInterfaceStatement* SgInterfaceStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInterfaceStatement* SgInterfaceStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInterfaceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInterfaceStatement_clearMemoryPool ( );
void SgInterfaceStatement_extendMemoryPoolForFileIO ( );
unsigned long SgInterfaceStatement_initializeStorageClassArray( SgInterfaceStatementStorageClass *storageArray );
void SgInterfaceStatement_resetValidFreepointers( );
unsigned long SgInterfaceStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamespaceAliasDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamespaceAliasDeclarationStatement* SgNamespaceAliasDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamespaceAliasDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamespaceAliasDeclarationStatement* SgNamespaceAliasDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamespaceAliasDeclarationStatement* SgNamespaceAliasDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamespaceAliasDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamespaceAliasDeclarationStatement_clearMemoryPool ( );
void SgNamespaceAliasDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNamespaceAliasDeclarationStatement_initializeStorageClassArray( SgNamespaceAliasDeclarationStatementStorageClass *storageArray );
void SgNamespaceAliasDeclarationStatement_resetValidFreepointers( );
unsigned long SgNamespaceAliasDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCommonBlock_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCommonBlock* SgCommonBlock_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCommonBlock_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCommonBlock* SgCommonBlock_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCommonBlock* SgCommonBlock_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCommonBlock_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCommonBlock_clearMemoryPool ( );
void SgCommonBlock_extendMemoryPoolForFileIO ( );
unsigned long SgCommonBlock_initializeStorageClassArray( SgCommonBlockStorageClass *storageArray );
void SgCommonBlock_resetValidFreepointers( );
unsigned long SgCommonBlock_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypedefDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypedefDeclaration* SgTypedefDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypedefDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypedefDeclaration* SgTypedefDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypedefDeclaration* SgTypedefDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypedefDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypedefDeclaration_clearMemoryPool ( );
void SgTypedefDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTypedefDeclaration_initializeStorageClassArray( SgTypedefDeclarationStorageClass *storageArray );
void SgTypedefDeclaration_resetValidFreepointers( );
unsigned long SgTypedefDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateTypedefDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateTypedefDeclaration* SgTemplateTypedefDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateTypedefDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateTypedefDeclaration* SgTemplateTypedefDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateTypedefDeclaration* SgTemplateTypedefDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateTypedefDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateTypedefDeclaration_clearMemoryPool ( );
void SgTemplateTypedefDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateTypedefDeclaration_initializeStorageClassArray( SgTemplateTypedefDeclarationStorageClass *storageArray );
void SgTemplateTypedefDeclaration_resetValidFreepointers( );
unsigned long SgTemplateTypedefDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationTypedefDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationTypedefDeclaration* SgTemplateInstantiationTypedefDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationTypedefDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationTypedefDeclaration* SgTemplateInstantiationTypedefDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationTypedefDeclaration* SgTemplateInstantiationTypedefDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationTypedefDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationTypedefDeclaration_clearMemoryPool ( );
void SgTemplateInstantiationTypedefDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationTypedefDeclaration_initializeStorageClassArray( SgTemplateInstantiationTypedefDeclarationStorageClass *storageArray );
void SgTemplateInstantiationTypedefDeclaration_resetValidFreepointers( );
unsigned long SgTemplateInstantiationTypedefDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStatementFunctionStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStatementFunctionStatement* SgStatementFunctionStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStatementFunctionStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStatementFunctionStatement* SgStatementFunctionStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStatementFunctionStatement* SgStatementFunctionStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStatementFunctionStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStatementFunctionStatement_clearMemoryPool ( );
void SgStatementFunctionStatement_extendMemoryPoolForFileIO ( );
unsigned long SgStatementFunctionStatement_initializeStorageClassArray( SgStatementFunctionStatementStorageClass *storageArray );
void SgStatementFunctionStatement_resetValidFreepointers( );
unsigned long SgStatementFunctionStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCtorInitializerList_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCtorInitializerList* SgCtorInitializerList_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCtorInitializerList_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCtorInitializerList* SgCtorInitializerList_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCtorInitializerList* SgCtorInitializerList_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCtorInitializerList_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCtorInitializerList_clearMemoryPool ( );
void SgCtorInitializerList_extendMemoryPoolForFileIO ( );
unsigned long SgCtorInitializerList_initializeStorageClassArray( SgCtorInitializerListStorageClass *storageArray );
void SgCtorInitializerList_resetValidFreepointers( );
unsigned long SgCtorInitializerList_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPragmaDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPragmaDeclaration* SgPragmaDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPragmaDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPragmaDeclaration* SgPragmaDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPragmaDeclaration* SgPragmaDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPragmaDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPragmaDeclaration_clearMemoryPool ( );
void SgPragmaDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgPragmaDeclaration_initializeStorageClassArray( SgPragmaDeclarationStorageClass *storageArray );
void SgPragmaDeclaration_resetValidFreepointers( );
unsigned long SgPragmaDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUsingDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUsingDirectiveStatement* SgUsingDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUsingDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUsingDirectiveStatement* SgUsingDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUsingDirectiveStatement* SgUsingDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUsingDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUsingDirectiveStatement_clearMemoryPool ( );
void SgUsingDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUsingDirectiveStatement_initializeStorageClassArray( SgUsingDirectiveStatementStorageClass *storageArray );
void SgUsingDirectiveStatement_resetValidFreepointers( );
unsigned long SgUsingDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassDeclaration* SgClassDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassDeclaration* SgClassDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassDeclaration* SgClassDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassDeclaration_clearMemoryPool ( );
void SgClassDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgClassDeclaration_initializeStorageClassArray( SgClassDeclarationStorageClass *storageArray );
void SgClassDeclaration_resetValidFreepointers( );
unsigned long SgClassDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateClassDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateClassDeclaration* SgTemplateClassDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateClassDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateClassDeclaration* SgTemplateClassDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateClassDeclaration* SgTemplateClassDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateClassDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateClassDeclaration_clearMemoryPool ( );
void SgTemplateClassDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateClassDeclaration_initializeStorageClassArray( SgTemplateClassDeclarationStorageClass *storageArray );
void SgTemplateClassDeclaration_resetValidFreepointers( );
unsigned long SgTemplateClassDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationDecl* SgTemplateInstantiationDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationDecl* SgTemplateInstantiationDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationDecl* SgTemplateInstantiationDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationDecl_clearMemoryPool ( );
void SgTemplateInstantiationDecl_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationDecl_initializeStorageClassArray( SgTemplateInstantiationDeclStorageClass *storageArray );
void SgTemplateInstantiationDecl_resetValidFreepointers( );
unsigned long SgTemplateInstantiationDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDerivedTypeStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDerivedTypeStatement* SgDerivedTypeStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDerivedTypeStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDerivedTypeStatement* SgDerivedTypeStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDerivedTypeStatement* SgDerivedTypeStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDerivedTypeStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDerivedTypeStatement_clearMemoryPool ( );
void SgDerivedTypeStatement_extendMemoryPoolForFileIO ( );
unsigned long SgDerivedTypeStatement_initializeStorageClassArray( SgDerivedTypeStatementStorageClass *storageArray );
void SgDerivedTypeStatement_resetValidFreepointers( );
unsigned long SgDerivedTypeStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModuleStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModuleStatement* SgModuleStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModuleStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModuleStatement* SgModuleStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModuleStatement* SgModuleStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModuleStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModuleStatement_clearMemoryPool ( );
void SgModuleStatement_extendMemoryPoolForFileIO ( );
unsigned long SgModuleStatement_initializeStorageClassArray( SgModuleStatementStorageClass *storageArray );
void SgModuleStatement_resetValidFreepointers( );
unsigned long SgModuleStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaPackageDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaPackageDeclaration* SgJavaPackageDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaPackageDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaPackageDeclaration* SgJavaPackageDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaPackageDeclaration* SgJavaPackageDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaPackageDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaPackageDeclaration_clearMemoryPool ( );
void SgJavaPackageDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgJavaPackageDeclaration_initializeStorageClassArray( SgJavaPackageDeclarationStorageClass *storageArray );
void SgJavaPackageDeclaration_resetValidFreepointers( );
unsigned long SgJavaPackageDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJovialTableStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJovialTableStatement* SgJovialTableStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJovialTableStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJovialTableStatement* SgJovialTableStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJovialTableStatement* SgJovialTableStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJovialTableStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJovialTableStatement_clearMemoryPool ( );
void SgJovialTableStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJovialTableStatement_initializeStorageClassArray( SgJovialTableStatementStorageClass *storageArray );
void SgJovialTableStatement_resetValidFreepointers( );
unsigned long SgJovialTableStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgImplicitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgImplicitStatement* SgImplicitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgImplicitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgImplicitStatement* SgImplicitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgImplicitStatement* SgImplicitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgImplicitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgImplicitStatement_clearMemoryPool ( );
void SgImplicitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgImplicitStatement_initializeStorageClassArray( SgImplicitStatementStorageClass *storageArray );
void SgImplicitStatement_resetValidFreepointers( );
unsigned long SgImplicitStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUsingDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUsingDeclarationStatement* SgUsingDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUsingDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUsingDeclarationStatement* SgUsingDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUsingDeclarationStatement* SgUsingDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUsingDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUsingDeclarationStatement_clearMemoryPool ( );
void SgUsingDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUsingDeclarationStatement_initializeStorageClassArray( SgUsingDeclarationStatementStorageClass *storageArray );
void SgUsingDeclarationStatement_resetValidFreepointers( );
unsigned long SgUsingDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamelistStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamelistStatement* SgNamelistStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamelistStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamelistStatement* SgNamelistStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamelistStatement* SgNamelistStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamelistStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamelistStatement_clearMemoryPool ( );
void SgNamelistStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNamelistStatement_initializeStorageClassArray( SgNamelistStatementStorageClass *storageArray );
void SgNamelistStatement_resetValidFreepointers( );
unsigned long SgNamelistStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgImportStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgImportStatement* SgImportStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgImportStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgImportStatement* SgImportStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgImportStatement* SgImportStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgImportStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgImportStatement_clearMemoryPool ( );
void SgImportStatement_extendMemoryPoolForFileIO ( );
unsigned long SgImportStatement_initializeStorageClassArray( SgImportStatementStorageClass *storageArray );
void SgImportStatement_resetValidFreepointers( );
unsigned long SgImportStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionDeclaration* SgFunctionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionDeclaration* SgFunctionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionDeclaration* SgFunctionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionDeclaration_clearMemoryPool ( );
void SgFunctionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionDeclaration_initializeStorageClassArray( SgFunctionDeclarationStorageClass *storageArray );
void SgFunctionDeclaration_resetValidFreepointers( );
unsigned long SgFunctionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateFunctionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateFunctionDeclaration* SgTemplateFunctionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateFunctionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateFunctionDeclaration* SgTemplateFunctionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateFunctionDeclaration* SgTemplateFunctionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateFunctionDeclaration_clearMemoryPool ( );
void SgTemplateFunctionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateFunctionDeclaration_initializeStorageClassArray( SgTemplateFunctionDeclarationStorageClass *storageArray );
void SgTemplateFunctionDeclaration_resetValidFreepointers( );
unsigned long SgTemplateFunctionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMemberFunctionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMemberFunctionDeclaration* SgMemberFunctionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMemberFunctionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMemberFunctionDeclaration* SgMemberFunctionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMemberFunctionDeclaration* SgMemberFunctionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMemberFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMemberFunctionDeclaration_clearMemoryPool ( );
void SgMemberFunctionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgMemberFunctionDeclaration_initializeStorageClassArray( SgMemberFunctionDeclarationStorageClass *storageArray );
void SgMemberFunctionDeclaration_resetValidFreepointers( );
unsigned long SgMemberFunctionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateMemberFunctionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateMemberFunctionDeclaration* SgTemplateMemberFunctionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateMemberFunctionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateMemberFunctionDeclaration* SgTemplateMemberFunctionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateMemberFunctionDeclaration* SgTemplateMemberFunctionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateMemberFunctionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateMemberFunctionDeclaration_clearMemoryPool ( );
void SgTemplateMemberFunctionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateMemberFunctionDeclaration_initializeStorageClassArray( SgTemplateMemberFunctionDeclarationStorageClass *storageArray );
void SgTemplateMemberFunctionDeclaration_resetValidFreepointers( );
unsigned long SgTemplateMemberFunctionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationMemberFunctionDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationMemberFunctionDecl* SgTemplateInstantiationMemberFunctionDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationMemberFunctionDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationMemberFunctionDecl* SgTemplateInstantiationMemberFunctionDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationMemberFunctionDecl* SgTemplateInstantiationMemberFunctionDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationMemberFunctionDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationMemberFunctionDecl_clearMemoryPool ( );
void SgTemplateInstantiationMemberFunctionDecl_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationMemberFunctionDecl_initializeStorageClassArray( SgTemplateInstantiationMemberFunctionDeclStorageClass *storageArray );
void SgTemplateInstantiationMemberFunctionDecl_resetValidFreepointers( );
unsigned long SgTemplateInstantiationMemberFunctionDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateInstantiationFunctionDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateInstantiationFunctionDecl* SgTemplateInstantiationFunctionDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateInstantiationFunctionDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateInstantiationFunctionDecl* SgTemplateInstantiationFunctionDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateInstantiationFunctionDecl* SgTemplateInstantiationFunctionDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateInstantiationFunctionDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateInstantiationFunctionDecl_clearMemoryPool ( );
void SgTemplateInstantiationFunctionDecl_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateInstantiationFunctionDecl_initializeStorageClassArray( SgTemplateInstantiationFunctionDeclStorageClass *storageArray );
void SgTemplateInstantiationFunctionDecl_resetValidFreepointers( );
unsigned long SgTemplateInstantiationFunctionDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgProgramHeaderStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgProgramHeaderStatement* SgProgramHeaderStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgProgramHeaderStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgProgramHeaderStatement* SgProgramHeaderStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgProgramHeaderStatement* SgProgramHeaderStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgProgramHeaderStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgProgramHeaderStatement_clearMemoryPool ( );
void SgProgramHeaderStatement_extendMemoryPoolForFileIO ( );
unsigned long SgProgramHeaderStatement_initializeStorageClassArray( SgProgramHeaderStatementStorageClass *storageArray );
void SgProgramHeaderStatement_resetValidFreepointers( );
unsigned long SgProgramHeaderStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgProcedureHeaderStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgProcedureHeaderStatement* SgProcedureHeaderStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgProcedureHeaderStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgProcedureHeaderStatement* SgProcedureHeaderStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgProcedureHeaderStatement* SgProcedureHeaderStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgProcedureHeaderStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgProcedureHeaderStatement_clearMemoryPool ( );
void SgProcedureHeaderStatement_extendMemoryPoolForFileIO ( );
unsigned long SgProcedureHeaderStatement_initializeStorageClassArray( SgProcedureHeaderStatementStorageClass *storageArray );
void SgProcedureHeaderStatement_resetValidFreepointers( );
unsigned long SgProcedureHeaderStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEntryStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEntryStatement* SgEntryStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEntryStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEntryStatement* SgEntryStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEntryStatement* SgEntryStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEntryStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEntryStatement_clearMemoryPool ( );
void SgEntryStatement_extendMemoryPoolForFileIO ( );
unsigned long SgEntryStatement_initializeStorageClassArray( SgEntryStatementStorageClass *storageArray );
void SgEntryStatement_resetValidFreepointers( );
unsigned long SgEntryStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaEntryDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaEntryDecl* SgAdaEntryDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaEntryDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaEntryDecl* SgAdaEntryDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaEntryDecl* SgAdaEntryDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaEntryDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaEntryDecl_clearMemoryPool ( );
void SgAdaEntryDecl_extendMemoryPoolForFileIO ( );
unsigned long SgAdaEntryDecl_initializeStorageClassArray( SgAdaEntryDeclStorageClass *storageArray );
void SgAdaEntryDecl_resetValidFreepointers( );
unsigned long SgAdaEntryDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgContainsStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgContainsStatement* SgContainsStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgContainsStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgContainsStatement* SgContainsStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgContainsStatement* SgContainsStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgContainsStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgContainsStatement_clearMemoryPool ( );
void SgContainsStatement_extendMemoryPoolForFileIO ( );
unsigned long SgContainsStatement_initializeStorageClassArray( SgContainsStatementStorageClass *storageArray );
void SgContainsStatement_resetValidFreepointers( );
unsigned long SgContainsStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgC_PreprocessorDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgC_PreprocessorDirectiveStatement* SgC_PreprocessorDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgC_PreprocessorDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgC_PreprocessorDirectiveStatement* SgC_PreprocessorDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgC_PreprocessorDirectiveStatement* SgC_PreprocessorDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgC_PreprocessorDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgC_PreprocessorDirectiveStatement_clearMemoryPool ( );
void SgC_PreprocessorDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgC_PreprocessorDirectiveStatement_initializeStorageClassArray( SgC_PreprocessorDirectiveStatementStorageClass *storageArray );
void SgC_PreprocessorDirectiveStatement_resetValidFreepointers( );
unsigned long SgC_PreprocessorDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIncludeDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIncludeDirectiveStatement* SgIncludeDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIncludeDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIncludeDirectiveStatement* SgIncludeDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIncludeDirectiveStatement* SgIncludeDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIncludeDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIncludeDirectiveStatement_clearMemoryPool ( );
void SgIncludeDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIncludeDirectiveStatement_initializeStorageClassArray( SgIncludeDirectiveStatementStorageClass *storageArray );
void SgIncludeDirectiveStatement_resetValidFreepointers( );
unsigned long SgIncludeDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDefineDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDefineDirectiveStatement* SgDefineDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDefineDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDefineDirectiveStatement* SgDefineDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDefineDirectiveStatement* SgDefineDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDefineDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDefineDirectiveStatement_clearMemoryPool ( );
void SgDefineDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgDefineDirectiveStatement_initializeStorageClassArray( SgDefineDirectiveStatementStorageClass *storageArray );
void SgDefineDirectiveStatement_resetValidFreepointers( );
unsigned long SgDefineDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUndefDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUndefDirectiveStatement* SgUndefDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUndefDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUndefDirectiveStatement* SgUndefDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUndefDirectiveStatement* SgUndefDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUndefDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUndefDirectiveStatement_clearMemoryPool ( );
void SgUndefDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUndefDirectiveStatement_initializeStorageClassArray( SgUndefDirectiveStatementStorageClass *storageArray );
void SgUndefDirectiveStatement_resetValidFreepointers( );
unsigned long SgUndefDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIfdefDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIfdefDirectiveStatement* SgIfdefDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIfdefDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIfdefDirectiveStatement* SgIfdefDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIfdefDirectiveStatement* SgIfdefDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIfdefDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIfdefDirectiveStatement_clearMemoryPool ( );
void SgIfdefDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIfdefDirectiveStatement_initializeStorageClassArray( SgIfdefDirectiveStatementStorageClass *storageArray );
void SgIfdefDirectiveStatement_resetValidFreepointers( );
unsigned long SgIfdefDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIfndefDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIfndefDirectiveStatement* SgIfndefDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIfndefDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIfndefDirectiveStatement* SgIfndefDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIfndefDirectiveStatement* SgIfndefDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIfndefDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIfndefDirectiveStatement_clearMemoryPool ( );
void SgIfndefDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIfndefDirectiveStatement_initializeStorageClassArray( SgIfndefDirectiveStatementStorageClass *storageArray );
void SgIfndefDirectiveStatement_resetValidFreepointers( );
unsigned long SgIfndefDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIfDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIfDirectiveStatement* SgIfDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIfDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIfDirectiveStatement* SgIfDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIfDirectiveStatement* SgIfDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIfDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIfDirectiveStatement_clearMemoryPool ( );
void SgIfDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIfDirectiveStatement_initializeStorageClassArray( SgIfDirectiveStatementStorageClass *storageArray );
void SgIfDirectiveStatement_resetValidFreepointers( );
unsigned long SgIfDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeadIfDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeadIfDirectiveStatement* SgDeadIfDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeadIfDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeadIfDirectiveStatement* SgDeadIfDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeadIfDirectiveStatement* SgDeadIfDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeadIfDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeadIfDirectiveStatement_clearMemoryPool ( );
void SgDeadIfDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgDeadIfDirectiveStatement_initializeStorageClassArray( SgDeadIfDirectiveStatementStorageClass *storageArray );
void SgDeadIfDirectiveStatement_resetValidFreepointers( );
unsigned long SgDeadIfDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElseDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElseDirectiveStatement* SgElseDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElseDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElseDirectiveStatement* SgElseDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElseDirectiveStatement* SgElseDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElseDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElseDirectiveStatement_clearMemoryPool ( );
void SgElseDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgElseDirectiveStatement_initializeStorageClassArray( SgElseDirectiveStatementStorageClass *storageArray );
void SgElseDirectiveStatement_resetValidFreepointers( );
unsigned long SgElseDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElseifDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElseifDirectiveStatement* SgElseifDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElseifDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElseifDirectiveStatement* SgElseifDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElseifDirectiveStatement* SgElseifDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElseifDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElseifDirectiveStatement_clearMemoryPool ( );
void SgElseifDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgElseifDirectiveStatement_initializeStorageClassArray( SgElseifDirectiveStatementStorageClass *storageArray );
void SgElseifDirectiveStatement_resetValidFreepointers( );
unsigned long SgElseifDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEndifDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEndifDirectiveStatement* SgEndifDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEndifDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEndifDirectiveStatement* SgEndifDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEndifDirectiveStatement* SgEndifDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEndifDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEndifDirectiveStatement_clearMemoryPool ( );
void SgEndifDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgEndifDirectiveStatement_initializeStorageClassArray( SgEndifDirectiveStatementStorageClass *storageArray );
void SgEndifDirectiveStatement_resetValidFreepointers( );
unsigned long SgEndifDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLineDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLineDirectiveStatement* SgLineDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLineDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLineDirectiveStatement* SgLineDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLineDirectiveStatement* SgLineDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLineDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLineDirectiveStatement_clearMemoryPool ( );
void SgLineDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgLineDirectiveStatement_initializeStorageClassArray( SgLineDirectiveStatementStorageClass *storageArray );
void SgLineDirectiveStatement_resetValidFreepointers( );
unsigned long SgLineDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWarningDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWarningDirectiveStatement* SgWarningDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWarningDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWarningDirectiveStatement* SgWarningDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWarningDirectiveStatement* SgWarningDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWarningDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWarningDirectiveStatement_clearMemoryPool ( );
void SgWarningDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgWarningDirectiveStatement_initializeStorageClassArray( SgWarningDirectiveStatementStorageClass *storageArray );
void SgWarningDirectiveStatement_resetValidFreepointers( );
unsigned long SgWarningDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgErrorDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgErrorDirectiveStatement* SgErrorDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgErrorDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgErrorDirectiveStatement* SgErrorDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgErrorDirectiveStatement* SgErrorDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgErrorDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgErrorDirectiveStatement_clearMemoryPool ( );
void SgErrorDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgErrorDirectiveStatement_initializeStorageClassArray( SgErrorDirectiveStatementStorageClass *storageArray );
void SgErrorDirectiveStatement_resetValidFreepointers( );
unsigned long SgErrorDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEmptyDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEmptyDirectiveStatement* SgEmptyDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEmptyDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEmptyDirectiveStatement* SgEmptyDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEmptyDirectiveStatement* SgEmptyDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEmptyDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEmptyDirectiveStatement_clearMemoryPool ( );
void SgEmptyDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgEmptyDirectiveStatement_initializeStorageClassArray( SgEmptyDirectiveStatementStorageClass *storageArray );
void SgEmptyDirectiveStatement_resetValidFreepointers( );
unsigned long SgEmptyDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIncludeNextDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIncludeNextDirectiveStatement* SgIncludeNextDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIncludeNextDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIncludeNextDirectiveStatement* SgIncludeNextDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIncludeNextDirectiveStatement* SgIncludeNextDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIncludeNextDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIncludeNextDirectiveStatement_clearMemoryPool ( );
void SgIncludeNextDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIncludeNextDirectiveStatement_initializeStorageClassArray( SgIncludeNextDirectiveStatementStorageClass *storageArray );
void SgIncludeNextDirectiveStatement_resetValidFreepointers( );
unsigned long SgIncludeNextDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIdentDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIdentDirectiveStatement* SgIdentDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIdentDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIdentDirectiveStatement* SgIdentDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIdentDirectiveStatement* SgIdentDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIdentDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIdentDirectiveStatement_clearMemoryPool ( );
void SgIdentDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIdentDirectiveStatement_initializeStorageClassArray( SgIdentDirectiveStatementStorageClass *storageArray );
void SgIdentDirectiveStatement_resetValidFreepointers( );
unsigned long SgIdentDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLinemarkerDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLinemarkerDirectiveStatement* SgLinemarkerDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLinemarkerDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLinemarkerDirectiveStatement* SgLinemarkerDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLinemarkerDirectiveStatement* SgLinemarkerDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLinemarkerDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLinemarkerDirectiveStatement_clearMemoryPool ( );
void SgLinemarkerDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgLinemarkerDirectiveStatement_initializeStorageClassArray( SgLinemarkerDirectiveStatementStorageClass *storageArray );
void SgLinemarkerDirectiveStatement_resetValidFreepointers( );
unsigned long SgLinemarkerDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpThreadprivateStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpThreadprivateStatement* SgOmpThreadprivateStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpThreadprivateStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpThreadprivateStatement* SgOmpThreadprivateStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpThreadprivateStatement* SgOmpThreadprivateStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpThreadprivateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpThreadprivateStatement_clearMemoryPool ( );
void SgOmpThreadprivateStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpThreadprivateStatement_initializeStorageClassArray( SgOmpThreadprivateStatementStorageClass *storageArray );
void SgOmpThreadprivateStatement_resetValidFreepointers( );
unsigned long SgOmpThreadprivateStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFortranIncludeLine_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFortranIncludeLine* SgFortranIncludeLine_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFortranIncludeLine_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFortranIncludeLine* SgFortranIncludeLine_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFortranIncludeLine* SgFortranIncludeLine_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFortranIncludeLine_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFortranIncludeLine_clearMemoryPool ( );
void SgFortranIncludeLine_extendMemoryPoolForFileIO ( );
unsigned long SgFortranIncludeLine_initializeStorageClassArray( SgFortranIncludeLineStorageClass *storageArray );
void SgFortranIncludeLine_resetValidFreepointers( );
unsigned long SgFortranIncludeLine_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaImportStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaImportStatement* SgJavaImportStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaImportStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaImportStatement* SgJavaImportStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaImportStatement* SgJavaImportStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaImportStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaImportStatement_clearMemoryPool ( );
void SgJavaImportStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaImportStatement_initializeStorageClassArray( SgJavaImportStatementStorageClass *storageArray );
void SgJavaImportStatement_resetValidFreepointers( );
unsigned long SgJavaImportStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaPackageStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaPackageStatement* SgJavaPackageStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaPackageStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaPackageStatement* SgJavaPackageStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaPackageStatement* SgJavaPackageStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaPackageStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaPackageStatement_clearMemoryPool ( );
void SgJavaPackageStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaPackageStatement_initializeStorageClassArray( SgJavaPackageStatementStorageClass *storageArray );
void SgJavaPackageStatement_resetValidFreepointers( );
unsigned long SgJavaPackageStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStmtDeclarationStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStmtDeclarationStatement* SgStmtDeclarationStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStmtDeclarationStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStmtDeclarationStatement* SgStmtDeclarationStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStmtDeclarationStatement* SgStmtDeclarationStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStmtDeclarationStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStmtDeclarationStatement_clearMemoryPool ( );
void SgStmtDeclarationStatement_extendMemoryPoolForFileIO ( );
unsigned long SgStmtDeclarationStatement_initializeStorageClassArray( SgStmtDeclarationStatementStorageClass *storageArray );
void SgStmtDeclarationStatement_resetValidFreepointers( );
unsigned long SgStmtDeclarationStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStaticAssertionDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStaticAssertionDeclaration* SgStaticAssertionDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStaticAssertionDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStaticAssertionDeclaration* SgStaticAssertionDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStaticAssertionDeclaration* SgStaticAssertionDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStaticAssertionDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStaticAssertionDeclaration_clearMemoryPool ( );
void SgStaticAssertionDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgStaticAssertionDeclaration_initializeStorageClassArray( SgStaticAssertionDeclarationStorageClass *storageArray );
void SgStaticAssertionDeclaration_resetValidFreepointers( );
unsigned long SgStaticAssertionDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpDeclareSimdStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpDeclareSimdStatement* SgOmpDeclareSimdStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpDeclareSimdStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpDeclareSimdStatement* SgOmpDeclareSimdStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpDeclareSimdStatement* SgOmpDeclareSimdStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpDeclareSimdStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpDeclareSimdStatement_clearMemoryPool ( );
void SgOmpDeclareSimdStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpDeclareSimdStatement_initializeStorageClassArray( SgOmpDeclareSimdStatementStorageClass *storageArray );
void SgOmpDeclareSimdStatement_resetValidFreepointers( );
unsigned long SgOmpDeclareSimdStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMicrosoftAttributeDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMicrosoftAttributeDeclaration* SgMicrosoftAttributeDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMicrosoftAttributeDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMicrosoftAttributeDeclaration* SgMicrosoftAttributeDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMicrosoftAttributeDeclaration* SgMicrosoftAttributeDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMicrosoftAttributeDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMicrosoftAttributeDeclaration_clearMemoryPool ( );
void SgMicrosoftAttributeDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgMicrosoftAttributeDeclaration_initializeStorageClassArray( SgMicrosoftAttributeDeclarationStorageClass *storageArray );
void SgMicrosoftAttributeDeclaration_resetValidFreepointers( );
unsigned long SgMicrosoftAttributeDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJovialCompoolStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJovialCompoolStatement* SgJovialCompoolStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJovialCompoolStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJovialCompoolStatement* SgJovialCompoolStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJovialCompoolStatement* SgJovialCompoolStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJovialCompoolStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJovialCompoolStatement_clearMemoryPool ( );
void SgJovialCompoolStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJovialCompoolStatement_initializeStorageClassArray( SgJovialCompoolStatementStorageClass *storageArray );
void SgJovialCompoolStatement_resetValidFreepointers( );
unsigned long SgJovialCompoolStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJovialDirectiveStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJovialDirectiveStatement* SgJovialDirectiveStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJovialDirectiveStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJovialDirectiveStatement* SgJovialDirectiveStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJovialDirectiveStatement* SgJovialDirectiveStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJovialDirectiveStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJovialDirectiveStatement_clearMemoryPool ( );
void SgJovialDirectiveStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJovialDirectiveStatement_initializeStorageClassArray( SgJovialDirectiveStatementStorageClass *storageArray );
void SgJovialDirectiveStatement_resetValidFreepointers( );
unsigned long SgJovialDirectiveStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJovialDefineDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJovialDefineDeclaration* SgJovialDefineDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJovialDefineDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJovialDefineDeclaration* SgJovialDefineDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJovialDefineDeclaration* SgJovialDefineDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJovialDefineDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJovialDefineDeclaration_clearMemoryPool ( );
void SgJovialDefineDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgJovialDefineDeclaration_initializeStorageClassArray( SgJovialDefineDeclarationStorageClass *storageArray );
void SgJovialDefineDeclaration_resetValidFreepointers( );
unsigned long SgJovialDefineDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJovialOverlayDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJovialOverlayDeclaration* SgJovialOverlayDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJovialOverlayDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJovialOverlayDeclaration* SgJovialOverlayDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJovialOverlayDeclaration* SgJovialOverlayDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJovialOverlayDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJovialOverlayDeclaration_clearMemoryPool ( );
void SgJovialOverlayDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgJovialOverlayDeclaration_initializeStorageClassArray( SgJovialOverlayDeclarationStorageClass *storageArray );
void SgJovialOverlayDeclaration_resetValidFreepointers( );
unsigned long SgJovialOverlayDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNonrealDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNonrealDecl* SgNonrealDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNonrealDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNonrealDecl* SgNonrealDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNonrealDecl* SgNonrealDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNonrealDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNonrealDecl_clearMemoryPool ( );
void SgNonrealDecl_extendMemoryPoolForFileIO ( );
unsigned long SgNonrealDecl_initializeStorageClassArray( SgNonrealDeclStorageClass *storageArray );
void SgNonrealDecl_resetValidFreepointers( );
unsigned long SgNonrealDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEmptyDeclaration_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEmptyDeclaration* SgEmptyDeclaration_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEmptyDeclaration_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEmptyDeclaration* SgEmptyDeclaration_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEmptyDeclaration* SgEmptyDeclaration_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEmptyDeclaration_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEmptyDeclaration_clearMemoryPool ( );
void SgEmptyDeclaration_extendMemoryPoolForFileIO ( );
unsigned long SgEmptyDeclaration_initializeStorageClassArray( SgEmptyDeclarationStorageClass *storageArray );
void SgEmptyDeclaration_resetValidFreepointers( );
unsigned long SgEmptyDeclaration_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaPackageBodyDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaPackageBodyDecl* SgAdaPackageBodyDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaPackageBodyDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaPackageBodyDecl* SgAdaPackageBodyDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaPackageBodyDecl* SgAdaPackageBodyDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaPackageBodyDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaPackageBodyDecl_clearMemoryPool ( );
void SgAdaPackageBodyDecl_extendMemoryPoolForFileIO ( );
unsigned long SgAdaPackageBodyDecl_initializeStorageClassArray( SgAdaPackageBodyDeclStorageClass *storageArray );
void SgAdaPackageBodyDecl_resetValidFreepointers( );
unsigned long SgAdaPackageBodyDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaPackageSpecDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaPackageSpecDecl* SgAdaPackageSpecDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaPackageSpecDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaPackageSpecDecl* SgAdaPackageSpecDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaPackageSpecDecl* SgAdaPackageSpecDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaPackageSpecDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaPackageSpecDecl_clearMemoryPool ( );
void SgAdaPackageSpecDecl_extendMemoryPoolForFileIO ( );
unsigned long SgAdaPackageSpecDecl_initializeStorageClassArray( SgAdaPackageSpecDeclStorageClass *storageArray );
void SgAdaPackageSpecDecl_resetValidFreepointers( );
unsigned long SgAdaPackageSpecDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaRenamingDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaRenamingDecl* SgAdaRenamingDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaRenamingDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaRenamingDecl* SgAdaRenamingDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaRenamingDecl* SgAdaRenamingDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaRenamingDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaRenamingDecl_clearMemoryPool ( );
void SgAdaRenamingDecl_extendMemoryPoolForFileIO ( );
unsigned long SgAdaRenamingDecl_initializeStorageClassArray( SgAdaRenamingDeclStorageClass *storageArray );
void SgAdaRenamingDecl_resetValidFreepointers( );
unsigned long SgAdaRenamingDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaTaskSpecDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaTaskSpecDecl* SgAdaTaskSpecDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaTaskSpecDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaTaskSpecDecl* SgAdaTaskSpecDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaTaskSpecDecl* SgAdaTaskSpecDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaTaskSpecDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaTaskSpecDecl_clearMemoryPool ( );
void SgAdaTaskSpecDecl_extendMemoryPoolForFileIO ( );
unsigned long SgAdaTaskSpecDecl_initializeStorageClassArray( SgAdaTaskSpecDeclStorageClass *storageArray );
void SgAdaTaskSpecDecl_resetValidFreepointers( );
unsigned long SgAdaTaskSpecDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaTaskBodyDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaTaskBodyDecl* SgAdaTaskBodyDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaTaskBodyDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaTaskBodyDecl* SgAdaTaskBodyDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaTaskBodyDecl* SgAdaTaskBodyDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaTaskBodyDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaTaskBodyDecl_clearMemoryPool ( );
void SgAdaTaskBodyDecl_extendMemoryPoolForFileIO ( );
unsigned long SgAdaTaskBodyDecl_initializeStorageClassArray( SgAdaTaskBodyDeclStorageClass *storageArray );
void SgAdaTaskBodyDecl_resetValidFreepointers( );
unsigned long SgAdaTaskBodyDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaTaskTypeDecl_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaTaskTypeDecl* SgAdaTaskTypeDecl_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaTaskTypeDecl_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaTaskTypeDecl* SgAdaTaskTypeDecl_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaTaskTypeDecl* SgAdaTaskTypeDecl_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaTaskTypeDecl_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaTaskTypeDecl_clearMemoryPool ( );
void SgAdaTaskTypeDecl_extendMemoryPoolForFileIO ( );
unsigned long SgAdaTaskTypeDecl_initializeStorageClassArray( SgAdaTaskTypeDeclStorageClass *storageArray );
void SgAdaTaskTypeDecl_resetValidFreepointers( );
unsigned long SgAdaTaskTypeDecl_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExprStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExprStatement* SgExprStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExprStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExprStatement* SgExprStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExprStatement* SgExprStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExprStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExprStatement_clearMemoryPool ( );
void SgExprStatement_extendMemoryPoolForFileIO ( );
unsigned long SgExprStatement_initializeStorageClassArray( SgExprStatementStorageClass *storageArray );
void SgExprStatement_resetValidFreepointers( );
unsigned long SgExprStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLabelStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLabelStatement* SgLabelStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLabelStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLabelStatement* SgLabelStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLabelStatement* SgLabelStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLabelStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLabelStatement_clearMemoryPool ( );
void SgLabelStatement_extendMemoryPoolForFileIO ( );
unsigned long SgLabelStatement_initializeStorageClassArray( SgLabelStatementStorageClass *storageArray );
void SgLabelStatement_resetValidFreepointers( );
unsigned long SgLabelStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCaseOptionStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCaseOptionStmt* SgCaseOptionStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCaseOptionStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCaseOptionStmt* SgCaseOptionStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCaseOptionStmt* SgCaseOptionStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCaseOptionStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCaseOptionStmt_clearMemoryPool ( );
void SgCaseOptionStmt_extendMemoryPoolForFileIO ( );
unsigned long SgCaseOptionStmt_initializeStorageClassArray( SgCaseOptionStmtStorageClass *storageArray );
void SgCaseOptionStmt_resetValidFreepointers( );
unsigned long SgCaseOptionStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTryStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTryStmt* SgTryStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTryStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTryStmt* SgTryStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTryStmt* SgTryStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTryStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTryStmt_clearMemoryPool ( );
void SgTryStmt_extendMemoryPoolForFileIO ( );
unsigned long SgTryStmt_initializeStorageClassArray( SgTryStmtStorageClass *storageArray );
void SgTryStmt_resetValidFreepointers( );
unsigned long SgTryStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDefaultOptionStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDefaultOptionStmt* SgDefaultOptionStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDefaultOptionStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDefaultOptionStmt* SgDefaultOptionStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDefaultOptionStmt* SgDefaultOptionStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDefaultOptionStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDefaultOptionStmt_clearMemoryPool ( );
void SgDefaultOptionStmt_extendMemoryPoolForFileIO ( );
unsigned long SgDefaultOptionStmt_initializeStorageClassArray( SgDefaultOptionStmtStorageClass *storageArray );
void SgDefaultOptionStmt_resetValidFreepointers( );
unsigned long SgDefaultOptionStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBreakStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBreakStmt* SgBreakStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBreakStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBreakStmt* SgBreakStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBreakStmt* SgBreakStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBreakStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBreakStmt_clearMemoryPool ( );
void SgBreakStmt_extendMemoryPoolForFileIO ( );
unsigned long SgBreakStmt_initializeStorageClassArray( SgBreakStmtStorageClass *storageArray );
void SgBreakStmt_resetValidFreepointers( );
unsigned long SgBreakStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgContinueStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgContinueStmt* SgContinueStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgContinueStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgContinueStmt* SgContinueStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgContinueStmt* SgContinueStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgContinueStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgContinueStmt_clearMemoryPool ( );
void SgContinueStmt_extendMemoryPoolForFileIO ( );
unsigned long SgContinueStmt_initializeStorageClassArray( SgContinueStmtStorageClass *storageArray );
void SgContinueStmt_resetValidFreepointers( );
unsigned long SgContinueStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgReturnStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgReturnStmt* SgReturnStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgReturnStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgReturnStmt* SgReturnStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgReturnStmt* SgReturnStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgReturnStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgReturnStmt_clearMemoryPool ( );
void SgReturnStmt_extendMemoryPoolForFileIO ( );
unsigned long SgReturnStmt_initializeStorageClassArray( SgReturnStmtStorageClass *storageArray );
void SgReturnStmt_resetValidFreepointers( );
unsigned long SgReturnStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGotoStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGotoStatement* SgGotoStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGotoStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGotoStatement* SgGotoStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGotoStatement* SgGotoStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGotoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGotoStatement_clearMemoryPool ( );
void SgGotoStatement_extendMemoryPoolForFileIO ( );
unsigned long SgGotoStatement_initializeStorageClassArray( SgGotoStatementStorageClass *storageArray );
void SgGotoStatement_resetValidFreepointers( );
unsigned long SgGotoStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSpawnStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSpawnStmt* SgSpawnStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSpawnStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSpawnStmt* SgSpawnStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSpawnStmt* SgSpawnStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSpawnStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSpawnStmt_clearMemoryPool ( );
void SgSpawnStmt_extendMemoryPoolForFileIO ( );
unsigned long SgSpawnStmt_initializeStorageClassArray( SgSpawnStmtStorageClass *storageArray );
void SgSpawnStmt_resetValidFreepointers( );
unsigned long SgSpawnStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNullStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNullStatement* SgNullStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNullStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNullStatement* SgNullStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNullStatement* SgNullStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNullStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNullStatement_clearMemoryPool ( );
void SgNullStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNullStatement_initializeStorageClassArray( SgNullStatementStorageClass *storageArray );
void SgNullStatement_resetValidFreepointers( );
unsigned long SgNullStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVariantStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVariantStatement* SgVariantStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVariantStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVariantStatement* SgVariantStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVariantStatement* SgVariantStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVariantStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVariantStatement_clearMemoryPool ( );
void SgVariantStatement_extendMemoryPoolForFileIO ( );
unsigned long SgVariantStatement_initializeStorageClassArray( SgVariantStatementStorageClass *storageArray );
void SgVariantStatement_resetValidFreepointers( );
unsigned long SgVariantStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgForInitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgForInitStatement* SgForInitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgForInitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgForInitStatement* SgForInitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgForInitStatement* SgForInitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgForInitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgForInitStatement_clearMemoryPool ( );
void SgForInitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgForInitStatement_initializeStorageClassArray( SgForInitStatementStorageClass *storageArray );
void SgForInitStatement_resetValidFreepointers( );
unsigned long SgForInitStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCatchStatementSeq_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCatchStatementSeq* SgCatchStatementSeq_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCatchStatementSeq_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCatchStatementSeq* SgCatchStatementSeq_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCatchStatementSeq* SgCatchStatementSeq_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCatchStatementSeq_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCatchStatementSeq_clearMemoryPool ( );
void SgCatchStatementSeq_extendMemoryPoolForFileIO ( );
unsigned long SgCatchStatementSeq_initializeStorageClassArray( SgCatchStatementSeqStorageClass *storageArray );
void SgCatchStatementSeq_resetValidFreepointers( );
unsigned long SgCatchStatementSeq_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgProcessControlStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgProcessControlStatement* SgProcessControlStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgProcessControlStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgProcessControlStatement* SgProcessControlStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgProcessControlStatement* SgProcessControlStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgProcessControlStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgProcessControlStatement_clearMemoryPool ( );
void SgProcessControlStatement_extendMemoryPoolForFileIO ( );
unsigned long SgProcessControlStatement_initializeStorageClassArray( SgProcessControlStatementStorageClass *storageArray );
void SgProcessControlStatement_resetValidFreepointers( );
unsigned long SgProcessControlStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIOStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIOStatement* SgIOStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIOStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIOStatement* SgIOStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIOStatement* SgIOStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIOStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIOStatement_clearMemoryPool ( );
void SgIOStatement_extendMemoryPoolForFileIO ( );
unsigned long SgIOStatement_initializeStorageClassArray( SgIOStatementStorageClass *storageArray );
void SgIOStatement_resetValidFreepointers( );
unsigned long SgIOStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPrintStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPrintStatement* SgPrintStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPrintStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPrintStatement* SgPrintStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPrintStatement* SgPrintStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPrintStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPrintStatement_clearMemoryPool ( );
void SgPrintStatement_extendMemoryPoolForFileIO ( );
unsigned long SgPrintStatement_initializeStorageClassArray( SgPrintStatementStorageClass *storageArray );
void SgPrintStatement_resetValidFreepointers( );
unsigned long SgPrintStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgReadStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgReadStatement* SgReadStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgReadStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgReadStatement* SgReadStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgReadStatement* SgReadStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgReadStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgReadStatement_clearMemoryPool ( );
void SgReadStatement_extendMemoryPoolForFileIO ( );
unsigned long SgReadStatement_initializeStorageClassArray( SgReadStatementStorageClass *storageArray );
void SgReadStatement_resetValidFreepointers( );
unsigned long SgReadStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWriteStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWriteStatement* SgWriteStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWriteStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWriteStatement* SgWriteStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWriteStatement* SgWriteStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWriteStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWriteStatement_clearMemoryPool ( );
void SgWriteStatement_extendMemoryPoolForFileIO ( );
unsigned long SgWriteStatement_initializeStorageClassArray( SgWriteStatementStorageClass *storageArray );
void SgWriteStatement_resetValidFreepointers( );
unsigned long SgWriteStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOpenStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOpenStatement* SgOpenStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOpenStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOpenStatement* SgOpenStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOpenStatement* SgOpenStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOpenStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOpenStatement_clearMemoryPool ( );
void SgOpenStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOpenStatement_initializeStorageClassArray( SgOpenStatementStorageClass *storageArray );
void SgOpenStatement_resetValidFreepointers( );
unsigned long SgOpenStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCloseStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCloseStatement* SgCloseStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCloseStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCloseStatement* SgCloseStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCloseStatement* SgCloseStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCloseStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCloseStatement_clearMemoryPool ( );
void SgCloseStatement_extendMemoryPoolForFileIO ( );
unsigned long SgCloseStatement_initializeStorageClassArray( SgCloseStatementStorageClass *storageArray );
void SgCloseStatement_resetValidFreepointers( );
unsigned long SgCloseStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInquireStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInquireStatement* SgInquireStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInquireStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInquireStatement* SgInquireStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInquireStatement* SgInquireStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInquireStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInquireStatement_clearMemoryPool ( );
void SgInquireStatement_extendMemoryPoolForFileIO ( );
unsigned long SgInquireStatement_initializeStorageClassArray( SgInquireStatementStorageClass *storageArray );
void SgInquireStatement_resetValidFreepointers( );
unsigned long SgInquireStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFlushStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFlushStatement* SgFlushStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFlushStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFlushStatement* SgFlushStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFlushStatement* SgFlushStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFlushStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFlushStatement_clearMemoryPool ( );
void SgFlushStatement_extendMemoryPoolForFileIO ( );
unsigned long SgFlushStatement_initializeStorageClassArray( SgFlushStatementStorageClass *storageArray );
void SgFlushStatement_resetValidFreepointers( );
unsigned long SgFlushStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBackspaceStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBackspaceStatement* SgBackspaceStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBackspaceStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBackspaceStatement* SgBackspaceStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBackspaceStatement* SgBackspaceStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBackspaceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBackspaceStatement_clearMemoryPool ( );
void SgBackspaceStatement_extendMemoryPoolForFileIO ( );
unsigned long SgBackspaceStatement_initializeStorageClassArray( SgBackspaceStatementStorageClass *storageArray );
void SgBackspaceStatement_resetValidFreepointers( );
unsigned long SgBackspaceStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRewindStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRewindStatement* SgRewindStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRewindStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRewindStatement* SgRewindStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRewindStatement* SgRewindStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRewindStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRewindStatement_clearMemoryPool ( );
void SgRewindStatement_extendMemoryPoolForFileIO ( );
unsigned long SgRewindStatement_initializeStorageClassArray( SgRewindStatementStorageClass *storageArray );
void SgRewindStatement_resetValidFreepointers( );
unsigned long SgRewindStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEndfileStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEndfileStatement* SgEndfileStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEndfileStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEndfileStatement* SgEndfileStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEndfileStatement* SgEndfileStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEndfileStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEndfileStatement_clearMemoryPool ( );
void SgEndfileStatement_extendMemoryPoolForFileIO ( );
unsigned long SgEndfileStatement_initializeStorageClassArray( SgEndfileStatementStorageClass *storageArray );
void SgEndfileStatement_resetValidFreepointers( );
unsigned long SgEndfileStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWaitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWaitStatement* SgWaitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWaitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWaitStatement* SgWaitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWaitStatement* SgWaitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWaitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWaitStatement_clearMemoryPool ( );
void SgWaitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgWaitStatement_initializeStorageClassArray( SgWaitStatementStorageClass *storageArray );
void SgWaitStatement_resetValidFreepointers( );
unsigned long SgWaitStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWhereStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWhereStatement* SgWhereStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWhereStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWhereStatement* SgWhereStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWhereStatement* SgWhereStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWhereStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWhereStatement_clearMemoryPool ( );
void SgWhereStatement_extendMemoryPoolForFileIO ( );
unsigned long SgWhereStatement_initializeStorageClassArray( SgWhereStatementStorageClass *storageArray );
void SgWhereStatement_resetValidFreepointers( );
unsigned long SgWhereStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElseWhereStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElseWhereStatement* SgElseWhereStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElseWhereStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElseWhereStatement* SgElseWhereStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElseWhereStatement* SgElseWhereStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElseWhereStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElseWhereStatement_clearMemoryPool ( );
void SgElseWhereStatement_extendMemoryPoolForFileIO ( );
unsigned long SgElseWhereStatement_initializeStorageClassArray( SgElseWhereStatementStorageClass *storageArray );
void SgElseWhereStatement_resetValidFreepointers( );
unsigned long SgElseWhereStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNullifyStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNullifyStatement* SgNullifyStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNullifyStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNullifyStatement* SgNullifyStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNullifyStatement* SgNullifyStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNullifyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNullifyStatement_clearMemoryPool ( );
void SgNullifyStatement_extendMemoryPoolForFileIO ( );
unsigned long SgNullifyStatement_initializeStorageClassArray( SgNullifyStatementStorageClass *storageArray );
void SgNullifyStatement_resetValidFreepointers( );
unsigned long SgNullifyStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgArithmeticIfStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgArithmeticIfStatement* SgArithmeticIfStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgArithmeticIfStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgArithmeticIfStatement* SgArithmeticIfStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgArithmeticIfStatement* SgArithmeticIfStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgArithmeticIfStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgArithmeticIfStatement_clearMemoryPool ( );
void SgArithmeticIfStatement_extendMemoryPoolForFileIO ( );
unsigned long SgArithmeticIfStatement_initializeStorageClassArray( SgArithmeticIfStatementStorageClass *storageArray );
void SgArithmeticIfStatement_resetValidFreepointers( );
unsigned long SgArithmeticIfStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssignStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssignStatement* SgAssignStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssignStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssignStatement* SgAssignStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssignStatement* SgAssignStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssignStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssignStatement_clearMemoryPool ( );
void SgAssignStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAssignStatement_initializeStorageClassArray( SgAssignStatementStorageClass *storageArray );
void SgAssignStatement_resetValidFreepointers( );
unsigned long SgAssignStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgComputedGotoStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgComputedGotoStatement* SgComputedGotoStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgComputedGotoStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgComputedGotoStatement* SgComputedGotoStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgComputedGotoStatement* SgComputedGotoStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgComputedGotoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgComputedGotoStatement_clearMemoryPool ( );
void SgComputedGotoStatement_extendMemoryPoolForFileIO ( );
unsigned long SgComputedGotoStatement_initializeStorageClassArray( SgComputedGotoStatementStorageClass *storageArray );
void SgComputedGotoStatement_resetValidFreepointers( );
unsigned long SgComputedGotoStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssignedGotoStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssignedGotoStatement* SgAssignedGotoStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssignedGotoStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssignedGotoStatement* SgAssignedGotoStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssignedGotoStatement* SgAssignedGotoStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssignedGotoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssignedGotoStatement_clearMemoryPool ( );
void SgAssignedGotoStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAssignedGotoStatement_initializeStorageClassArray( SgAssignedGotoStatementStorageClass *storageArray );
void SgAssignedGotoStatement_resetValidFreepointers( );
unsigned long SgAssignedGotoStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAllocateStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAllocateStatement* SgAllocateStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAllocateStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAllocateStatement* SgAllocateStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAllocateStatement* SgAllocateStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAllocateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAllocateStatement_clearMemoryPool ( );
void SgAllocateStatement_extendMemoryPoolForFileIO ( );
unsigned long SgAllocateStatement_initializeStorageClassArray( SgAllocateStatementStorageClass *storageArray );
void SgAllocateStatement_resetValidFreepointers( );
unsigned long SgAllocateStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeallocateStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeallocateStatement* SgDeallocateStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeallocateStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeallocateStatement* SgDeallocateStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeallocateStatement* SgDeallocateStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeallocateStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeallocateStatement_clearMemoryPool ( );
void SgDeallocateStatement_extendMemoryPoolForFileIO ( );
unsigned long SgDeallocateStatement_initializeStorageClassArray( SgDeallocateStatementStorageClass *storageArray );
void SgDeallocateStatement_resetValidFreepointers( );
unsigned long SgDeallocateStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcNotifyStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcNotifyStatement* SgUpcNotifyStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcNotifyStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcNotifyStatement* SgUpcNotifyStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcNotifyStatement* SgUpcNotifyStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcNotifyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcNotifyStatement_clearMemoryPool ( );
void SgUpcNotifyStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUpcNotifyStatement_initializeStorageClassArray( SgUpcNotifyStatementStorageClass *storageArray );
void SgUpcNotifyStatement_resetValidFreepointers( );
unsigned long SgUpcNotifyStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcWaitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcWaitStatement* SgUpcWaitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcWaitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcWaitStatement* SgUpcWaitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcWaitStatement* SgUpcWaitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcWaitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcWaitStatement_clearMemoryPool ( );
void SgUpcWaitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUpcWaitStatement_initializeStorageClassArray( SgUpcWaitStatementStorageClass *storageArray );
void SgUpcWaitStatement_resetValidFreepointers( );
unsigned long SgUpcWaitStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcBarrierStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcBarrierStatement* SgUpcBarrierStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcBarrierStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcBarrierStatement* SgUpcBarrierStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcBarrierStatement* SgUpcBarrierStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcBarrierStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcBarrierStatement_clearMemoryPool ( );
void SgUpcBarrierStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUpcBarrierStatement_initializeStorageClassArray( SgUpcBarrierStatementStorageClass *storageArray );
void SgUpcBarrierStatement_resetValidFreepointers( );
unsigned long SgUpcBarrierStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcFenceStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcFenceStatement* SgUpcFenceStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcFenceStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcFenceStatement* SgUpcFenceStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcFenceStatement* SgUpcFenceStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcFenceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcFenceStatement_clearMemoryPool ( );
void SgUpcFenceStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUpcFenceStatement_initializeStorageClassArray( SgUpcFenceStatementStorageClass *storageArray );
void SgUpcFenceStatement_resetValidFreepointers( );
unsigned long SgUpcFenceStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpBarrierStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpBarrierStatement* SgOmpBarrierStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpBarrierStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpBarrierStatement* SgOmpBarrierStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpBarrierStatement* SgOmpBarrierStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpBarrierStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpBarrierStatement_clearMemoryPool ( );
void SgOmpBarrierStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpBarrierStatement_initializeStorageClassArray( SgOmpBarrierStatementStorageClass *storageArray );
void SgOmpBarrierStatement_resetValidFreepointers( );
unsigned long SgOmpBarrierStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpTaskwaitStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpTaskwaitStatement* SgOmpTaskwaitStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpTaskwaitStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpTaskwaitStatement* SgOmpTaskwaitStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpTaskwaitStatement* SgOmpTaskwaitStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpTaskwaitStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpTaskwaitStatement_clearMemoryPool ( );
void SgOmpTaskwaitStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpTaskwaitStatement_initializeStorageClassArray( SgOmpTaskwaitStatementStorageClass *storageArray );
void SgOmpTaskwaitStatement_resetValidFreepointers( );
unsigned long SgOmpTaskwaitStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpFlushStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpFlushStatement* SgOmpFlushStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpFlushStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpFlushStatement* SgOmpFlushStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpFlushStatement* SgOmpFlushStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpFlushStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpFlushStatement_clearMemoryPool ( );
void SgOmpFlushStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpFlushStatement_initializeStorageClassArray( SgOmpFlushStatementStorageClass *storageArray );
void SgOmpFlushStatement_resetValidFreepointers( );
unsigned long SgOmpFlushStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpBodyStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpBodyStatement* SgOmpBodyStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpBodyStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpBodyStatement* SgOmpBodyStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpBodyStatement* SgOmpBodyStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpBodyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpBodyStatement_clearMemoryPool ( );
void SgOmpBodyStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpBodyStatement_initializeStorageClassArray( SgOmpBodyStatementStorageClass *storageArray );
void SgOmpBodyStatement_resetValidFreepointers( );
unsigned long SgOmpBodyStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpMasterStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpMasterStatement* SgOmpMasterStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpMasterStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpMasterStatement* SgOmpMasterStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpMasterStatement* SgOmpMasterStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpMasterStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpMasterStatement_clearMemoryPool ( );
void SgOmpMasterStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpMasterStatement_initializeStorageClassArray( SgOmpMasterStatementStorageClass *storageArray );
void SgOmpMasterStatement_resetValidFreepointers( );
unsigned long SgOmpMasterStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpOrderedStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpOrderedStatement* SgOmpOrderedStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpOrderedStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpOrderedStatement* SgOmpOrderedStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpOrderedStatement* SgOmpOrderedStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpOrderedStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpOrderedStatement_clearMemoryPool ( );
void SgOmpOrderedStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpOrderedStatement_initializeStorageClassArray( SgOmpOrderedStatementStorageClass *storageArray );
void SgOmpOrderedStatement_resetValidFreepointers( );
unsigned long SgOmpOrderedStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpCriticalStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpCriticalStatement* SgOmpCriticalStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpCriticalStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpCriticalStatement* SgOmpCriticalStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpCriticalStatement* SgOmpCriticalStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpCriticalStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpCriticalStatement_clearMemoryPool ( );
void SgOmpCriticalStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpCriticalStatement_initializeStorageClassArray( SgOmpCriticalStatementStorageClass *storageArray );
void SgOmpCriticalStatement_resetValidFreepointers( );
unsigned long SgOmpCriticalStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSectionStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSectionStatement* SgOmpSectionStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSectionStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSectionStatement* SgOmpSectionStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSectionStatement* SgOmpSectionStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSectionStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSectionStatement_clearMemoryPool ( );
void SgOmpSectionStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSectionStatement_initializeStorageClassArray( SgOmpSectionStatementStorageClass *storageArray );
void SgOmpSectionStatement_resetValidFreepointers( );
unsigned long SgOmpSectionStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpWorkshareStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpWorkshareStatement* SgOmpWorkshareStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpWorkshareStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpWorkshareStatement* SgOmpWorkshareStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpWorkshareStatement* SgOmpWorkshareStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpWorkshareStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpWorkshareStatement_clearMemoryPool ( );
void SgOmpWorkshareStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpWorkshareStatement_initializeStorageClassArray( SgOmpWorkshareStatementStorageClass *storageArray );
void SgOmpWorkshareStatement_resetValidFreepointers( );
unsigned long SgOmpWorkshareStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpClauseBodyStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpClauseBodyStatement* SgOmpClauseBodyStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpClauseBodyStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpClauseBodyStatement* SgOmpClauseBodyStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpClauseBodyStatement* SgOmpClauseBodyStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpClauseBodyStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpClauseBodyStatement_clearMemoryPool ( );
void SgOmpClauseBodyStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpClauseBodyStatement_initializeStorageClassArray( SgOmpClauseBodyStatementStorageClass *storageArray );
void SgOmpClauseBodyStatement_resetValidFreepointers( );
unsigned long SgOmpClauseBodyStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpParallelStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpParallelStatement* SgOmpParallelStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpParallelStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpParallelStatement* SgOmpParallelStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpParallelStatement* SgOmpParallelStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpParallelStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpParallelStatement_clearMemoryPool ( );
void SgOmpParallelStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpParallelStatement_initializeStorageClassArray( SgOmpParallelStatementStorageClass *storageArray );
void SgOmpParallelStatement_resetValidFreepointers( );
unsigned long SgOmpParallelStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSingleStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSingleStatement* SgOmpSingleStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSingleStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSingleStatement* SgOmpSingleStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSingleStatement* SgOmpSingleStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSingleStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSingleStatement_clearMemoryPool ( );
void SgOmpSingleStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSingleStatement_initializeStorageClassArray( SgOmpSingleStatementStorageClass *storageArray );
void SgOmpSingleStatement_resetValidFreepointers( );
unsigned long SgOmpSingleStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpAtomicStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpAtomicStatement* SgOmpAtomicStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpAtomicStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpAtomicStatement* SgOmpAtomicStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpAtomicStatement* SgOmpAtomicStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpAtomicStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpAtomicStatement_clearMemoryPool ( );
void SgOmpAtomicStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpAtomicStatement_initializeStorageClassArray( SgOmpAtomicStatementStorageClass *storageArray );
void SgOmpAtomicStatement_resetValidFreepointers( );
unsigned long SgOmpAtomicStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpTaskStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpTaskStatement* SgOmpTaskStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpTaskStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpTaskStatement* SgOmpTaskStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpTaskStatement* SgOmpTaskStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpTaskStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpTaskStatement_clearMemoryPool ( );
void SgOmpTaskStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpTaskStatement_initializeStorageClassArray( SgOmpTaskStatementStorageClass *storageArray );
void SgOmpTaskStatement_resetValidFreepointers( );
unsigned long SgOmpTaskStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpForStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpForStatement* SgOmpForStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpForStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpForStatement* SgOmpForStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpForStatement* SgOmpForStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpForStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpForStatement_clearMemoryPool ( );
void SgOmpForStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpForStatement_initializeStorageClassArray( SgOmpForStatementStorageClass *storageArray );
void SgOmpForStatement_resetValidFreepointers( );
unsigned long SgOmpForStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpDoStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpDoStatement* SgOmpDoStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpDoStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpDoStatement* SgOmpDoStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpDoStatement* SgOmpDoStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpDoStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpDoStatement_clearMemoryPool ( );
void SgOmpDoStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpDoStatement_initializeStorageClassArray( SgOmpDoStatementStorageClass *storageArray );
void SgOmpDoStatement_resetValidFreepointers( );
unsigned long SgOmpDoStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSectionsStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSectionsStatement* SgOmpSectionsStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSectionsStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSectionsStatement* SgOmpSectionsStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSectionsStatement* SgOmpSectionsStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSectionsStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSectionsStatement_clearMemoryPool ( );
void SgOmpSectionsStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSectionsStatement_initializeStorageClassArray( SgOmpSectionsStatementStorageClass *storageArray );
void SgOmpSectionsStatement_resetValidFreepointers( );
unsigned long SgOmpSectionsStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpTargetStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpTargetStatement* SgOmpTargetStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpTargetStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpTargetStatement* SgOmpTargetStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpTargetStatement* SgOmpTargetStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpTargetStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpTargetStatement_clearMemoryPool ( );
void SgOmpTargetStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpTargetStatement_initializeStorageClassArray( SgOmpTargetStatementStorageClass *storageArray );
void SgOmpTargetStatement_resetValidFreepointers( );
unsigned long SgOmpTargetStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpTargetDataStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpTargetDataStatement* SgOmpTargetDataStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpTargetDataStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpTargetDataStatement* SgOmpTargetDataStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpTargetDataStatement* SgOmpTargetDataStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpTargetDataStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpTargetDataStatement_clearMemoryPool ( );
void SgOmpTargetDataStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpTargetDataStatement_initializeStorageClassArray( SgOmpTargetDataStatementStorageClass *storageArray );
void SgOmpTargetDataStatement_resetValidFreepointers( );
unsigned long SgOmpTargetDataStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpSimdStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpSimdStatement* SgOmpSimdStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpSimdStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpSimdStatement* SgOmpSimdStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpSimdStatement* SgOmpSimdStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpSimdStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpSimdStatement_clearMemoryPool ( );
void SgOmpSimdStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpSimdStatement_initializeStorageClassArray( SgOmpSimdStatementStorageClass *storageArray );
void SgOmpSimdStatement_resetValidFreepointers( );
unsigned long SgOmpSimdStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOmpForSimdStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOmpForSimdStatement* SgOmpForSimdStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOmpForSimdStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOmpForSimdStatement* SgOmpForSimdStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOmpForSimdStatement* SgOmpForSimdStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOmpForSimdStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOmpForSimdStatement_clearMemoryPool ( );
void SgOmpForSimdStatement_extendMemoryPoolForFileIO ( );
unsigned long SgOmpForSimdStatement_initializeStorageClassArray( SgOmpForSimdStatementStorageClass *storageArray );
void SgOmpForSimdStatement_resetValidFreepointers( );
unsigned long SgOmpForSimdStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSequenceStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSequenceStatement* SgSequenceStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSequenceStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSequenceStatement* SgSequenceStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSequenceStatement* SgSequenceStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSequenceStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSequenceStatement_clearMemoryPool ( );
void SgSequenceStatement_extendMemoryPoolForFileIO ( );
unsigned long SgSequenceStatement_initializeStorageClassArray( SgSequenceStatementStorageClass *storageArray );
void SgSequenceStatement_resetValidFreepointers( );
unsigned long SgSequenceStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWithStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWithStatement* SgWithStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWithStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWithStatement* SgWithStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWithStatement* SgWithStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWithStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWithStatement_clearMemoryPool ( );
void SgWithStatement_extendMemoryPoolForFileIO ( );
unsigned long SgWithStatement_initializeStorageClassArray( SgWithStatementStorageClass *storageArray );
void SgWithStatement_resetValidFreepointers( );
unsigned long SgWithStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPythonPrintStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPythonPrintStmt* SgPythonPrintStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPythonPrintStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPythonPrintStmt* SgPythonPrintStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPythonPrintStmt* SgPythonPrintStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPythonPrintStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPythonPrintStmt_clearMemoryPool ( );
void SgPythonPrintStmt_extendMemoryPoolForFileIO ( );
unsigned long SgPythonPrintStmt_initializeStorageClassArray( SgPythonPrintStmtStorageClass *storageArray );
void SgPythonPrintStmt_resetValidFreepointers( );
unsigned long SgPythonPrintStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPassStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPassStatement* SgPassStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPassStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPassStatement* SgPassStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPassStatement* SgPassStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPassStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPassStatement_clearMemoryPool ( );
void SgPassStatement_extendMemoryPoolForFileIO ( );
unsigned long SgPassStatement_initializeStorageClassArray( SgPassStatementStorageClass *storageArray );
void SgPassStatement_resetValidFreepointers( );
unsigned long SgPassStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssertStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssertStmt* SgAssertStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssertStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssertStmt* SgAssertStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssertStmt* SgAssertStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssertStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssertStmt_clearMemoryPool ( );
void SgAssertStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAssertStmt_initializeStorageClassArray( SgAssertStmtStorageClass *storageArray );
void SgAssertStmt_resetValidFreepointers( );
unsigned long SgAssertStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExecStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExecStatement* SgExecStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExecStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExecStatement* SgExecStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExecStatement* SgExecStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExecStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExecStatement_clearMemoryPool ( );
void SgExecStatement_extendMemoryPoolForFileIO ( );
unsigned long SgExecStatement_initializeStorageClassArray( SgExecStatementStorageClass *storageArray );
void SgExecStatement_resetValidFreepointers( );
unsigned long SgExecStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPythonGlobalStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPythonGlobalStmt* SgPythonGlobalStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPythonGlobalStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPythonGlobalStmt* SgPythonGlobalStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPythonGlobalStmt* SgPythonGlobalStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPythonGlobalStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPythonGlobalStmt_clearMemoryPool ( );
void SgPythonGlobalStmt_extendMemoryPoolForFileIO ( );
unsigned long SgPythonGlobalStmt_initializeStorageClassArray( SgPythonGlobalStmtStorageClass *storageArray );
void SgPythonGlobalStmt_resetValidFreepointers( );
unsigned long SgPythonGlobalStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaThrowStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaThrowStatement* SgJavaThrowStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaThrowStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaThrowStatement* SgJavaThrowStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaThrowStatement* SgJavaThrowStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaThrowStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaThrowStatement_clearMemoryPool ( );
void SgJavaThrowStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaThrowStatement_initializeStorageClassArray( SgJavaThrowStatementStorageClass *storageArray );
void SgJavaThrowStatement_resetValidFreepointers( );
unsigned long SgJavaThrowStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaSynchronizedStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaSynchronizedStatement* SgJavaSynchronizedStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaSynchronizedStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaSynchronizedStatement* SgJavaSynchronizedStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaSynchronizedStatement* SgJavaSynchronizedStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaSynchronizedStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaSynchronizedStatement_clearMemoryPool ( );
void SgJavaSynchronizedStatement_extendMemoryPoolForFileIO ( );
unsigned long SgJavaSynchronizedStatement_initializeStorageClassArray( SgJavaSynchronizedStatementStorageClass *storageArray );
void SgJavaSynchronizedStatement_resetValidFreepointers( );
unsigned long SgJavaSynchronizedStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsyncStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsyncStmt* SgAsyncStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsyncStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsyncStmt* SgAsyncStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsyncStmt* SgAsyncStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsyncStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsyncStmt_clearMemoryPool ( );
void SgAsyncStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAsyncStmt_initializeStorageClassArray( SgAsyncStmtStorageClass *storageArray );
void SgAsyncStmt_resetValidFreepointers( );
unsigned long SgAsyncStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFinishStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFinishStmt* SgFinishStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFinishStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFinishStmt* SgFinishStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFinishStmt* SgFinishStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFinishStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFinishStmt_clearMemoryPool ( );
void SgFinishStmt_extendMemoryPoolForFileIO ( );
unsigned long SgFinishStmt_initializeStorageClassArray( SgFinishStmtStorageClass *storageArray );
void SgFinishStmt_resetValidFreepointers( );
unsigned long SgFinishStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAtStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAtStmt* SgAtStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAtStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAtStmt* SgAtStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAtStmt* SgAtStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAtStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAtStmt_clearMemoryPool ( );
void SgAtStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAtStmt_initializeStorageClassArray( SgAtStmtStorageClass *storageArray );
void SgAtStmt_resetValidFreepointers( );
unsigned long SgAtStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAtomicStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAtomicStmt* SgAtomicStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAtomicStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAtomicStmt* SgAtomicStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAtomicStmt* SgAtomicStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAtomicStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAtomicStmt_clearMemoryPool ( );
void SgAtomicStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAtomicStmt_initializeStorageClassArray( SgAtomicStmtStorageClass *storageArray );
void SgAtomicStmt_resetValidFreepointers( );
unsigned long SgAtomicStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWhenStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWhenStmt* SgWhenStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWhenStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWhenStmt* SgWhenStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWhenStmt* SgWhenStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWhenStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWhenStmt_clearMemoryPool ( );
void SgWhenStmt_extendMemoryPoolForFileIO ( );
unsigned long SgWhenStmt_initializeStorageClassArray( SgWhenStmtStorageClass *storageArray );
void SgWhenStmt_resetValidFreepointers( );
unsigned long SgWhenStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgImageControlStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgImageControlStatement* SgImageControlStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgImageControlStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgImageControlStatement* SgImageControlStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgImageControlStatement* SgImageControlStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgImageControlStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgImageControlStatement_clearMemoryPool ( );
void SgImageControlStatement_extendMemoryPoolForFileIO ( );
unsigned long SgImageControlStatement_initializeStorageClassArray( SgImageControlStatementStorageClass *storageArray );
void SgImageControlStatement_resetValidFreepointers( );
unsigned long SgImageControlStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSyncAllStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSyncAllStatement* SgSyncAllStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSyncAllStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSyncAllStatement* SgSyncAllStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSyncAllStatement* SgSyncAllStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSyncAllStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSyncAllStatement_clearMemoryPool ( );
void SgSyncAllStatement_extendMemoryPoolForFileIO ( );
unsigned long SgSyncAllStatement_initializeStorageClassArray( SgSyncAllStatementStorageClass *storageArray );
void SgSyncAllStatement_resetValidFreepointers( );
unsigned long SgSyncAllStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSyncImagesStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSyncImagesStatement* SgSyncImagesStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSyncImagesStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSyncImagesStatement* SgSyncImagesStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSyncImagesStatement* SgSyncImagesStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSyncImagesStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSyncImagesStatement_clearMemoryPool ( );
void SgSyncImagesStatement_extendMemoryPoolForFileIO ( );
unsigned long SgSyncImagesStatement_initializeStorageClassArray( SgSyncImagesStatementStorageClass *storageArray );
void SgSyncImagesStatement_resetValidFreepointers( );
unsigned long SgSyncImagesStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSyncMemoryStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSyncMemoryStatement* SgSyncMemoryStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSyncMemoryStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSyncMemoryStatement* SgSyncMemoryStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSyncMemoryStatement* SgSyncMemoryStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSyncMemoryStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSyncMemoryStatement_clearMemoryPool ( );
void SgSyncMemoryStatement_extendMemoryPoolForFileIO ( );
unsigned long SgSyncMemoryStatement_initializeStorageClassArray( SgSyncMemoryStatementStorageClass *storageArray );
void SgSyncMemoryStatement_resetValidFreepointers( );
unsigned long SgSyncMemoryStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSyncTeamStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSyncTeamStatement* SgSyncTeamStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSyncTeamStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSyncTeamStatement* SgSyncTeamStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSyncTeamStatement* SgSyncTeamStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSyncTeamStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSyncTeamStatement_clearMemoryPool ( );
void SgSyncTeamStatement_extendMemoryPoolForFileIO ( );
unsigned long SgSyncTeamStatement_initializeStorageClassArray( SgSyncTeamStatementStorageClass *storageArray );
void SgSyncTeamStatement_resetValidFreepointers( );
unsigned long SgSyncTeamStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLockStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLockStatement* SgLockStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLockStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLockStatement* SgLockStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLockStatement* SgLockStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLockStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLockStatement_clearMemoryPool ( );
void SgLockStatement_extendMemoryPoolForFileIO ( );
unsigned long SgLockStatement_initializeStorageClassArray( SgLockStatementStorageClass *storageArray );
void SgLockStatement_resetValidFreepointers( );
unsigned long SgLockStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnlockStatement_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnlockStatement* SgUnlockStatement_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnlockStatement_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnlockStatement* SgUnlockStatement_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnlockStatement* SgUnlockStatement_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnlockStatement_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnlockStatement_clearMemoryPool ( );
void SgUnlockStatement_extendMemoryPoolForFileIO ( );
unsigned long SgUnlockStatement_initializeStorageClassArray( SgUnlockStatementStorageClass *storageArray );
void SgUnlockStatement_resetValidFreepointers( );
unsigned long SgUnlockStatement_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaExitStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaExitStmt* SgAdaExitStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaExitStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaExitStmt* SgAdaExitStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaExitStmt* SgAdaExitStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaExitStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaExitStmt_clearMemoryPool ( );
void SgAdaExitStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAdaExitStmt_initializeStorageClassArray( SgAdaExitStmtStorageClass *storageArray );
void SgAdaExitStmt_resetValidFreepointers( );
unsigned long SgAdaExitStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaLoopStmt_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaLoopStmt* SgAdaLoopStmt_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaLoopStmt_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaLoopStmt* SgAdaLoopStmt_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaLoopStmt* SgAdaLoopStmt_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaLoopStmt_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaLoopStmt_clearMemoryPool ( );
void SgAdaLoopStmt_extendMemoryPoolForFileIO ( );
unsigned long SgAdaLoopStmt_initializeStorageClassArray( SgAdaLoopStmtStorageClass *storageArray );
void SgAdaLoopStmt_resetValidFreepointers( );
unsigned long SgAdaLoopStmt_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExpression* SgExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExpression* SgExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExpression* SgExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExpression_clearMemoryPool ( );
void SgExpression_extendMemoryPoolForFileIO ( );
unsigned long SgExpression_initializeStorageClassArray( SgExpressionStorageClass *storageArray );
void SgExpression_resetValidFreepointers( );
unsigned long SgExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnaryOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnaryOp* SgUnaryOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnaryOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnaryOp* SgUnaryOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnaryOp* SgUnaryOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnaryOp_clearMemoryPool ( );
void SgUnaryOp_extendMemoryPoolForFileIO ( );
unsigned long SgUnaryOp_initializeStorageClassArray( SgUnaryOpStorageClass *storageArray );
void SgUnaryOp_resetValidFreepointers( );
unsigned long SgUnaryOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExpressionRoot_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExpressionRoot* SgExpressionRoot_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExpressionRoot_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExpressionRoot* SgExpressionRoot_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExpressionRoot* SgExpressionRoot_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExpressionRoot_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExpressionRoot_clearMemoryPool ( );
void SgExpressionRoot_extendMemoryPoolForFileIO ( );
unsigned long SgExpressionRoot_initializeStorageClassArray( SgExpressionRootStorageClass *storageArray );
void SgExpressionRoot_resetValidFreepointers( );
unsigned long SgExpressionRoot_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMinusOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMinusOp* SgMinusOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMinusOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMinusOp* SgMinusOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMinusOp* SgMinusOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMinusOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMinusOp_clearMemoryPool ( );
void SgMinusOp_extendMemoryPoolForFileIO ( );
unsigned long SgMinusOp_initializeStorageClassArray( SgMinusOpStorageClass *storageArray );
void SgMinusOp_resetValidFreepointers( );
unsigned long SgMinusOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnaryAddOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnaryAddOp* SgUnaryAddOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnaryAddOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnaryAddOp* SgUnaryAddOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnaryAddOp* SgUnaryAddOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnaryAddOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnaryAddOp_clearMemoryPool ( );
void SgUnaryAddOp_extendMemoryPoolForFileIO ( );
unsigned long SgUnaryAddOp_initializeStorageClassArray( SgUnaryAddOpStorageClass *storageArray );
void SgUnaryAddOp_resetValidFreepointers( );
unsigned long SgUnaryAddOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNotOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNotOp* SgNotOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNotOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNotOp* SgNotOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNotOp* SgNotOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNotOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNotOp_clearMemoryPool ( );
void SgNotOp_extendMemoryPoolForFileIO ( );
unsigned long SgNotOp_initializeStorageClassArray( SgNotOpStorageClass *storageArray );
void SgNotOp_resetValidFreepointers( );
unsigned long SgNotOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPointerDerefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPointerDerefExp* SgPointerDerefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPointerDerefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPointerDerefExp* SgPointerDerefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPointerDerefExp* SgPointerDerefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPointerDerefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPointerDerefExp_clearMemoryPool ( );
void SgPointerDerefExp_extendMemoryPoolForFileIO ( );
unsigned long SgPointerDerefExp_initializeStorageClassArray( SgPointerDerefExpStorageClass *storageArray );
void SgPointerDerefExp_resetValidFreepointers( );
unsigned long SgPointerDerefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAddressOfOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAddressOfOp* SgAddressOfOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAddressOfOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAddressOfOp* SgAddressOfOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAddressOfOp* SgAddressOfOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAddressOfOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAddressOfOp_clearMemoryPool ( );
void SgAddressOfOp_extendMemoryPoolForFileIO ( );
unsigned long SgAddressOfOp_initializeStorageClassArray( SgAddressOfOpStorageClass *storageArray );
void SgAddressOfOp_resetValidFreepointers( );
unsigned long SgAddressOfOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMinusMinusOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMinusMinusOp* SgMinusMinusOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMinusMinusOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMinusMinusOp* SgMinusMinusOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMinusMinusOp* SgMinusMinusOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMinusMinusOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMinusMinusOp_clearMemoryPool ( );
void SgMinusMinusOp_extendMemoryPoolForFileIO ( );
unsigned long SgMinusMinusOp_initializeStorageClassArray( SgMinusMinusOpStorageClass *storageArray );
void SgMinusMinusOp_resetValidFreepointers( );
unsigned long SgMinusMinusOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPlusPlusOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPlusPlusOp* SgPlusPlusOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPlusPlusOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPlusPlusOp* SgPlusPlusOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPlusPlusOp* SgPlusPlusOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPlusPlusOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPlusPlusOp_clearMemoryPool ( );
void SgPlusPlusOp_extendMemoryPoolForFileIO ( );
unsigned long SgPlusPlusOp_initializeStorageClassArray( SgPlusPlusOpStorageClass *storageArray );
void SgPlusPlusOp_resetValidFreepointers( );
unsigned long SgPlusPlusOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitComplementOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitComplementOp* SgBitComplementOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitComplementOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitComplementOp* SgBitComplementOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitComplementOp* SgBitComplementOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitComplementOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitComplementOp_clearMemoryPool ( );
void SgBitComplementOp_extendMemoryPoolForFileIO ( );
unsigned long SgBitComplementOp_initializeStorageClassArray( SgBitComplementOpStorageClass *storageArray );
void SgBitComplementOp_resetValidFreepointers( );
unsigned long SgBitComplementOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCastExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCastExp* SgCastExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCastExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCastExp* SgCastExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCastExp* SgCastExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCastExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCastExp_clearMemoryPool ( );
void SgCastExp_extendMemoryPoolForFileIO ( );
unsigned long SgCastExp_initializeStorageClassArray( SgCastExpStorageClass *storageArray );
void SgCastExp_resetValidFreepointers( );
unsigned long SgCastExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgThrowOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgThrowOp* SgThrowOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgThrowOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgThrowOp* SgThrowOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgThrowOp* SgThrowOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgThrowOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgThrowOp_clearMemoryPool ( );
void SgThrowOp_extendMemoryPoolForFileIO ( );
unsigned long SgThrowOp_initializeStorageClassArray( SgThrowOpStorageClass *storageArray );
void SgThrowOp_resetValidFreepointers( );
unsigned long SgThrowOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRealPartOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRealPartOp* SgRealPartOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRealPartOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRealPartOp* SgRealPartOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRealPartOp* SgRealPartOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRealPartOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRealPartOp_clearMemoryPool ( );
void SgRealPartOp_extendMemoryPoolForFileIO ( );
unsigned long SgRealPartOp_initializeStorageClassArray( SgRealPartOpStorageClass *storageArray );
void SgRealPartOp_resetValidFreepointers( );
unsigned long SgRealPartOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgImagPartOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgImagPartOp* SgImagPartOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgImagPartOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgImagPartOp* SgImagPartOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgImagPartOp* SgImagPartOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgImagPartOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgImagPartOp_clearMemoryPool ( );
void SgImagPartOp_extendMemoryPoolForFileIO ( );
unsigned long SgImagPartOp_initializeStorageClassArray( SgImagPartOpStorageClass *storageArray );
void SgImagPartOp_resetValidFreepointers( );
unsigned long SgImagPartOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgConjugateOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgConjugateOp* SgConjugateOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgConjugateOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgConjugateOp* SgConjugateOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgConjugateOp* SgConjugateOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgConjugateOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgConjugateOp_clearMemoryPool ( );
void SgConjugateOp_extendMemoryPoolForFileIO ( );
unsigned long SgConjugateOp_initializeStorageClassArray( SgConjugateOpStorageClass *storageArray );
void SgConjugateOp_resetValidFreepointers( );
unsigned long SgConjugateOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUserDefinedUnaryOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUserDefinedUnaryOp* SgUserDefinedUnaryOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUserDefinedUnaryOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUserDefinedUnaryOp* SgUserDefinedUnaryOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUserDefinedUnaryOp* SgUserDefinedUnaryOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUserDefinedUnaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUserDefinedUnaryOp_clearMemoryPool ( );
void SgUserDefinedUnaryOp_extendMemoryPoolForFileIO ( );
unsigned long SgUserDefinedUnaryOp_initializeStorageClassArray( SgUserDefinedUnaryOpStorageClass *storageArray );
void SgUserDefinedUnaryOp_resetValidFreepointers( );
unsigned long SgUserDefinedUnaryOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMatrixTransposeOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMatrixTransposeOp* SgMatrixTransposeOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMatrixTransposeOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMatrixTransposeOp* SgMatrixTransposeOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMatrixTransposeOp* SgMatrixTransposeOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMatrixTransposeOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMatrixTransposeOp_clearMemoryPool ( );
void SgMatrixTransposeOp_extendMemoryPoolForFileIO ( );
unsigned long SgMatrixTransposeOp_initializeStorageClassArray( SgMatrixTransposeOpStorageClass *storageArray );
void SgMatrixTransposeOp_resetValidFreepointers( );
unsigned long SgMatrixTransposeOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAbsOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAbsOp* SgAbsOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAbsOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAbsOp* SgAbsOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAbsOp* SgAbsOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAbsOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAbsOp_clearMemoryPool ( );
void SgAbsOp_extendMemoryPoolForFileIO ( );
unsigned long SgAbsOp_initializeStorageClassArray( SgAbsOpStorageClass *storageArray );
void SgAbsOp_resetValidFreepointers( );
unsigned long SgAbsOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBinaryOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBinaryOp* SgBinaryOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBinaryOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBinaryOp* SgBinaryOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBinaryOp* SgBinaryOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBinaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBinaryOp_clearMemoryPool ( );
void SgBinaryOp_extendMemoryPoolForFileIO ( );
unsigned long SgBinaryOp_initializeStorageClassArray( SgBinaryOpStorageClass *storageArray );
void SgBinaryOp_resetValidFreepointers( );
unsigned long SgBinaryOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgArrowExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgArrowExp* SgArrowExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgArrowExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgArrowExp* SgArrowExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgArrowExp* SgArrowExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgArrowExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgArrowExp_clearMemoryPool ( );
void SgArrowExp_extendMemoryPoolForFileIO ( );
unsigned long SgArrowExp_initializeStorageClassArray( SgArrowExpStorageClass *storageArray );
void SgArrowExp_resetValidFreepointers( );
unsigned long SgArrowExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDotExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDotExp* SgDotExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDotExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDotExp* SgDotExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDotExp* SgDotExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDotExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDotExp_clearMemoryPool ( );
void SgDotExp_extendMemoryPoolForFileIO ( );
unsigned long SgDotExp_initializeStorageClassArray( SgDotExpStorageClass *storageArray );
void SgDotExp_resetValidFreepointers( );
unsigned long SgDotExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDotStarOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDotStarOp* SgDotStarOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDotStarOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDotStarOp* SgDotStarOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDotStarOp* SgDotStarOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDotStarOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDotStarOp_clearMemoryPool ( );
void SgDotStarOp_extendMemoryPoolForFileIO ( );
unsigned long SgDotStarOp_initializeStorageClassArray( SgDotStarOpStorageClass *storageArray );
void SgDotStarOp_resetValidFreepointers( );
unsigned long SgDotStarOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgArrowStarOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgArrowStarOp* SgArrowStarOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgArrowStarOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgArrowStarOp* SgArrowStarOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgArrowStarOp* SgArrowStarOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgArrowStarOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgArrowStarOp_clearMemoryPool ( );
void SgArrowStarOp_extendMemoryPoolForFileIO ( );
unsigned long SgArrowStarOp_initializeStorageClassArray( SgArrowStarOpStorageClass *storageArray );
void SgArrowStarOp_resetValidFreepointers( );
unsigned long SgArrowStarOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEqualityOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEqualityOp* SgEqualityOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEqualityOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEqualityOp* SgEqualityOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEqualityOp* SgEqualityOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEqualityOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEqualityOp_clearMemoryPool ( );
void SgEqualityOp_extendMemoryPoolForFileIO ( );
unsigned long SgEqualityOp_initializeStorageClassArray( SgEqualityOpStorageClass *storageArray );
void SgEqualityOp_resetValidFreepointers( );
unsigned long SgEqualityOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLessThanOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLessThanOp* SgLessThanOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLessThanOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLessThanOp* SgLessThanOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLessThanOp* SgLessThanOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLessThanOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLessThanOp_clearMemoryPool ( );
void SgLessThanOp_extendMemoryPoolForFileIO ( );
unsigned long SgLessThanOp_initializeStorageClassArray( SgLessThanOpStorageClass *storageArray );
void SgLessThanOp_resetValidFreepointers( );
unsigned long SgLessThanOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGreaterThanOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGreaterThanOp* SgGreaterThanOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGreaterThanOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGreaterThanOp* SgGreaterThanOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGreaterThanOp* SgGreaterThanOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGreaterThanOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGreaterThanOp_clearMemoryPool ( );
void SgGreaterThanOp_extendMemoryPoolForFileIO ( );
unsigned long SgGreaterThanOp_initializeStorageClassArray( SgGreaterThanOpStorageClass *storageArray );
void SgGreaterThanOp_resetValidFreepointers( );
unsigned long SgGreaterThanOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNotEqualOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNotEqualOp* SgNotEqualOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNotEqualOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNotEqualOp* SgNotEqualOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNotEqualOp* SgNotEqualOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNotEqualOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNotEqualOp_clearMemoryPool ( );
void SgNotEqualOp_extendMemoryPoolForFileIO ( );
unsigned long SgNotEqualOp_initializeStorageClassArray( SgNotEqualOpStorageClass *storageArray );
void SgNotEqualOp_resetValidFreepointers( );
unsigned long SgNotEqualOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLessOrEqualOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLessOrEqualOp* SgLessOrEqualOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLessOrEqualOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLessOrEqualOp* SgLessOrEqualOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLessOrEqualOp* SgLessOrEqualOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLessOrEqualOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLessOrEqualOp_clearMemoryPool ( );
void SgLessOrEqualOp_extendMemoryPoolForFileIO ( );
unsigned long SgLessOrEqualOp_initializeStorageClassArray( SgLessOrEqualOpStorageClass *storageArray );
void SgLessOrEqualOp_resetValidFreepointers( );
unsigned long SgLessOrEqualOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgGreaterOrEqualOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgGreaterOrEqualOp* SgGreaterOrEqualOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgGreaterOrEqualOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgGreaterOrEqualOp* SgGreaterOrEqualOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgGreaterOrEqualOp* SgGreaterOrEqualOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgGreaterOrEqualOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgGreaterOrEqualOp_clearMemoryPool ( );
void SgGreaterOrEqualOp_extendMemoryPoolForFileIO ( );
unsigned long SgGreaterOrEqualOp_initializeStorageClassArray( SgGreaterOrEqualOpStorageClass *storageArray );
void SgGreaterOrEqualOp_resetValidFreepointers( );
unsigned long SgGreaterOrEqualOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAddOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAddOp* SgAddOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAddOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAddOp* SgAddOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAddOp* SgAddOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAddOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAddOp_clearMemoryPool ( );
void SgAddOp_extendMemoryPoolForFileIO ( );
unsigned long SgAddOp_initializeStorageClassArray( SgAddOpStorageClass *storageArray );
void SgAddOp_resetValidFreepointers( );
unsigned long SgAddOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSubtractOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSubtractOp* SgSubtractOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSubtractOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSubtractOp* SgSubtractOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSubtractOp* SgSubtractOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSubtractOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSubtractOp_clearMemoryPool ( );
void SgSubtractOp_extendMemoryPoolForFileIO ( );
unsigned long SgSubtractOp_initializeStorageClassArray( SgSubtractOpStorageClass *storageArray );
void SgSubtractOp_resetValidFreepointers( );
unsigned long SgSubtractOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMultiplyOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMultiplyOp* SgMultiplyOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMultiplyOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMultiplyOp* SgMultiplyOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMultiplyOp* SgMultiplyOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMultiplyOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMultiplyOp_clearMemoryPool ( );
void SgMultiplyOp_extendMemoryPoolForFileIO ( );
unsigned long SgMultiplyOp_initializeStorageClassArray( SgMultiplyOpStorageClass *storageArray );
void SgMultiplyOp_resetValidFreepointers( );
unsigned long SgMultiplyOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDivideOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDivideOp* SgDivideOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDivideOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDivideOp* SgDivideOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDivideOp* SgDivideOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDivideOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDivideOp_clearMemoryPool ( );
void SgDivideOp_extendMemoryPoolForFileIO ( );
unsigned long SgDivideOp_initializeStorageClassArray( SgDivideOpStorageClass *storageArray );
void SgDivideOp_resetValidFreepointers( );
unsigned long SgDivideOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIntegerDivideOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIntegerDivideOp* SgIntegerDivideOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIntegerDivideOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIntegerDivideOp* SgIntegerDivideOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIntegerDivideOp* SgIntegerDivideOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIntegerDivideOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIntegerDivideOp_clearMemoryPool ( );
void SgIntegerDivideOp_extendMemoryPoolForFileIO ( );
unsigned long SgIntegerDivideOp_initializeStorageClassArray( SgIntegerDivideOpStorageClass *storageArray );
void SgIntegerDivideOp_resetValidFreepointers( );
unsigned long SgIntegerDivideOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModOp* SgModOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModOp* SgModOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModOp* SgModOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModOp_clearMemoryPool ( );
void SgModOp_extendMemoryPoolForFileIO ( );
unsigned long SgModOp_initializeStorageClassArray( SgModOpStorageClass *storageArray );
void SgModOp_resetValidFreepointers( );
unsigned long SgModOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAndOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAndOp* SgAndOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAndOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAndOp* SgAndOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAndOp* SgAndOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAndOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAndOp_clearMemoryPool ( );
void SgAndOp_extendMemoryPoolForFileIO ( );
unsigned long SgAndOp_initializeStorageClassArray( SgAndOpStorageClass *storageArray );
void SgAndOp_resetValidFreepointers( );
unsigned long SgAndOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgOrOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgOrOp* SgOrOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgOrOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgOrOp* SgOrOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgOrOp* SgOrOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgOrOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgOrOp_clearMemoryPool ( );
void SgOrOp_extendMemoryPoolForFileIO ( );
unsigned long SgOrOp_initializeStorageClassArray( SgOrOpStorageClass *storageArray );
void SgOrOp_resetValidFreepointers( );
unsigned long SgOrOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitXorOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitXorOp* SgBitXorOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitXorOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitXorOp* SgBitXorOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitXorOp* SgBitXorOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitXorOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitXorOp_clearMemoryPool ( );
void SgBitXorOp_extendMemoryPoolForFileIO ( );
unsigned long SgBitXorOp_initializeStorageClassArray( SgBitXorOpStorageClass *storageArray );
void SgBitXorOp_resetValidFreepointers( );
unsigned long SgBitXorOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitAndOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitAndOp* SgBitAndOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitAndOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitAndOp* SgBitAndOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitAndOp* SgBitAndOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitAndOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitAndOp_clearMemoryPool ( );
void SgBitAndOp_extendMemoryPoolForFileIO ( );
unsigned long SgBitAndOp_initializeStorageClassArray( SgBitAndOpStorageClass *storageArray );
void SgBitAndOp_resetValidFreepointers( );
unsigned long SgBitAndOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitOrOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitOrOp* SgBitOrOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitOrOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitOrOp* SgBitOrOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitOrOp* SgBitOrOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitOrOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitOrOp_clearMemoryPool ( );
void SgBitOrOp_extendMemoryPoolForFileIO ( );
unsigned long SgBitOrOp_initializeStorageClassArray( SgBitOrOpStorageClass *storageArray );
void SgBitOrOp_resetValidFreepointers( );
unsigned long SgBitOrOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBitEqvOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBitEqvOp* SgBitEqvOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBitEqvOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBitEqvOp* SgBitEqvOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBitEqvOp* SgBitEqvOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBitEqvOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBitEqvOp_clearMemoryPool ( );
void SgBitEqvOp_extendMemoryPoolForFileIO ( );
unsigned long SgBitEqvOp_initializeStorageClassArray( SgBitEqvOpStorageClass *storageArray );
void SgBitEqvOp_resetValidFreepointers( );
unsigned long SgBitEqvOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCommaOpExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCommaOpExp* SgCommaOpExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCommaOpExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCommaOpExp* SgCommaOpExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCommaOpExp* SgCommaOpExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCommaOpExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCommaOpExp_clearMemoryPool ( );
void SgCommaOpExp_extendMemoryPoolForFileIO ( );
unsigned long SgCommaOpExp_initializeStorageClassArray( SgCommaOpExpStorageClass *storageArray );
void SgCommaOpExp_resetValidFreepointers( );
unsigned long SgCommaOpExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLshiftOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLshiftOp* SgLshiftOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLshiftOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLshiftOp* SgLshiftOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLshiftOp* SgLshiftOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLshiftOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLshiftOp_clearMemoryPool ( );
void SgLshiftOp_extendMemoryPoolForFileIO ( );
unsigned long SgLshiftOp_initializeStorageClassArray( SgLshiftOpStorageClass *storageArray );
void SgLshiftOp_resetValidFreepointers( );
unsigned long SgLshiftOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRshiftOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRshiftOp* SgRshiftOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRshiftOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRshiftOp* SgRshiftOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRshiftOp* SgRshiftOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRshiftOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRshiftOp_clearMemoryPool ( );
void SgRshiftOp_extendMemoryPoolForFileIO ( );
unsigned long SgRshiftOp_initializeStorageClassArray( SgRshiftOpStorageClass *storageArray );
void SgRshiftOp_resetValidFreepointers( );
unsigned long SgRshiftOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPntrArrRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPntrArrRefExp* SgPntrArrRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPntrArrRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPntrArrRefExp* SgPntrArrRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPntrArrRefExp* SgPntrArrRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPntrArrRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPntrArrRefExp_clearMemoryPool ( );
void SgPntrArrRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgPntrArrRefExp_initializeStorageClassArray( SgPntrArrRefExpStorageClass *storageArray );
void SgPntrArrRefExp_resetValidFreepointers( );
unsigned long SgPntrArrRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgScopeOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgScopeOp* SgScopeOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgScopeOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgScopeOp* SgScopeOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgScopeOp* SgScopeOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgScopeOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgScopeOp_clearMemoryPool ( );
void SgScopeOp_extendMemoryPoolForFileIO ( );
unsigned long SgScopeOp_initializeStorageClassArray( SgScopeOpStorageClass *storageArray );
void SgScopeOp_resetValidFreepointers( );
unsigned long SgScopeOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssignOp* SgAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssignOp* SgAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssignOp* SgAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssignOp_clearMemoryPool ( );
void SgAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgAssignOp_initializeStorageClassArray( SgAssignOpStorageClass *storageArray );
void SgAssignOp_resetValidFreepointers( );
unsigned long SgAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExponentiationOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExponentiationOp* SgExponentiationOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExponentiationOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExponentiationOp* SgExponentiationOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExponentiationOp* SgExponentiationOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExponentiationOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExponentiationOp_clearMemoryPool ( );
void SgExponentiationOp_extendMemoryPoolForFileIO ( );
unsigned long SgExponentiationOp_initializeStorageClassArray( SgExponentiationOpStorageClass *storageArray );
void SgExponentiationOp_resetValidFreepointers( );
unsigned long SgExponentiationOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaUnsignedRshiftOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaUnsignedRshiftOp* SgJavaUnsignedRshiftOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaUnsignedRshiftOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaUnsignedRshiftOp* SgJavaUnsignedRshiftOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaUnsignedRshiftOp* SgJavaUnsignedRshiftOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaUnsignedRshiftOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaUnsignedRshiftOp_clearMemoryPool ( );
void SgJavaUnsignedRshiftOp_extendMemoryPoolForFileIO ( );
unsigned long SgJavaUnsignedRshiftOp_initializeStorageClassArray( SgJavaUnsignedRshiftOpStorageClass *storageArray );
void SgJavaUnsignedRshiftOp_resetValidFreepointers( );
unsigned long SgJavaUnsignedRshiftOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgConcatenationOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgConcatenationOp* SgConcatenationOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgConcatenationOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgConcatenationOp* SgConcatenationOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgConcatenationOp* SgConcatenationOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgConcatenationOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgConcatenationOp_clearMemoryPool ( );
void SgConcatenationOp_extendMemoryPoolForFileIO ( );
unsigned long SgConcatenationOp_initializeStorageClassArray( SgConcatenationOpStorageClass *storageArray );
void SgConcatenationOp_resetValidFreepointers( );
unsigned long SgConcatenationOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPointerAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPointerAssignOp* SgPointerAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPointerAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPointerAssignOp* SgPointerAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPointerAssignOp* SgPointerAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPointerAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPointerAssignOp_clearMemoryPool ( );
void SgPointerAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgPointerAssignOp_initializeStorageClassArray( SgPointerAssignOpStorageClass *storageArray );
void SgPointerAssignOp_resetValidFreepointers( );
unsigned long SgPointerAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUserDefinedBinaryOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUserDefinedBinaryOp* SgUserDefinedBinaryOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUserDefinedBinaryOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUserDefinedBinaryOp* SgUserDefinedBinaryOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUserDefinedBinaryOp* SgUserDefinedBinaryOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUserDefinedBinaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUserDefinedBinaryOp_clearMemoryPool ( );
void SgUserDefinedBinaryOp_extendMemoryPoolForFileIO ( );
unsigned long SgUserDefinedBinaryOp_initializeStorageClassArray( SgUserDefinedBinaryOpStorageClass *storageArray );
void SgUserDefinedBinaryOp_resetValidFreepointers( );
unsigned long SgUserDefinedBinaryOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCompoundAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCompoundAssignOp* SgCompoundAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCompoundAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCompoundAssignOp* SgCompoundAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCompoundAssignOp* SgCompoundAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCompoundAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCompoundAssignOp_clearMemoryPool ( );
void SgCompoundAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgCompoundAssignOp_initializeStorageClassArray( SgCompoundAssignOpStorageClass *storageArray );
void SgCompoundAssignOp_resetValidFreepointers( );
unsigned long SgCompoundAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPlusAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPlusAssignOp* SgPlusAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPlusAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPlusAssignOp* SgPlusAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPlusAssignOp* SgPlusAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPlusAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPlusAssignOp_clearMemoryPool ( );
void SgPlusAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgPlusAssignOp_initializeStorageClassArray( SgPlusAssignOpStorageClass *storageArray );
void SgPlusAssignOp_resetValidFreepointers( );
unsigned long SgPlusAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMinusAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMinusAssignOp* SgMinusAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMinusAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMinusAssignOp* SgMinusAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMinusAssignOp* SgMinusAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMinusAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMinusAssignOp_clearMemoryPool ( );
void SgMinusAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgMinusAssignOp_initializeStorageClassArray( SgMinusAssignOpStorageClass *storageArray );
void SgMinusAssignOp_resetValidFreepointers( );
unsigned long SgMinusAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAndAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAndAssignOp* SgAndAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAndAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAndAssignOp* SgAndAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAndAssignOp* SgAndAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAndAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAndAssignOp_clearMemoryPool ( );
void SgAndAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgAndAssignOp_initializeStorageClassArray( SgAndAssignOpStorageClass *storageArray );
void SgAndAssignOp_resetValidFreepointers( );
unsigned long SgAndAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIorAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIorAssignOp* SgIorAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIorAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIorAssignOp* SgIorAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIorAssignOp* SgIorAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIorAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIorAssignOp_clearMemoryPool ( );
void SgIorAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgIorAssignOp_initializeStorageClassArray( SgIorAssignOpStorageClass *storageArray );
void SgIorAssignOp_resetValidFreepointers( );
unsigned long SgIorAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMultAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMultAssignOp* SgMultAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMultAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMultAssignOp* SgMultAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMultAssignOp* SgMultAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMultAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMultAssignOp_clearMemoryPool ( );
void SgMultAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgMultAssignOp_initializeStorageClassArray( SgMultAssignOpStorageClass *storageArray );
void SgMultAssignOp_resetValidFreepointers( );
unsigned long SgMultAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDivAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDivAssignOp* SgDivAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDivAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDivAssignOp* SgDivAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDivAssignOp* SgDivAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDivAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDivAssignOp_clearMemoryPool ( );
void SgDivAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgDivAssignOp_initializeStorageClassArray( SgDivAssignOpStorageClass *storageArray );
void SgDivAssignOp_resetValidFreepointers( );
unsigned long SgDivAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModAssignOp* SgModAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModAssignOp* SgModAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModAssignOp* SgModAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModAssignOp_clearMemoryPool ( );
void SgModAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgModAssignOp_initializeStorageClassArray( SgModAssignOpStorageClass *storageArray );
void SgModAssignOp_resetValidFreepointers( );
unsigned long SgModAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgXorAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgXorAssignOp* SgXorAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgXorAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgXorAssignOp* SgXorAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgXorAssignOp* SgXorAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgXorAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgXorAssignOp_clearMemoryPool ( );
void SgXorAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgXorAssignOp_initializeStorageClassArray( SgXorAssignOpStorageClass *storageArray );
void SgXorAssignOp_resetValidFreepointers( );
unsigned long SgXorAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLshiftAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLshiftAssignOp* SgLshiftAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLshiftAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLshiftAssignOp* SgLshiftAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLshiftAssignOp* SgLshiftAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLshiftAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLshiftAssignOp_clearMemoryPool ( );
void SgLshiftAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgLshiftAssignOp_initializeStorageClassArray( SgLshiftAssignOpStorageClass *storageArray );
void SgLshiftAssignOp_resetValidFreepointers( );
unsigned long SgLshiftAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRshiftAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRshiftAssignOp* SgRshiftAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRshiftAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRshiftAssignOp* SgRshiftAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRshiftAssignOp* SgRshiftAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRshiftAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRshiftAssignOp_clearMemoryPool ( );
void SgRshiftAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgRshiftAssignOp_initializeStorageClassArray( SgRshiftAssignOpStorageClass *storageArray );
void SgRshiftAssignOp_resetValidFreepointers( );
unsigned long SgRshiftAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaUnsignedRshiftAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaUnsignedRshiftAssignOp* SgJavaUnsignedRshiftAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaUnsignedRshiftAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaUnsignedRshiftAssignOp* SgJavaUnsignedRshiftAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaUnsignedRshiftAssignOp* SgJavaUnsignedRshiftAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaUnsignedRshiftAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaUnsignedRshiftAssignOp_clearMemoryPool ( );
void SgJavaUnsignedRshiftAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgJavaUnsignedRshiftAssignOp_initializeStorageClassArray( SgJavaUnsignedRshiftAssignOpStorageClass *storageArray );
void SgJavaUnsignedRshiftAssignOp_resetValidFreepointers( );
unsigned long SgJavaUnsignedRshiftAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIntegerDivideAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIntegerDivideAssignOp* SgIntegerDivideAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIntegerDivideAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIntegerDivideAssignOp* SgIntegerDivideAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIntegerDivideAssignOp* SgIntegerDivideAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIntegerDivideAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIntegerDivideAssignOp_clearMemoryPool ( );
void SgIntegerDivideAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgIntegerDivideAssignOp_initializeStorageClassArray( SgIntegerDivideAssignOpStorageClass *storageArray );
void SgIntegerDivideAssignOp_resetValidFreepointers( );
unsigned long SgIntegerDivideAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExponentiationAssignOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExponentiationAssignOp* SgExponentiationAssignOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExponentiationAssignOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExponentiationAssignOp* SgExponentiationAssignOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExponentiationAssignOp* SgExponentiationAssignOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExponentiationAssignOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExponentiationAssignOp_clearMemoryPool ( );
void SgExponentiationAssignOp_extendMemoryPoolForFileIO ( );
unsigned long SgExponentiationAssignOp_initializeStorageClassArray( SgExponentiationAssignOpStorageClass *storageArray );
void SgExponentiationAssignOp_resetValidFreepointers( );
unsigned long SgExponentiationAssignOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMembershipOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMembershipOp* SgMembershipOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMembershipOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMembershipOp* SgMembershipOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMembershipOp* SgMembershipOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMembershipOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMembershipOp_clearMemoryPool ( );
void SgMembershipOp_extendMemoryPoolForFileIO ( );
unsigned long SgMembershipOp_initializeStorageClassArray( SgMembershipOpStorageClass *storageArray );
void SgMembershipOp_resetValidFreepointers( );
unsigned long SgMembershipOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSpaceshipOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSpaceshipOp* SgSpaceshipOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSpaceshipOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSpaceshipOp* SgSpaceshipOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSpaceshipOp* SgSpaceshipOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSpaceshipOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSpaceshipOp_clearMemoryPool ( );
void SgSpaceshipOp_extendMemoryPoolForFileIO ( );
unsigned long SgSpaceshipOp_initializeStorageClassArray( SgSpaceshipOpStorageClass *storageArray );
void SgSpaceshipOp_resetValidFreepointers( );
unsigned long SgSpaceshipOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNonMembershipOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNonMembershipOp* SgNonMembershipOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNonMembershipOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNonMembershipOp* SgNonMembershipOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNonMembershipOp* SgNonMembershipOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNonMembershipOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNonMembershipOp_clearMemoryPool ( );
void SgNonMembershipOp_extendMemoryPoolForFileIO ( );
unsigned long SgNonMembershipOp_initializeStorageClassArray( SgNonMembershipOpStorageClass *storageArray );
void SgNonMembershipOp_resetValidFreepointers( );
unsigned long SgNonMembershipOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIsOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIsOp* SgIsOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIsOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIsOp* SgIsOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIsOp* SgIsOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIsOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIsOp_clearMemoryPool ( );
void SgIsOp_extendMemoryPoolForFileIO ( );
unsigned long SgIsOp_initializeStorageClassArray( SgIsOpStorageClass *storageArray );
void SgIsOp_resetValidFreepointers( );
unsigned long SgIsOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIsNotOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIsNotOp* SgIsNotOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIsNotOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIsNotOp* SgIsNotOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIsNotOp* SgIsNotOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIsNotOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIsNotOp_clearMemoryPool ( );
void SgIsNotOp_extendMemoryPoolForFileIO ( );
unsigned long SgIsNotOp_initializeStorageClassArray( SgIsNotOpStorageClass *storageArray );
void SgIsNotOp_resetValidFreepointers( );
unsigned long SgIsNotOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDotDotExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDotDotExp* SgDotDotExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDotDotExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDotDotExp* SgDotDotExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDotDotExp* SgDotDotExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDotDotExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDotDotExp_clearMemoryPool ( );
void SgDotDotExp_extendMemoryPoolForFileIO ( );
unsigned long SgDotDotExp_initializeStorageClassArray( SgDotDotExpStorageClass *storageArray );
void SgDotDotExp_resetValidFreepointers( );
unsigned long SgDotDotExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElementwiseOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElementwiseOp* SgElementwiseOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElementwiseOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElementwiseOp* SgElementwiseOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElementwiseOp* SgElementwiseOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElementwiseOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElementwiseOp_clearMemoryPool ( );
void SgElementwiseOp_extendMemoryPoolForFileIO ( );
unsigned long SgElementwiseOp_initializeStorageClassArray( SgElementwiseOpStorageClass *storageArray );
void SgElementwiseOp_resetValidFreepointers( );
unsigned long SgElementwiseOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElementwiseMultiplyOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElementwiseMultiplyOp* SgElementwiseMultiplyOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElementwiseMultiplyOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElementwiseMultiplyOp* SgElementwiseMultiplyOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElementwiseMultiplyOp* SgElementwiseMultiplyOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElementwiseMultiplyOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElementwiseMultiplyOp_clearMemoryPool ( );
void SgElementwiseMultiplyOp_extendMemoryPoolForFileIO ( );
unsigned long SgElementwiseMultiplyOp_initializeStorageClassArray( SgElementwiseMultiplyOpStorageClass *storageArray );
void SgElementwiseMultiplyOp_resetValidFreepointers( );
unsigned long SgElementwiseMultiplyOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElementwisePowerOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElementwisePowerOp* SgElementwisePowerOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElementwisePowerOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElementwisePowerOp* SgElementwisePowerOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElementwisePowerOp* SgElementwisePowerOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElementwisePowerOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElementwisePowerOp_clearMemoryPool ( );
void SgElementwisePowerOp_extendMemoryPoolForFileIO ( );
unsigned long SgElementwisePowerOp_initializeStorageClassArray( SgElementwisePowerOpStorageClass *storageArray );
void SgElementwisePowerOp_resetValidFreepointers( );
unsigned long SgElementwisePowerOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElementwiseLeftDivideOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElementwiseLeftDivideOp* SgElementwiseLeftDivideOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElementwiseLeftDivideOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElementwiseLeftDivideOp* SgElementwiseLeftDivideOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElementwiseLeftDivideOp* SgElementwiseLeftDivideOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElementwiseLeftDivideOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElementwiseLeftDivideOp_clearMemoryPool ( );
void SgElementwiseLeftDivideOp_extendMemoryPoolForFileIO ( );
unsigned long SgElementwiseLeftDivideOp_initializeStorageClassArray( SgElementwiseLeftDivideOpStorageClass *storageArray );
void SgElementwiseLeftDivideOp_resetValidFreepointers( );
unsigned long SgElementwiseLeftDivideOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElementwiseDivideOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElementwiseDivideOp* SgElementwiseDivideOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElementwiseDivideOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElementwiseDivideOp* SgElementwiseDivideOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElementwiseDivideOp* SgElementwiseDivideOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElementwiseDivideOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElementwiseDivideOp_clearMemoryPool ( );
void SgElementwiseDivideOp_extendMemoryPoolForFileIO ( );
unsigned long SgElementwiseDivideOp_initializeStorageClassArray( SgElementwiseDivideOpStorageClass *storageArray );
void SgElementwiseDivideOp_resetValidFreepointers( );
unsigned long SgElementwiseDivideOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElementwiseAddOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElementwiseAddOp* SgElementwiseAddOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElementwiseAddOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElementwiseAddOp* SgElementwiseAddOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElementwiseAddOp* SgElementwiseAddOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElementwiseAddOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElementwiseAddOp_clearMemoryPool ( );
void SgElementwiseAddOp_extendMemoryPoolForFileIO ( );
unsigned long SgElementwiseAddOp_initializeStorageClassArray( SgElementwiseAddOpStorageClass *storageArray );
void SgElementwiseAddOp_resetValidFreepointers( );
unsigned long SgElementwiseAddOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgElementwiseSubtractOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgElementwiseSubtractOp* SgElementwiseSubtractOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgElementwiseSubtractOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgElementwiseSubtractOp* SgElementwiseSubtractOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgElementwiseSubtractOp* SgElementwiseSubtractOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgElementwiseSubtractOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgElementwiseSubtractOp_clearMemoryPool ( );
void SgElementwiseSubtractOp_extendMemoryPoolForFileIO ( );
unsigned long SgElementwiseSubtractOp_initializeStorageClassArray( SgElementwiseSubtractOpStorageClass *storageArray );
void SgElementwiseSubtractOp_resetValidFreepointers( );
unsigned long SgElementwiseSubtractOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPowerOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPowerOp* SgPowerOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPowerOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPowerOp* SgPowerOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPowerOp* SgPowerOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPowerOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPowerOp_clearMemoryPool ( );
void SgPowerOp_extendMemoryPoolForFileIO ( );
unsigned long SgPowerOp_initializeStorageClassArray( SgPowerOpStorageClass *storageArray );
void SgPowerOp_resetValidFreepointers( );
unsigned long SgPowerOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLeftDivideOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLeftDivideOp* SgLeftDivideOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLeftDivideOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLeftDivideOp* SgLeftDivideOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLeftDivideOp* SgLeftDivideOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLeftDivideOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLeftDivideOp_clearMemoryPool ( );
void SgLeftDivideOp_extendMemoryPoolForFileIO ( );
unsigned long SgLeftDivideOp_initializeStorageClassArray( SgLeftDivideOpStorageClass *storageArray );
void SgLeftDivideOp_resetValidFreepointers( );
unsigned long SgLeftDivideOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRemOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRemOp* SgRemOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRemOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRemOp* SgRemOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRemOp* SgRemOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRemOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRemOp_clearMemoryPool ( );
void SgRemOp_extendMemoryPoolForFileIO ( );
unsigned long SgRemOp_initializeStorageClassArray( SgRemOpStorageClass *storageArray );
void SgRemOp_resetValidFreepointers( );
unsigned long SgRemOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgReplicationOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgReplicationOp* SgReplicationOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgReplicationOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgReplicationOp* SgReplicationOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgReplicationOp* SgReplicationOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgReplicationOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgReplicationOp_clearMemoryPool ( );
void SgReplicationOp_extendMemoryPoolForFileIO ( );
unsigned long SgReplicationOp_initializeStorageClassArray( SgReplicationOpStorageClass *storageArray );
void SgReplicationOp_resetValidFreepointers( );
unsigned long SgReplicationOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAtOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAtOp* SgAtOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAtOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAtOp* SgAtOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAtOp* SgAtOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAtOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAtOp_clearMemoryPool ( );
void SgAtOp_extendMemoryPoolForFileIO ( );
unsigned long SgAtOp_initializeStorageClassArray( SgAtOpStorageClass *storageArray );
void SgAtOp_resetValidFreepointers( );
unsigned long SgAtOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgExprListExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgExprListExp* SgExprListExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgExprListExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgExprListExp* SgExprListExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgExprListExp* SgExprListExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgExprListExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgExprListExp_clearMemoryPool ( );
void SgExprListExp_extendMemoryPoolForFileIO ( );
unsigned long SgExprListExp_initializeStorageClassArray( SgExprListExpStorageClass *storageArray );
void SgExprListExp_resetValidFreepointers( );
unsigned long SgExprListExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgListExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgListExp* SgListExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgListExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgListExp* SgListExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgListExp* SgListExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgListExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgListExp_clearMemoryPool ( );
void SgListExp_extendMemoryPoolForFileIO ( );
unsigned long SgListExp_initializeStorageClassArray( SgListExpStorageClass *storageArray );
void SgListExp_resetValidFreepointers( );
unsigned long SgListExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTupleExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTupleExp* SgTupleExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTupleExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTupleExp* SgTupleExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTupleExp* SgTupleExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTupleExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTupleExp_clearMemoryPool ( );
void SgTupleExp_extendMemoryPoolForFileIO ( );
unsigned long SgTupleExp_initializeStorageClassArray( SgTupleExpStorageClass *storageArray );
void SgTupleExp_resetValidFreepointers( );
unsigned long SgTupleExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMatrixExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMatrixExp* SgMatrixExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMatrixExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMatrixExp* SgMatrixExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMatrixExp* SgMatrixExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMatrixExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMatrixExp_clearMemoryPool ( );
void SgMatrixExp_extendMemoryPoolForFileIO ( );
unsigned long SgMatrixExp_initializeStorageClassArray( SgMatrixExpStorageClass *storageArray );
void SgMatrixExp_resetValidFreepointers( );
unsigned long SgMatrixExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarRefExp* SgVarRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarRefExp* SgVarRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarRefExp* SgVarRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarRefExp_clearMemoryPool ( );
void SgVarRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgVarRefExp_initializeStorageClassArray( SgVarRefExpStorageClass *storageArray );
void SgVarRefExp_resetValidFreepointers( );
unsigned long SgVarRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassNameRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassNameRefExp* SgClassNameRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassNameRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassNameRefExp* SgClassNameRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassNameRefExp* SgClassNameRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassNameRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassNameRefExp_clearMemoryPool ( );
void SgClassNameRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgClassNameRefExp_initializeStorageClassArray( SgClassNameRefExpStorageClass *storageArray );
void SgClassNameRefExp_resetValidFreepointers( );
unsigned long SgClassNameRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionRefExp* SgFunctionRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionRefExp* SgFunctionRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionRefExp* SgFunctionRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionRefExp_clearMemoryPool ( );
void SgFunctionRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionRefExp_initializeStorageClassArray( SgFunctionRefExpStorageClass *storageArray );
void SgFunctionRefExp_resetValidFreepointers( );
unsigned long SgFunctionRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMemberFunctionRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMemberFunctionRefExp* SgMemberFunctionRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMemberFunctionRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMemberFunctionRefExp* SgMemberFunctionRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMemberFunctionRefExp* SgMemberFunctionRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMemberFunctionRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMemberFunctionRefExp_clearMemoryPool ( );
void SgMemberFunctionRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgMemberFunctionRefExp_initializeStorageClassArray( SgMemberFunctionRefExpStorageClass *storageArray );
void SgMemberFunctionRefExp_resetValidFreepointers( );
unsigned long SgMemberFunctionRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgValueExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgValueExp* SgValueExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgValueExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgValueExp* SgValueExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgValueExp* SgValueExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgValueExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgValueExp_clearMemoryPool ( );
void SgValueExp_extendMemoryPoolForFileIO ( );
unsigned long SgValueExp_initializeStorageClassArray( SgValueExpStorageClass *storageArray );
void SgValueExp_resetValidFreepointers( );
unsigned long SgValueExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBoolValExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBoolValExp* SgBoolValExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBoolValExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBoolValExp* SgBoolValExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBoolValExp* SgBoolValExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBoolValExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBoolValExp_clearMemoryPool ( );
void SgBoolValExp_extendMemoryPoolForFileIO ( );
unsigned long SgBoolValExp_initializeStorageClassArray( SgBoolValExpStorageClass *storageArray );
void SgBoolValExp_resetValidFreepointers( );
unsigned long SgBoolValExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStringVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStringVal* SgStringVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStringVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStringVal* SgStringVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStringVal* SgStringVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStringVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStringVal_clearMemoryPool ( );
void SgStringVal_extendMemoryPoolForFileIO ( );
unsigned long SgStringVal_initializeStorageClassArray( SgStringValStorageClass *storageArray );
void SgStringVal_resetValidFreepointers( );
unsigned long SgStringVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgShortVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgShortVal* SgShortVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgShortVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgShortVal* SgShortVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgShortVal* SgShortVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgShortVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgShortVal_clearMemoryPool ( );
void SgShortVal_extendMemoryPoolForFileIO ( );
unsigned long SgShortVal_initializeStorageClassArray( SgShortValStorageClass *storageArray );
void SgShortVal_resetValidFreepointers( );
unsigned long SgShortVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCharVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCharVal* SgCharVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCharVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCharVal* SgCharVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCharVal* SgCharVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCharVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCharVal_clearMemoryPool ( );
void SgCharVal_extendMemoryPoolForFileIO ( );
unsigned long SgCharVal_initializeStorageClassArray( SgCharValStorageClass *storageArray );
void SgCharVal_resetValidFreepointers( );
unsigned long SgCharVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnsignedCharVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnsignedCharVal* SgUnsignedCharVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnsignedCharVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnsignedCharVal* SgUnsignedCharVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnsignedCharVal* SgUnsignedCharVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnsignedCharVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnsignedCharVal_clearMemoryPool ( );
void SgUnsignedCharVal_extendMemoryPoolForFileIO ( );
unsigned long SgUnsignedCharVal_initializeStorageClassArray( SgUnsignedCharValStorageClass *storageArray );
void SgUnsignedCharVal_resetValidFreepointers( );
unsigned long SgUnsignedCharVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgWcharVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgWcharVal* SgWcharVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgWcharVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgWcharVal* SgWcharVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgWcharVal* SgWcharVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgWcharVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgWcharVal_clearMemoryPool ( );
void SgWcharVal_extendMemoryPoolForFileIO ( );
unsigned long SgWcharVal_initializeStorageClassArray( SgWcharValStorageClass *storageArray );
void SgWcharVal_resetValidFreepointers( );
unsigned long SgWcharVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnsignedShortVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnsignedShortVal* SgUnsignedShortVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnsignedShortVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnsignedShortVal* SgUnsignedShortVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnsignedShortVal* SgUnsignedShortVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnsignedShortVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnsignedShortVal_clearMemoryPool ( );
void SgUnsignedShortVal_extendMemoryPoolForFileIO ( );
unsigned long SgUnsignedShortVal_initializeStorageClassArray( SgUnsignedShortValStorageClass *storageArray );
void SgUnsignedShortVal_resetValidFreepointers( );
unsigned long SgUnsignedShortVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIntVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIntVal* SgIntVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIntVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIntVal* SgIntVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIntVal* SgIntVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIntVal_clearMemoryPool ( );
void SgIntVal_extendMemoryPoolForFileIO ( );
unsigned long SgIntVal_initializeStorageClassArray( SgIntValStorageClass *storageArray );
void SgIntVal_resetValidFreepointers( );
unsigned long SgIntVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEnumVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEnumVal* SgEnumVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEnumVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEnumVal* SgEnumVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEnumVal* SgEnumVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEnumVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEnumVal_clearMemoryPool ( );
void SgEnumVal_extendMemoryPoolForFileIO ( );
unsigned long SgEnumVal_initializeStorageClassArray( SgEnumValStorageClass *storageArray );
void SgEnumVal_resetValidFreepointers( );
unsigned long SgEnumVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnsignedIntVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnsignedIntVal* SgUnsignedIntVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnsignedIntVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnsignedIntVal* SgUnsignedIntVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnsignedIntVal* SgUnsignedIntVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnsignedIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnsignedIntVal_clearMemoryPool ( );
void SgUnsignedIntVal_extendMemoryPoolForFileIO ( );
unsigned long SgUnsignedIntVal_initializeStorageClassArray( SgUnsignedIntValStorageClass *storageArray );
void SgUnsignedIntVal_resetValidFreepointers( );
unsigned long SgUnsignedIntVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLongIntVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLongIntVal* SgLongIntVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLongIntVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLongIntVal* SgLongIntVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLongIntVal* SgLongIntVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLongIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLongIntVal_clearMemoryPool ( );
void SgLongIntVal_extendMemoryPoolForFileIO ( );
unsigned long SgLongIntVal_initializeStorageClassArray( SgLongIntValStorageClass *storageArray );
void SgLongIntVal_resetValidFreepointers( );
unsigned long SgLongIntVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLongLongIntVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLongLongIntVal* SgLongLongIntVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLongLongIntVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLongLongIntVal* SgLongLongIntVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLongLongIntVal* SgLongLongIntVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLongLongIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLongLongIntVal_clearMemoryPool ( );
void SgLongLongIntVal_extendMemoryPoolForFileIO ( );
unsigned long SgLongLongIntVal_initializeStorageClassArray( SgLongLongIntValStorageClass *storageArray );
void SgLongLongIntVal_resetValidFreepointers( );
unsigned long SgLongLongIntVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnsignedLongLongIntVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnsignedLongLongIntVal* SgUnsignedLongLongIntVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnsignedLongLongIntVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnsignedLongLongIntVal* SgUnsignedLongLongIntVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnsignedLongLongIntVal* SgUnsignedLongLongIntVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnsignedLongLongIntVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnsignedLongLongIntVal_clearMemoryPool ( );
void SgUnsignedLongLongIntVal_extendMemoryPoolForFileIO ( );
unsigned long SgUnsignedLongLongIntVal_initializeStorageClassArray( SgUnsignedLongLongIntValStorageClass *storageArray );
void SgUnsignedLongLongIntVal_resetValidFreepointers( );
unsigned long SgUnsignedLongLongIntVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnsignedLongVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnsignedLongVal* SgUnsignedLongVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnsignedLongVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnsignedLongVal* SgUnsignedLongVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnsignedLongVal* SgUnsignedLongVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnsignedLongVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnsignedLongVal_clearMemoryPool ( );
void SgUnsignedLongVal_extendMemoryPoolForFileIO ( );
unsigned long SgUnsignedLongVal_initializeStorageClassArray( SgUnsignedLongValStorageClass *storageArray );
void SgUnsignedLongVal_resetValidFreepointers( );
unsigned long SgUnsignedLongVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFloatVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFloatVal* SgFloatVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFloatVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFloatVal* SgFloatVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFloatVal* SgFloatVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFloatVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFloatVal_clearMemoryPool ( );
void SgFloatVal_extendMemoryPoolForFileIO ( );
unsigned long SgFloatVal_initializeStorageClassArray( SgFloatValStorageClass *storageArray );
void SgFloatVal_resetValidFreepointers( );
unsigned long SgFloatVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDoubleVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDoubleVal* SgDoubleVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDoubleVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDoubleVal* SgDoubleVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDoubleVal* SgDoubleVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDoubleVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDoubleVal_clearMemoryPool ( );
void SgDoubleVal_extendMemoryPoolForFileIO ( );
unsigned long SgDoubleVal_initializeStorageClassArray( SgDoubleValStorageClass *storageArray );
void SgDoubleVal_resetValidFreepointers( );
unsigned long SgDoubleVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLongDoubleVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLongDoubleVal* SgLongDoubleVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLongDoubleVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLongDoubleVal* SgLongDoubleVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLongDoubleVal* SgLongDoubleVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLongDoubleVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLongDoubleVal_clearMemoryPool ( );
void SgLongDoubleVal_extendMemoryPoolForFileIO ( );
unsigned long SgLongDoubleVal_initializeStorageClassArray( SgLongDoubleValStorageClass *storageArray );
void SgLongDoubleVal_resetValidFreepointers( );
unsigned long SgLongDoubleVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgComplexVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgComplexVal* SgComplexVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgComplexVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgComplexVal* SgComplexVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgComplexVal* SgComplexVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgComplexVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgComplexVal_clearMemoryPool ( );
void SgComplexVal_extendMemoryPoolForFileIO ( );
unsigned long SgComplexVal_initializeStorageClassArray( SgComplexValStorageClass *storageArray );
void SgComplexVal_resetValidFreepointers( );
unsigned long SgComplexVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcThreads_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcThreads* SgUpcThreads_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcThreads_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcThreads* SgUpcThreads_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcThreads* SgUpcThreads_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcThreads_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcThreads_clearMemoryPool ( );
void SgUpcThreads_extendMemoryPoolForFileIO ( );
unsigned long SgUpcThreads_initializeStorageClassArray( SgUpcThreadsStorageClass *storageArray );
void SgUpcThreads_resetValidFreepointers( );
unsigned long SgUpcThreads_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcMythread_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcMythread* SgUpcMythread_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcMythread_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcMythread* SgUpcMythread_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcMythread* SgUpcMythread_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcMythread_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcMythread_clearMemoryPool ( );
void SgUpcMythread_extendMemoryPoolForFileIO ( );
unsigned long SgUpcMythread_initializeStorageClassArray( SgUpcMythreadStorageClass *storageArray );
void SgUpcMythread_resetValidFreepointers( );
unsigned long SgUpcMythread_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateParameterVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateParameterVal* SgTemplateParameterVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateParameterVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateParameterVal* SgTemplateParameterVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateParameterVal* SgTemplateParameterVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateParameterVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateParameterVal_clearMemoryPool ( );
void SgTemplateParameterVal_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateParameterVal_initializeStorageClassArray( SgTemplateParameterValStorageClass *storageArray );
void SgTemplateParameterVal_resetValidFreepointers( );
unsigned long SgTemplateParameterVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNullptrValExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNullptrValExp* SgNullptrValExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNullptrValExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNullptrValExp* SgNullptrValExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNullptrValExp* SgNullptrValExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNullptrValExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNullptrValExp_clearMemoryPool ( );
void SgNullptrValExp_extendMemoryPoolForFileIO ( );
unsigned long SgNullptrValExp_initializeStorageClassArray( SgNullptrValExpStorageClass *storageArray );
void SgNullptrValExp_resetValidFreepointers( );
unsigned long SgNullptrValExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgChar16Val_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgChar16Val* SgChar16Val_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgChar16Val_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgChar16Val* SgChar16Val_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgChar16Val* SgChar16Val_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgChar16Val_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgChar16Val_clearMemoryPool ( );
void SgChar16Val_extendMemoryPoolForFileIO ( );
unsigned long SgChar16Val_initializeStorageClassArray( SgChar16ValStorageClass *storageArray );
void SgChar16Val_resetValidFreepointers( );
unsigned long SgChar16Val_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgChar32Val_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgChar32Val* SgChar32Val_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgChar32Val_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgChar32Val* SgChar32Val_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgChar32Val* SgChar32Val_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgChar32Val_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgChar32Val_clearMemoryPool ( );
void SgChar32Val_extendMemoryPoolForFileIO ( );
unsigned long SgChar32Val_initializeStorageClassArray( SgChar32ValStorageClass *storageArray );
void SgChar32Val_resetValidFreepointers( );
unsigned long SgChar32Val_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFloat80Val_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFloat80Val* SgFloat80Val_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFloat80Val_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFloat80Val* SgFloat80Val_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFloat80Val* SgFloat80Val_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFloat80Val_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFloat80Val_clearMemoryPool ( );
void SgFloat80Val_extendMemoryPoolForFileIO ( );
unsigned long SgFloat80Val_initializeStorageClassArray( SgFloat80ValStorageClass *storageArray );
void SgFloat80Val_resetValidFreepointers( );
unsigned long SgFloat80Val_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFloat128Val_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFloat128Val* SgFloat128Val_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFloat128Val_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFloat128Val* SgFloat128Val_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFloat128Val* SgFloat128Val_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFloat128Val_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFloat128Val_clearMemoryPool ( );
void SgFloat128Val_extendMemoryPoolForFileIO ( );
unsigned long SgFloat128Val_initializeStorageClassArray( SgFloat128ValStorageClass *storageArray );
void SgFloat128Val_resetValidFreepointers( );
unsigned long SgFloat128Val_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVoidVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVoidVal* SgVoidVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVoidVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVoidVal* SgVoidVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVoidVal* SgVoidVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVoidVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVoidVal_clearMemoryPool ( );
void SgVoidVal_extendMemoryPoolForFileIO ( );
unsigned long SgVoidVal_initializeStorageClassArray( SgVoidValStorageClass *storageArray );
void SgVoidVal_resetValidFreepointers( );
unsigned long SgVoidVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaFloatVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaFloatVal* SgAdaFloatVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaFloatVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaFloatVal* SgAdaFloatVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaFloatVal* SgAdaFloatVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaFloatVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaFloatVal_clearMemoryPool ( );
void SgAdaFloatVal_extendMemoryPoolForFileIO ( );
unsigned long SgAdaFloatVal_initializeStorageClassArray( SgAdaFloatValStorageClass *storageArray );
void SgAdaFloatVal_resetValidFreepointers( );
unsigned long SgAdaFloatVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJovialBitVal_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJovialBitVal* SgJovialBitVal_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJovialBitVal_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJovialBitVal* SgJovialBitVal_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJovialBitVal* SgJovialBitVal_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJovialBitVal_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJovialBitVal_clearMemoryPool ( );
void SgJovialBitVal_extendMemoryPoolForFileIO ( );
unsigned long SgJovialBitVal_initializeStorageClassArray( SgJovialBitValStorageClass *storageArray );
void SgJovialBitVal_resetValidFreepointers( );
unsigned long SgJovialBitVal_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCallExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCallExpression* SgCallExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCallExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCallExpression* SgCallExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCallExpression* SgCallExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCallExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCallExpression_clearMemoryPool ( );
void SgCallExpression_extendMemoryPoolForFileIO ( );
unsigned long SgCallExpression_initializeStorageClassArray( SgCallExpressionStorageClass *storageArray );
void SgCallExpression_resetValidFreepointers( );
unsigned long SgCallExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionCallExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionCallExp* SgFunctionCallExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionCallExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionCallExp* SgFunctionCallExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionCallExp* SgFunctionCallExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionCallExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionCallExp_clearMemoryPool ( );
void SgFunctionCallExp_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionCallExp_initializeStorageClassArray( SgFunctionCallExpStorageClass *storageArray );
void SgFunctionCallExp_resetValidFreepointers( );
unsigned long SgFunctionCallExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCudaKernelCallExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCudaKernelCallExp* SgCudaKernelCallExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCudaKernelCallExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCudaKernelCallExp* SgCudaKernelCallExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCudaKernelCallExp* SgCudaKernelCallExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCudaKernelCallExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCudaKernelCallExp_clearMemoryPool ( );
void SgCudaKernelCallExp_extendMemoryPoolForFileIO ( );
unsigned long SgCudaKernelCallExp_initializeStorageClassArray( SgCudaKernelCallExpStorageClass *storageArray );
void SgCudaKernelCallExp_resetValidFreepointers( );
unsigned long SgCudaKernelCallExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSizeOfOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSizeOfOp* SgSizeOfOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSizeOfOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSizeOfOp* SgSizeOfOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSizeOfOp* SgSizeOfOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSizeOfOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSizeOfOp_clearMemoryPool ( );
void SgSizeOfOp_extendMemoryPoolForFileIO ( );
unsigned long SgSizeOfOp_initializeStorageClassArray( SgSizeOfOpStorageClass *storageArray );
void SgSizeOfOp_resetValidFreepointers( );
unsigned long SgSizeOfOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcLocalsizeofExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcLocalsizeofExpression* SgUpcLocalsizeofExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcLocalsizeofExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcLocalsizeofExpression* SgUpcLocalsizeofExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcLocalsizeofExpression* SgUpcLocalsizeofExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcLocalsizeofExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcLocalsizeofExpression_clearMemoryPool ( );
void SgUpcLocalsizeofExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUpcLocalsizeofExpression_initializeStorageClassArray( SgUpcLocalsizeofExpressionStorageClass *storageArray );
void SgUpcLocalsizeofExpression_resetValidFreepointers( );
unsigned long SgUpcLocalsizeofExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcBlocksizeofExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcBlocksizeofExpression* SgUpcBlocksizeofExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcBlocksizeofExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcBlocksizeofExpression* SgUpcBlocksizeofExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcBlocksizeofExpression* SgUpcBlocksizeofExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcBlocksizeofExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcBlocksizeofExpression_clearMemoryPool ( );
void SgUpcBlocksizeofExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUpcBlocksizeofExpression_initializeStorageClassArray( SgUpcBlocksizeofExpressionStorageClass *storageArray );
void SgUpcBlocksizeofExpression_resetValidFreepointers( );
unsigned long SgUpcBlocksizeofExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUpcElemsizeofExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUpcElemsizeofExpression* SgUpcElemsizeofExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUpcElemsizeofExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUpcElemsizeofExpression* SgUpcElemsizeofExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUpcElemsizeofExpression* SgUpcElemsizeofExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUpcElemsizeofExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUpcElemsizeofExpression_clearMemoryPool ( );
void SgUpcElemsizeofExpression_extendMemoryPoolForFileIO ( );
unsigned long SgUpcElemsizeofExpression_initializeStorageClassArray( SgUpcElemsizeofExpressionStorageClass *storageArray );
void SgUpcElemsizeofExpression_resetValidFreepointers( );
unsigned long SgUpcElemsizeofExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaInstanceOfOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaInstanceOfOp* SgJavaInstanceOfOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaInstanceOfOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaInstanceOfOp* SgJavaInstanceOfOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaInstanceOfOp* SgJavaInstanceOfOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaInstanceOfOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaInstanceOfOp_clearMemoryPool ( );
void SgJavaInstanceOfOp_extendMemoryPoolForFileIO ( );
unsigned long SgJavaInstanceOfOp_initializeStorageClassArray( SgJavaInstanceOfOpStorageClass *storageArray );
void SgJavaInstanceOfOp_resetValidFreepointers( );
unsigned long SgJavaInstanceOfOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSuperExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSuperExp* SgSuperExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSuperExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSuperExp* SgSuperExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSuperExp* SgSuperExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSuperExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSuperExp_clearMemoryPool ( );
void SgSuperExp_extendMemoryPoolForFileIO ( );
unsigned long SgSuperExp_initializeStorageClassArray( SgSuperExpStorageClass *storageArray );
void SgSuperExp_resetValidFreepointers( );
unsigned long SgSuperExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeIdOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeIdOp* SgTypeIdOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeIdOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeIdOp* SgTypeIdOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeIdOp* SgTypeIdOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeIdOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeIdOp_clearMemoryPool ( );
void SgTypeIdOp_extendMemoryPoolForFileIO ( );
unsigned long SgTypeIdOp_initializeStorageClassArray( SgTypeIdOpStorageClass *storageArray );
void SgTypeIdOp_resetValidFreepointers( );
unsigned long SgTypeIdOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgConditionalExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgConditionalExp* SgConditionalExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgConditionalExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgConditionalExp* SgConditionalExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgConditionalExp* SgConditionalExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgConditionalExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgConditionalExp_clearMemoryPool ( );
void SgConditionalExp_extendMemoryPoolForFileIO ( );
unsigned long SgConditionalExp_initializeStorageClassArray( SgConditionalExpStorageClass *storageArray );
void SgConditionalExp_resetValidFreepointers( );
unsigned long SgConditionalExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNewExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNewExp* SgNewExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNewExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNewExp* SgNewExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNewExp* SgNewExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNewExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNewExp_clearMemoryPool ( );
void SgNewExp_extendMemoryPoolForFileIO ( );
unsigned long SgNewExp_initializeStorageClassArray( SgNewExpStorageClass *storageArray );
void SgNewExp_resetValidFreepointers( );
unsigned long SgNewExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDeleteExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDeleteExp* SgDeleteExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDeleteExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDeleteExp* SgDeleteExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDeleteExp* SgDeleteExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDeleteExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDeleteExp_clearMemoryPool ( );
void SgDeleteExp_extendMemoryPoolForFileIO ( );
unsigned long SgDeleteExp_initializeStorageClassArray( SgDeleteExpStorageClass *storageArray );
void SgDeleteExp_resetValidFreepointers( );
unsigned long SgDeleteExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgThisExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgThisExp* SgThisExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgThisExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgThisExp* SgThisExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgThisExp* SgThisExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgThisExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgThisExp_clearMemoryPool ( );
void SgThisExp_extendMemoryPoolForFileIO ( );
unsigned long SgThisExp_initializeStorageClassArray( SgThisExpStorageClass *storageArray );
void SgThisExp_resetValidFreepointers( );
unsigned long SgThisExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRefExp* SgRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRefExp* SgRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRefExp* SgRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRefExp_clearMemoryPool ( );
void SgRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgRefExp_initializeStorageClassArray( SgRefExpStorageClass *storageArray );
void SgRefExp_resetValidFreepointers( );
unsigned long SgRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInitializer* SgInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInitializer* SgInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInitializer* SgInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInitializer_clearMemoryPool ( );
void SgInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgInitializer_initializeStorageClassArray( SgInitializerStorageClass *storageArray );
void SgInitializer_resetValidFreepointers( );
unsigned long SgInitializer_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAggregateInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAggregateInitializer* SgAggregateInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAggregateInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAggregateInitializer* SgAggregateInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAggregateInitializer* SgAggregateInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAggregateInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAggregateInitializer_clearMemoryPool ( );
void SgAggregateInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgAggregateInitializer_initializeStorageClassArray( SgAggregateInitializerStorageClass *storageArray );
void SgAggregateInitializer_resetValidFreepointers( );
unsigned long SgAggregateInitializer_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCompoundInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCompoundInitializer* SgCompoundInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCompoundInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCompoundInitializer* SgCompoundInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCompoundInitializer* SgCompoundInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCompoundInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCompoundInitializer_clearMemoryPool ( );
void SgCompoundInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgCompoundInitializer_initializeStorageClassArray( SgCompoundInitializerStorageClass *storageArray );
void SgCompoundInitializer_resetValidFreepointers( );
unsigned long SgCompoundInitializer_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgConstructorInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgConstructorInitializer* SgConstructorInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgConstructorInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgConstructorInitializer* SgConstructorInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgConstructorInitializer* SgConstructorInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgConstructorInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgConstructorInitializer_clearMemoryPool ( );
void SgConstructorInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgConstructorInitializer_initializeStorageClassArray( SgConstructorInitializerStorageClass *storageArray );
void SgConstructorInitializer_resetValidFreepointers( );
unsigned long SgConstructorInitializer_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAssignInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAssignInitializer* SgAssignInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAssignInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAssignInitializer* SgAssignInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAssignInitializer* SgAssignInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAssignInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAssignInitializer_clearMemoryPool ( );
void SgAssignInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgAssignInitializer_initializeStorageClassArray( SgAssignInitializerStorageClass *storageArray );
void SgAssignInitializer_resetValidFreepointers( );
unsigned long SgAssignInitializer_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDesignatedInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDesignatedInitializer* SgDesignatedInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDesignatedInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDesignatedInitializer* SgDesignatedInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDesignatedInitializer* SgDesignatedInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDesignatedInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDesignatedInitializer_clearMemoryPool ( );
void SgDesignatedInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgDesignatedInitializer_initializeStorageClassArray( SgDesignatedInitializerStorageClass *storageArray );
void SgDesignatedInitializer_resetValidFreepointers( );
unsigned long SgDesignatedInitializer_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgBracedInitializer_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgBracedInitializer* SgBracedInitializer_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgBracedInitializer_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgBracedInitializer* SgBracedInitializer_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgBracedInitializer* SgBracedInitializer_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgBracedInitializer_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgBracedInitializer_clearMemoryPool ( );
void SgBracedInitializer_extendMemoryPoolForFileIO ( );
unsigned long SgBracedInitializer_initializeStorageClassArray( SgBracedInitializerStorageClass *storageArray );
void SgBracedInitializer_resetValidFreepointers( );
unsigned long SgBracedInitializer_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarArgStartOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarArgStartOp* SgVarArgStartOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarArgStartOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarArgStartOp* SgVarArgStartOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarArgStartOp* SgVarArgStartOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarArgStartOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarArgStartOp_clearMemoryPool ( );
void SgVarArgStartOp_extendMemoryPoolForFileIO ( );
unsigned long SgVarArgStartOp_initializeStorageClassArray( SgVarArgStartOpStorageClass *storageArray );
void SgVarArgStartOp_resetValidFreepointers( );
unsigned long SgVarArgStartOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarArgOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarArgOp* SgVarArgOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarArgOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarArgOp* SgVarArgOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarArgOp* SgVarArgOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarArgOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarArgOp_clearMemoryPool ( );
void SgVarArgOp_extendMemoryPoolForFileIO ( );
unsigned long SgVarArgOp_initializeStorageClassArray( SgVarArgOpStorageClass *storageArray );
void SgVarArgOp_resetValidFreepointers( );
unsigned long SgVarArgOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarArgEndOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarArgEndOp* SgVarArgEndOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarArgEndOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarArgEndOp* SgVarArgEndOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarArgEndOp* SgVarArgEndOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarArgEndOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarArgEndOp_clearMemoryPool ( );
void SgVarArgEndOp_extendMemoryPoolForFileIO ( );
unsigned long SgVarArgEndOp_initializeStorageClassArray( SgVarArgEndOpStorageClass *storageArray );
void SgVarArgEndOp_resetValidFreepointers( );
unsigned long SgVarArgEndOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarArgCopyOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarArgCopyOp* SgVarArgCopyOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarArgCopyOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarArgCopyOp* SgVarArgCopyOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarArgCopyOp* SgVarArgCopyOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarArgCopyOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarArgCopyOp_clearMemoryPool ( );
void SgVarArgCopyOp_extendMemoryPoolForFileIO ( );
unsigned long SgVarArgCopyOp_initializeStorageClassArray( SgVarArgCopyOpStorageClass *storageArray );
void SgVarArgCopyOp_resetValidFreepointers( );
unsigned long SgVarArgCopyOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVarArgStartOneOperandOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVarArgStartOneOperandOp* SgVarArgStartOneOperandOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVarArgStartOneOperandOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVarArgStartOneOperandOp* SgVarArgStartOneOperandOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVarArgStartOneOperandOp* SgVarArgStartOneOperandOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVarArgStartOneOperandOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVarArgStartOneOperandOp_clearMemoryPool ( );
void SgVarArgStartOneOperandOp_extendMemoryPoolForFileIO ( );
unsigned long SgVarArgStartOneOperandOp_initializeStorageClassArray( SgVarArgStartOneOperandOpStorageClass *storageArray );
void SgVarArgStartOneOperandOp_resetValidFreepointers( );
unsigned long SgVarArgStartOneOperandOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNullExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNullExpression* SgNullExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNullExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNullExpression* SgNullExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNullExpression* SgNullExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNullExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNullExpression_clearMemoryPool ( );
void SgNullExpression_extendMemoryPoolForFileIO ( );
unsigned long SgNullExpression_initializeStorageClassArray( SgNullExpressionStorageClass *storageArray );
void SgNullExpression_resetValidFreepointers( );
unsigned long SgNullExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVariantExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVariantExpression* SgVariantExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVariantExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVariantExpression* SgVariantExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVariantExpression* SgVariantExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVariantExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVariantExpression_clearMemoryPool ( );
void SgVariantExpression_extendMemoryPoolForFileIO ( );
unsigned long SgVariantExpression_initializeStorageClassArray( SgVariantExpressionStorageClass *storageArray );
void SgVariantExpression_resetValidFreepointers( );
unsigned long SgVariantExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSubscriptExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSubscriptExpression* SgSubscriptExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSubscriptExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSubscriptExpression* SgSubscriptExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSubscriptExpression* SgSubscriptExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSubscriptExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSubscriptExpression_clearMemoryPool ( );
void SgSubscriptExpression_extendMemoryPoolForFileIO ( );
unsigned long SgSubscriptExpression_initializeStorageClassArray( SgSubscriptExpressionStorageClass *storageArray );
void SgSubscriptExpression_resetValidFreepointers( );
unsigned long SgSubscriptExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgColonShapeExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgColonShapeExp* SgColonShapeExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgColonShapeExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgColonShapeExp* SgColonShapeExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgColonShapeExp* SgColonShapeExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgColonShapeExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgColonShapeExp_clearMemoryPool ( );
void SgColonShapeExp_extendMemoryPoolForFileIO ( );
unsigned long SgColonShapeExp_initializeStorageClassArray( SgColonShapeExpStorageClass *storageArray );
void SgColonShapeExp_resetValidFreepointers( );
unsigned long SgColonShapeExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsteriskShapeExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsteriskShapeExp* SgAsteriskShapeExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsteriskShapeExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsteriskShapeExp* SgAsteriskShapeExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsteriskShapeExp* SgAsteriskShapeExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsteriskShapeExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsteriskShapeExp_clearMemoryPool ( );
void SgAsteriskShapeExp_extendMemoryPoolForFileIO ( );
unsigned long SgAsteriskShapeExp_initializeStorageClassArray( SgAsteriskShapeExpStorageClass *storageArray );
void SgAsteriskShapeExp_resetValidFreepointers( );
unsigned long SgAsteriskShapeExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgImpliedDo_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgImpliedDo* SgImpliedDo_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgImpliedDo_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgImpliedDo* SgImpliedDo_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgImpliedDo* SgImpliedDo_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgImpliedDo_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgImpliedDo_clearMemoryPool ( );
void SgImpliedDo_extendMemoryPoolForFileIO ( );
unsigned long SgImpliedDo_initializeStorageClassArray( SgImpliedDoStorageClass *storageArray );
void SgImpliedDo_resetValidFreepointers( );
unsigned long SgImpliedDo_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIOItemExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIOItemExpression* SgIOItemExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIOItemExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIOItemExpression* SgIOItemExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIOItemExpression* SgIOItemExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIOItemExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIOItemExpression_clearMemoryPool ( );
void SgIOItemExpression_extendMemoryPoolForFileIO ( );
unsigned long SgIOItemExpression_initializeStorageClassArray( SgIOItemExpressionStorageClass *storageArray );
void SgIOItemExpression_resetValidFreepointers( );
unsigned long SgIOItemExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStatementExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStatementExpression* SgStatementExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStatementExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStatementExpression* SgStatementExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStatementExpression* SgStatementExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStatementExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStatementExpression_clearMemoryPool ( );
void SgStatementExpression_extendMemoryPoolForFileIO ( );
unsigned long SgStatementExpression_initializeStorageClassArray( SgStatementExpressionStorageClass *storageArray );
void SgStatementExpression_resetValidFreepointers( );
unsigned long SgStatementExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAsmOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAsmOp* SgAsmOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAsmOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAsmOp* SgAsmOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAsmOp* SgAsmOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAsmOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAsmOp_clearMemoryPool ( );
void SgAsmOp_extendMemoryPoolForFileIO ( );
unsigned long SgAsmOp_initializeStorageClassArray( SgAsmOpStorageClass *storageArray );
void SgAsmOp_resetValidFreepointers( );
unsigned long SgAsmOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLabelRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLabelRefExp* SgLabelRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLabelRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLabelRefExp* SgLabelRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLabelRefExp* SgLabelRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLabelRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLabelRefExp_clearMemoryPool ( );
void SgLabelRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgLabelRefExp_initializeStorageClassArray( SgLabelRefExpStorageClass *storageArray );
void SgLabelRefExp_resetValidFreepointers( );
unsigned long SgLabelRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgActualArgumentExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgActualArgumentExpression* SgActualArgumentExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgActualArgumentExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgActualArgumentExpression* SgActualArgumentExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgActualArgumentExpression* SgActualArgumentExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgActualArgumentExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgActualArgumentExpression_clearMemoryPool ( );
void SgActualArgumentExpression_extendMemoryPoolForFileIO ( );
unsigned long SgActualArgumentExpression_initializeStorageClassArray( SgActualArgumentExpressionStorageClass *storageArray );
void SgActualArgumentExpression_resetValidFreepointers( );
unsigned long SgActualArgumentExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgUnknownArrayOrFunctionReference_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgUnknownArrayOrFunctionReference* SgUnknownArrayOrFunctionReference_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgUnknownArrayOrFunctionReference_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgUnknownArrayOrFunctionReference* SgUnknownArrayOrFunctionReference_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgUnknownArrayOrFunctionReference* SgUnknownArrayOrFunctionReference_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgUnknownArrayOrFunctionReference_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgUnknownArrayOrFunctionReference_clearMemoryPool ( );
void SgUnknownArrayOrFunctionReference_extendMemoryPoolForFileIO ( );
unsigned long SgUnknownArrayOrFunctionReference_initializeStorageClassArray( SgUnknownArrayOrFunctionReferenceStorageClass *storageArray );
void SgUnknownArrayOrFunctionReference_resetValidFreepointers( );
unsigned long SgUnknownArrayOrFunctionReference_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgPseudoDestructorRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgPseudoDestructorRefExp* SgPseudoDestructorRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgPseudoDestructorRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgPseudoDestructorRefExp* SgPseudoDestructorRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgPseudoDestructorRefExp* SgPseudoDestructorRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgPseudoDestructorRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgPseudoDestructorRefExp_clearMemoryPool ( );
void SgPseudoDestructorRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgPseudoDestructorRefExp_initializeStorageClassArray( SgPseudoDestructorRefExpStorageClass *storageArray );
void SgPseudoDestructorRefExp_resetValidFreepointers( );
unsigned long SgPseudoDestructorRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCAFCoExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCAFCoExpression* SgCAFCoExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCAFCoExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCAFCoExpression* SgCAFCoExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCAFCoExpression* SgCAFCoExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCAFCoExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCAFCoExpression_clearMemoryPool ( );
void SgCAFCoExpression_extendMemoryPoolForFileIO ( );
unsigned long SgCAFCoExpression_initializeStorageClassArray( SgCAFCoExpressionStorageClass *storageArray );
void SgCAFCoExpression_resetValidFreepointers( );
unsigned long SgCAFCoExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCudaKernelExecConfig_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCudaKernelExecConfig* SgCudaKernelExecConfig_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCudaKernelExecConfig_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCudaKernelExecConfig* SgCudaKernelExecConfig_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCudaKernelExecConfig* SgCudaKernelExecConfig_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCudaKernelExecConfig_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCudaKernelExecConfig_clearMemoryPool ( );
void SgCudaKernelExecConfig_extendMemoryPoolForFileIO ( );
unsigned long SgCudaKernelExecConfig_initializeStorageClassArray( SgCudaKernelExecConfigStorageClass *storageArray );
void SgCudaKernelExecConfig_resetValidFreepointers( );
unsigned long SgCudaKernelExecConfig_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLambdaRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLambdaRefExp* SgLambdaRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLambdaRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLambdaRefExp* SgLambdaRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLambdaRefExp* SgLambdaRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLambdaRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLambdaRefExp_clearMemoryPool ( );
void SgLambdaRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgLambdaRefExp_initializeStorageClassArray( SgLambdaRefExpStorageClass *storageArray );
void SgLambdaRefExp_resetValidFreepointers( );
unsigned long SgLambdaRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDictionaryExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDictionaryExp* SgDictionaryExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDictionaryExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDictionaryExp* SgDictionaryExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDictionaryExp* SgDictionaryExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDictionaryExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDictionaryExp_clearMemoryPool ( );
void SgDictionaryExp_extendMemoryPoolForFileIO ( );
unsigned long SgDictionaryExp_initializeStorageClassArray( SgDictionaryExpStorageClass *storageArray );
void SgDictionaryExp_resetValidFreepointers( );
unsigned long SgDictionaryExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgKeyDatumPair_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgKeyDatumPair* SgKeyDatumPair_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgKeyDatumPair_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgKeyDatumPair* SgKeyDatumPair_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgKeyDatumPair* SgKeyDatumPair_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgKeyDatumPair_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgKeyDatumPair_clearMemoryPool ( );
void SgKeyDatumPair_extendMemoryPoolForFileIO ( );
unsigned long SgKeyDatumPair_initializeStorageClassArray( SgKeyDatumPairStorageClass *storageArray );
void SgKeyDatumPair_resetValidFreepointers( );
unsigned long SgKeyDatumPair_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgComprehension_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgComprehension* SgComprehension_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgComprehension_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgComprehension* SgComprehension_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgComprehension* SgComprehension_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgComprehension_clearMemoryPool ( );
void SgComprehension_extendMemoryPoolForFileIO ( );
unsigned long SgComprehension_initializeStorageClassArray( SgComprehensionStorageClass *storageArray );
void SgComprehension_resetValidFreepointers( );
unsigned long SgComprehension_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgListComprehension_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgListComprehension* SgListComprehension_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgListComprehension_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgListComprehension* SgListComprehension_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgListComprehension* SgListComprehension_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgListComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgListComprehension_clearMemoryPool ( );
void SgListComprehension_extendMemoryPoolForFileIO ( );
unsigned long SgListComprehension_initializeStorageClassArray( SgListComprehensionStorageClass *storageArray );
void SgListComprehension_resetValidFreepointers( );
unsigned long SgListComprehension_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSetComprehension_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSetComprehension* SgSetComprehension_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSetComprehension_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSetComprehension* SgSetComprehension_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSetComprehension* SgSetComprehension_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSetComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSetComprehension_clearMemoryPool ( );
void SgSetComprehension_extendMemoryPoolForFileIO ( );
unsigned long SgSetComprehension_initializeStorageClassArray( SgSetComprehensionStorageClass *storageArray );
void SgSetComprehension_resetValidFreepointers( );
unsigned long SgSetComprehension_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDictionaryComprehension_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDictionaryComprehension* SgDictionaryComprehension_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDictionaryComprehension_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDictionaryComprehension* SgDictionaryComprehension_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDictionaryComprehension* SgDictionaryComprehension_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDictionaryComprehension_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDictionaryComprehension_clearMemoryPool ( );
void SgDictionaryComprehension_extendMemoryPoolForFileIO ( );
unsigned long SgDictionaryComprehension_initializeStorageClassArray( SgDictionaryComprehensionStorageClass *storageArray );
void SgDictionaryComprehension_resetValidFreepointers( );
unsigned long SgDictionaryComprehension_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNaryOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNaryOp* SgNaryOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNaryOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNaryOp* SgNaryOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNaryOp* SgNaryOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNaryOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNaryOp_clearMemoryPool ( );
void SgNaryOp_extendMemoryPoolForFileIO ( );
unsigned long SgNaryOp_initializeStorageClassArray( SgNaryOpStorageClass *storageArray );
void SgNaryOp_resetValidFreepointers( );
unsigned long SgNaryOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNaryBooleanOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNaryBooleanOp* SgNaryBooleanOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNaryBooleanOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNaryBooleanOp* SgNaryBooleanOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNaryBooleanOp* SgNaryBooleanOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNaryBooleanOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNaryBooleanOp_clearMemoryPool ( );
void SgNaryBooleanOp_extendMemoryPoolForFileIO ( );
unsigned long SgNaryBooleanOp_initializeStorageClassArray( SgNaryBooleanOpStorageClass *storageArray );
void SgNaryBooleanOp_resetValidFreepointers( );
unsigned long SgNaryBooleanOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNaryComparisonOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNaryComparisonOp* SgNaryComparisonOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNaryComparisonOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNaryComparisonOp* SgNaryComparisonOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNaryComparisonOp* SgNaryComparisonOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNaryComparisonOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNaryComparisonOp_clearMemoryPool ( );
void SgNaryComparisonOp_extendMemoryPoolForFileIO ( );
unsigned long SgNaryComparisonOp_initializeStorageClassArray( SgNaryComparisonOpStorageClass *storageArray );
void SgNaryComparisonOp_resetValidFreepointers( );
unsigned long SgNaryComparisonOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgStringConversion_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgStringConversion* SgStringConversion_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgStringConversion_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgStringConversion* SgStringConversion_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgStringConversion* SgStringConversion_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgStringConversion_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgStringConversion_clearMemoryPool ( );
void SgStringConversion_extendMemoryPoolForFileIO ( );
unsigned long SgStringConversion_initializeStorageClassArray( SgStringConversionStorageClass *storageArray );
void SgStringConversion_resetValidFreepointers( );
unsigned long SgStringConversion_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgYieldExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgYieldExpression* SgYieldExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgYieldExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgYieldExpression* SgYieldExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgYieldExpression* SgYieldExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgYieldExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgYieldExpression_clearMemoryPool ( );
void SgYieldExpression_extendMemoryPoolForFileIO ( );
unsigned long SgYieldExpression_initializeStorageClassArray( SgYieldExpressionStorageClass *storageArray );
void SgYieldExpression_resetValidFreepointers( );
unsigned long SgYieldExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateFunctionRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateFunctionRefExp* SgTemplateFunctionRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateFunctionRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateFunctionRefExp* SgTemplateFunctionRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateFunctionRefExp* SgTemplateFunctionRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateFunctionRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateFunctionRefExp_clearMemoryPool ( );
void SgTemplateFunctionRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateFunctionRefExp_initializeStorageClassArray( SgTemplateFunctionRefExpStorageClass *storageArray );
void SgTemplateFunctionRefExp_resetValidFreepointers( );
unsigned long SgTemplateFunctionRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateMemberFunctionRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateMemberFunctionRefExp* SgTemplateMemberFunctionRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateMemberFunctionRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateMemberFunctionRefExp* SgTemplateMemberFunctionRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateMemberFunctionRefExp* SgTemplateMemberFunctionRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateMemberFunctionRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateMemberFunctionRefExp_clearMemoryPool ( );
void SgTemplateMemberFunctionRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateMemberFunctionRefExp_initializeStorageClassArray( SgTemplateMemberFunctionRefExpStorageClass *storageArray );
void SgTemplateMemberFunctionRefExp_resetValidFreepointers( );
unsigned long SgTemplateMemberFunctionRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAlignOfOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAlignOfOp* SgAlignOfOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAlignOfOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAlignOfOp* SgAlignOfOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAlignOfOp* SgAlignOfOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAlignOfOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAlignOfOp_clearMemoryPool ( );
void SgAlignOfOp_extendMemoryPoolForFileIO ( );
unsigned long SgAlignOfOp_initializeStorageClassArray( SgAlignOfOpStorageClass *storageArray );
void SgAlignOfOp_resetValidFreepointers( );
unsigned long SgAlignOfOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRangeExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRangeExp* SgRangeExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRangeExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRangeExp* SgRangeExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRangeExp* SgRangeExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRangeExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRangeExp_clearMemoryPool ( );
void SgRangeExp_extendMemoryPoolForFileIO ( );
unsigned long SgRangeExp_initializeStorageClassArray( SgRangeExpStorageClass *storageArray );
void SgRangeExp_resetValidFreepointers( );
unsigned long SgRangeExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMagicColonExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMagicColonExp* SgMagicColonExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMagicColonExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMagicColonExp* SgMagicColonExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMagicColonExp* SgMagicColonExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMagicColonExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMagicColonExp_clearMemoryPool ( );
void SgMagicColonExp_extendMemoryPoolForFileIO ( );
unsigned long SgMagicColonExp_initializeStorageClassArray( SgMagicColonExpStorageClass *storageArray );
void SgMagicColonExp_resetValidFreepointers( );
unsigned long SgMagicColonExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeTraitBuiltinOperator_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeTraitBuiltinOperator* SgTypeTraitBuiltinOperator_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeTraitBuiltinOperator_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeTraitBuiltinOperator* SgTypeTraitBuiltinOperator_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeTraitBuiltinOperator* SgTypeTraitBuiltinOperator_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeTraitBuiltinOperator_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeTraitBuiltinOperator_clearMemoryPool ( );
void SgTypeTraitBuiltinOperator_extendMemoryPoolForFileIO ( );
unsigned long SgTypeTraitBuiltinOperator_initializeStorageClassArray( SgTypeTraitBuiltinOperatorStorageClass *storageArray );
void SgTypeTraitBuiltinOperator_resetValidFreepointers( );
unsigned long SgTypeTraitBuiltinOperator_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCompoundLiteralExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCompoundLiteralExp* SgCompoundLiteralExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCompoundLiteralExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCompoundLiteralExp* SgCompoundLiteralExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCompoundLiteralExp* SgCompoundLiteralExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCompoundLiteralExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCompoundLiteralExp_clearMemoryPool ( );
void SgCompoundLiteralExp_extendMemoryPoolForFileIO ( );
unsigned long SgCompoundLiteralExp_initializeStorageClassArray( SgCompoundLiteralExpStorageClass *storageArray );
void SgCompoundLiteralExp_resetValidFreepointers( );
unsigned long SgCompoundLiteralExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaAnnotation_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaAnnotation* SgJavaAnnotation_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaAnnotation_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaAnnotation* SgJavaAnnotation_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaAnnotation* SgJavaAnnotation_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaAnnotation_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaAnnotation_clearMemoryPool ( );
void SgJavaAnnotation_extendMemoryPoolForFileIO ( );
unsigned long SgJavaAnnotation_initializeStorageClassArray( SgJavaAnnotationStorageClass *storageArray );
void SgJavaAnnotation_resetValidFreepointers( );
unsigned long SgJavaAnnotation_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaMarkerAnnotation_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaMarkerAnnotation* SgJavaMarkerAnnotation_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaMarkerAnnotation_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaMarkerAnnotation* SgJavaMarkerAnnotation_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaMarkerAnnotation* SgJavaMarkerAnnotation_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaMarkerAnnotation_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaMarkerAnnotation_clearMemoryPool ( );
void SgJavaMarkerAnnotation_extendMemoryPoolForFileIO ( );
unsigned long SgJavaMarkerAnnotation_initializeStorageClassArray( SgJavaMarkerAnnotationStorageClass *storageArray );
void SgJavaMarkerAnnotation_resetValidFreepointers( );
unsigned long SgJavaMarkerAnnotation_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaSingleMemberAnnotation_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaSingleMemberAnnotation* SgJavaSingleMemberAnnotation_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaSingleMemberAnnotation_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaSingleMemberAnnotation* SgJavaSingleMemberAnnotation_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaSingleMemberAnnotation* SgJavaSingleMemberAnnotation_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaSingleMemberAnnotation_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaSingleMemberAnnotation_clearMemoryPool ( );
void SgJavaSingleMemberAnnotation_extendMemoryPoolForFileIO ( );
unsigned long SgJavaSingleMemberAnnotation_initializeStorageClassArray( SgJavaSingleMemberAnnotationStorageClass *storageArray );
void SgJavaSingleMemberAnnotation_resetValidFreepointers( );
unsigned long SgJavaSingleMemberAnnotation_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaNormalAnnotation_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaNormalAnnotation* SgJavaNormalAnnotation_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaNormalAnnotation_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaNormalAnnotation* SgJavaNormalAnnotation_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaNormalAnnotation* SgJavaNormalAnnotation_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaNormalAnnotation_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaNormalAnnotation_clearMemoryPool ( );
void SgJavaNormalAnnotation_extendMemoryPoolForFileIO ( );
unsigned long SgJavaNormalAnnotation_initializeStorageClassArray( SgJavaNormalAnnotationStorageClass *storageArray );
void SgJavaNormalAnnotation_resetValidFreepointers( );
unsigned long SgJavaNormalAnnotation_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaTypeExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaTypeExpression* SgJavaTypeExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaTypeExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaTypeExpression* SgJavaTypeExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaTypeExpression* SgJavaTypeExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaTypeExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaTypeExpression_clearMemoryPool ( );
void SgJavaTypeExpression_extendMemoryPoolForFileIO ( );
unsigned long SgJavaTypeExpression_initializeStorageClassArray( SgJavaTypeExpressionStorageClass *storageArray );
void SgJavaTypeExpression_resetValidFreepointers( );
unsigned long SgJavaTypeExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypeExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypeExpression* SgTypeExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypeExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypeExpression* SgTypeExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypeExpression* SgTypeExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypeExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypeExpression_clearMemoryPool ( );
void SgTypeExpression_extendMemoryPoolForFileIO ( );
unsigned long SgTypeExpression_initializeStorageClassArray( SgTypeExpressionStorageClass *storageArray );
void SgTypeExpression_resetValidFreepointers( );
unsigned long SgTypeExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassExp* SgClassExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassExp* SgClassExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassExp* SgClassExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassExp_clearMemoryPool ( );
void SgClassExp_extendMemoryPoolForFileIO ( );
unsigned long SgClassExp_initializeStorageClassArray( SgClassExpStorageClass *storageArray );
void SgClassExp_resetValidFreepointers( );
unsigned long SgClassExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionParameterRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionParameterRefExp* SgFunctionParameterRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionParameterRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionParameterRefExp* SgFunctionParameterRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionParameterRefExp* SgFunctionParameterRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionParameterRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionParameterRefExp_clearMemoryPool ( );
void SgFunctionParameterRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionParameterRefExp_initializeStorageClassArray( SgFunctionParameterRefExpStorageClass *storageArray );
void SgFunctionParameterRefExp_resetValidFreepointers( );
unsigned long SgFunctionParameterRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLambdaExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLambdaExp* SgLambdaExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLambdaExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLambdaExp* SgLambdaExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLambdaExp* SgLambdaExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLambdaExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLambdaExp_clearMemoryPool ( );
void SgLambdaExp_extendMemoryPoolForFileIO ( );
unsigned long SgLambdaExp_initializeStorageClassArray( SgLambdaExpStorageClass *storageArray );
void SgLambdaExp_resetValidFreepointers( );
unsigned long SgLambdaExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgHereExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgHereExp* SgHereExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgHereExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgHereExp* SgHereExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgHereExp* SgHereExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgHereExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgHereExp_clearMemoryPool ( );
void SgHereExp_extendMemoryPoolForFileIO ( );
unsigned long SgHereExp_initializeStorageClassArray( SgHereExpStorageClass *storageArray );
void SgHereExp_resetValidFreepointers( );
unsigned long SgHereExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAtExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAtExp* SgAtExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAtExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAtExp* SgAtExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAtExp* SgAtExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAtExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAtExp_clearMemoryPool ( );
void SgAtExp_extendMemoryPoolForFileIO ( );
unsigned long SgAtExp_initializeStorageClassArray( SgAtExpStorageClass *storageArray );
void SgAtExp_resetValidFreepointers( );
unsigned long SgAtExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFinishExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFinishExp* SgFinishExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFinishExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFinishExp* SgFinishExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFinishExp* SgFinishExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFinishExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFinishExp_clearMemoryPool ( );
void SgFinishExp_extendMemoryPoolForFileIO ( );
unsigned long SgFinishExp_initializeStorageClassArray( SgFinishExpStorageClass *storageArray );
void SgFinishExp_resetValidFreepointers( );
unsigned long SgFinishExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNoexceptOp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNoexceptOp* SgNoexceptOp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNoexceptOp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNoexceptOp* SgNoexceptOp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNoexceptOp* SgNoexceptOp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNoexceptOp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNoexceptOp_clearMemoryPool ( );
void SgNoexceptOp_extendMemoryPoolForFileIO ( );
unsigned long SgNoexceptOp_initializeStorageClassArray( SgNoexceptOpStorageClass *storageArray );
void SgNoexceptOp_resetValidFreepointers( );
unsigned long SgNoexceptOp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNonrealRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNonrealRefExp* SgNonrealRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNonrealRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNonrealRefExp* SgNonrealRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNonrealRefExp* SgNonrealRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNonrealRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNonrealRefExp_clearMemoryPool ( );
void SgNonrealRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgNonrealRefExp_initializeStorageClassArray( SgNonrealRefExpStorageClass *storageArray );
void SgNonrealRefExp_resetValidFreepointers( );
unsigned long SgNonrealRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaTaskRefExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaTaskRefExp* SgAdaTaskRefExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaTaskRefExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaTaskRefExp* SgAdaTaskRefExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaTaskRefExp* SgAdaTaskRefExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaTaskRefExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaTaskRefExp_clearMemoryPool ( );
void SgAdaTaskRefExp_extendMemoryPoolForFileIO ( );
unsigned long SgAdaTaskRefExp_initializeStorageClassArray( SgAdaTaskRefExpStorageClass *storageArray );
void SgAdaTaskRefExp_resetValidFreepointers( );
unsigned long SgAdaTaskRefExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFoldExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFoldExpression* SgFoldExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFoldExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFoldExpression* SgFoldExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFoldExpression* SgFoldExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFoldExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFoldExpression_clearMemoryPool ( );
void SgFoldExpression_extendMemoryPoolForFileIO ( );
unsigned long SgFoldExpression_initializeStorageClassArray( SgFoldExpressionStorageClass *storageArray );
void SgFoldExpression_resetValidFreepointers( );
unsigned long SgFoldExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAwaitExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAwaitExpression* SgAwaitExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAwaitExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAwaitExpression* SgAwaitExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAwaitExpression* SgAwaitExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAwaitExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAwaitExpression_clearMemoryPool ( );
void SgAwaitExpression_extendMemoryPoolForFileIO ( );
unsigned long SgAwaitExpression_initializeStorageClassArray( SgAwaitExpressionStorageClass *storageArray );
void SgAwaitExpression_resetValidFreepointers( );
unsigned long SgAwaitExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgChooseExpression_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgChooseExpression* SgChooseExpression_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgChooseExpression_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgChooseExpression* SgChooseExpression_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgChooseExpression* SgChooseExpression_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgChooseExpression_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgChooseExpression_clearMemoryPool ( );
void SgChooseExpression_extendMemoryPoolForFileIO ( );
unsigned long SgChooseExpression_initializeStorageClassArray( SgChooseExpressionStorageClass *storageArray );
void SgChooseExpression_resetValidFreepointers( );
unsigned long SgChooseExpression_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJovialTablePresetExp_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJovialTablePresetExp* SgJovialTablePresetExp_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJovialTablePresetExp_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJovialTablePresetExp* SgJovialTablePresetExp_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJovialTablePresetExp* SgJovialTablePresetExp_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJovialTablePresetExp_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJovialTablePresetExp_clearMemoryPool ( );
void SgJovialTablePresetExp_extendMemoryPoolForFileIO ( );
unsigned long SgJovialTablePresetExp_initializeStorageClassArray( SgJovialTablePresetExpStorageClass *storageArray );
void SgJovialTablePresetExp_resetValidFreepointers( );
unsigned long SgJovialTablePresetExp_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgSymbol* SgSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgSymbol* SgSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgSymbol* SgSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgSymbol_clearMemoryPool ( );
void SgSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgSymbol_initializeStorageClassArray( SgSymbolStorageClass *storageArray );
void SgSymbol_resetValidFreepointers( );
unsigned long SgSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgVariableSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgVariableSymbol* SgVariableSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgVariableSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgVariableSymbol* SgVariableSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgVariableSymbol* SgVariableSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgVariableSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgVariableSymbol_clearMemoryPool ( );
void SgVariableSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgVariableSymbol_initializeStorageClassArray( SgVariableSymbolStorageClass *storageArray );
void SgVariableSymbol_resetValidFreepointers( );
unsigned long SgVariableSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateVariableSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateVariableSymbol* SgTemplateVariableSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateVariableSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateVariableSymbol* SgTemplateVariableSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateVariableSymbol* SgTemplateVariableSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateVariableSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateVariableSymbol_clearMemoryPool ( );
void SgTemplateVariableSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateVariableSymbol_initializeStorageClassArray( SgTemplateVariableSymbolStorageClass *storageArray );
void SgTemplateVariableSymbol_resetValidFreepointers( );
unsigned long SgTemplateVariableSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNonrealSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNonrealSymbol* SgNonrealSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNonrealSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNonrealSymbol* SgNonrealSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNonrealSymbol* SgNonrealSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNonrealSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNonrealSymbol_clearMemoryPool ( );
void SgNonrealSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgNonrealSymbol_initializeStorageClassArray( SgNonrealSymbolStorageClass *storageArray );
void SgNonrealSymbol_resetValidFreepointers( );
unsigned long SgNonrealSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionSymbol* SgFunctionSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionSymbol* SgFunctionSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionSymbol* SgFunctionSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionSymbol_clearMemoryPool ( );
void SgFunctionSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionSymbol_initializeStorageClassArray( SgFunctionSymbolStorageClass *storageArray );
void SgFunctionSymbol_resetValidFreepointers( );
unsigned long SgFunctionSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgMemberFunctionSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgMemberFunctionSymbol* SgMemberFunctionSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgMemberFunctionSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgMemberFunctionSymbol* SgMemberFunctionSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgMemberFunctionSymbol* SgMemberFunctionSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgMemberFunctionSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgMemberFunctionSymbol_clearMemoryPool ( );
void SgMemberFunctionSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgMemberFunctionSymbol_initializeStorageClassArray( SgMemberFunctionSymbolStorageClass *storageArray );
void SgMemberFunctionSymbol_resetValidFreepointers( );
unsigned long SgMemberFunctionSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateMemberFunctionSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateMemberFunctionSymbol* SgTemplateMemberFunctionSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateMemberFunctionSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateMemberFunctionSymbol* SgTemplateMemberFunctionSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateMemberFunctionSymbol* SgTemplateMemberFunctionSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateMemberFunctionSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateMemberFunctionSymbol_clearMemoryPool ( );
void SgTemplateMemberFunctionSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateMemberFunctionSymbol_initializeStorageClassArray( SgTemplateMemberFunctionSymbolStorageClass *storageArray );
void SgTemplateMemberFunctionSymbol_resetValidFreepointers( );
unsigned long SgTemplateMemberFunctionSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateFunctionSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateFunctionSymbol* SgTemplateFunctionSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateFunctionSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateFunctionSymbol* SgTemplateFunctionSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateFunctionSymbol* SgTemplateFunctionSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateFunctionSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateFunctionSymbol_clearMemoryPool ( );
void SgTemplateFunctionSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateFunctionSymbol_initializeStorageClassArray( SgTemplateFunctionSymbolStorageClass *storageArray );
void SgTemplateFunctionSymbol_resetValidFreepointers( );
unsigned long SgTemplateFunctionSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgRenameSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgRenameSymbol* SgRenameSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgRenameSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgRenameSymbol* SgRenameSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgRenameSymbol* SgRenameSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgRenameSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgRenameSymbol_clearMemoryPool ( );
void SgRenameSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgRenameSymbol_initializeStorageClassArray( SgRenameSymbolStorageClass *storageArray );
void SgRenameSymbol_resetValidFreepointers( );
unsigned long SgRenameSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgFunctionTypeSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgFunctionTypeSymbol* SgFunctionTypeSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgFunctionTypeSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgFunctionTypeSymbol* SgFunctionTypeSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgFunctionTypeSymbol* SgFunctionTypeSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgFunctionTypeSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgFunctionTypeSymbol_clearMemoryPool ( );
void SgFunctionTypeSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgFunctionTypeSymbol_initializeStorageClassArray( SgFunctionTypeSymbolStorageClass *storageArray );
void SgFunctionTypeSymbol_resetValidFreepointers( );
unsigned long SgFunctionTypeSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgClassSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgClassSymbol* SgClassSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgClassSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgClassSymbol* SgClassSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgClassSymbol* SgClassSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgClassSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgClassSymbol_clearMemoryPool ( );
void SgClassSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgClassSymbol_initializeStorageClassArray( SgClassSymbolStorageClass *storageArray );
void SgClassSymbol_resetValidFreepointers( );
unsigned long SgClassSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateClassSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateClassSymbol* SgTemplateClassSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateClassSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateClassSymbol* SgTemplateClassSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateClassSymbol* SgTemplateClassSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateClassSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateClassSymbol_clearMemoryPool ( );
void SgTemplateClassSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateClassSymbol_initializeStorageClassArray( SgTemplateClassSymbolStorageClass *storageArray );
void SgTemplateClassSymbol_resetValidFreepointers( );
unsigned long SgTemplateClassSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateSymbol* SgTemplateSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateSymbol* SgTemplateSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateSymbol* SgTemplateSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateSymbol_clearMemoryPool ( );
void SgTemplateSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateSymbol_initializeStorageClassArray( SgTemplateSymbolStorageClass *storageArray );
void SgTemplateSymbol_resetValidFreepointers( );
unsigned long SgTemplateSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEnumSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEnumSymbol* SgEnumSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEnumSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEnumSymbol* SgEnumSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEnumSymbol* SgEnumSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEnumSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEnumSymbol_clearMemoryPool ( );
void SgEnumSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgEnumSymbol_initializeStorageClassArray( SgEnumSymbolStorageClass *storageArray );
void SgEnumSymbol_resetValidFreepointers( );
unsigned long SgEnumSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgEnumFieldSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgEnumFieldSymbol* SgEnumFieldSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgEnumFieldSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgEnumFieldSymbol* SgEnumFieldSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgEnumFieldSymbol* SgEnumFieldSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgEnumFieldSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgEnumFieldSymbol_clearMemoryPool ( );
void SgEnumFieldSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgEnumFieldSymbol_initializeStorageClassArray( SgEnumFieldSymbolStorageClass *storageArray );
void SgEnumFieldSymbol_resetValidFreepointers( );
unsigned long SgEnumFieldSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTypedefSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTypedefSymbol* SgTypedefSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTypedefSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTypedefSymbol* SgTypedefSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTypedefSymbol* SgTypedefSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTypedefSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTypedefSymbol_clearMemoryPool ( );
void SgTypedefSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgTypedefSymbol_initializeStorageClassArray( SgTypedefSymbolStorageClass *storageArray );
void SgTypedefSymbol_resetValidFreepointers( );
unsigned long SgTypedefSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgTemplateTypedefSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgTemplateTypedefSymbol* SgTemplateTypedefSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgTemplateTypedefSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgTemplateTypedefSymbol* SgTemplateTypedefSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgTemplateTypedefSymbol* SgTemplateTypedefSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgTemplateTypedefSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgTemplateTypedefSymbol_clearMemoryPool ( );
void SgTemplateTypedefSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgTemplateTypedefSymbol_initializeStorageClassArray( SgTemplateTypedefSymbolStorageClass *storageArray );
void SgTemplateTypedefSymbol_resetValidFreepointers( );
unsigned long SgTemplateTypedefSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgLabelSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgLabelSymbol* SgLabelSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgLabelSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgLabelSymbol* SgLabelSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgLabelSymbol* SgLabelSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgLabelSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgLabelSymbol_clearMemoryPool ( );
void SgLabelSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgLabelSymbol_initializeStorageClassArray( SgLabelSymbolStorageClass *storageArray );
void SgLabelSymbol_resetValidFreepointers( );
unsigned long SgLabelSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgDefaultSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgDefaultSymbol* SgDefaultSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgDefaultSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgDefaultSymbol* SgDefaultSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgDefaultSymbol* SgDefaultSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgDefaultSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgDefaultSymbol_clearMemoryPool ( );
void SgDefaultSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgDefaultSymbol_initializeStorageClassArray( SgDefaultSymbolStorageClass *storageArray );
void SgDefaultSymbol_resetValidFreepointers( );
unsigned long SgDefaultSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgNamespaceSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgNamespaceSymbol* SgNamespaceSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgNamespaceSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgNamespaceSymbol* SgNamespaceSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgNamespaceSymbol* SgNamespaceSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgNamespaceSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgNamespaceSymbol_clearMemoryPool ( );
void SgNamespaceSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgNamespaceSymbol_initializeStorageClassArray( SgNamespaceSymbolStorageClass *storageArray );
void SgNamespaceSymbol_resetValidFreepointers( );
unsigned long SgNamespaceSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgIntrinsicSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgIntrinsicSymbol* SgIntrinsicSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgIntrinsicSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgIntrinsicSymbol* SgIntrinsicSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgIntrinsicSymbol* SgIntrinsicSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgIntrinsicSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgIntrinsicSymbol_clearMemoryPool ( );
void SgIntrinsicSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgIntrinsicSymbol_initializeStorageClassArray( SgIntrinsicSymbolStorageClass *storageArray );
void SgIntrinsicSymbol_resetValidFreepointers( );
unsigned long SgIntrinsicSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgModuleSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgModuleSymbol* SgModuleSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgModuleSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgModuleSymbol* SgModuleSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgModuleSymbol* SgModuleSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgModuleSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgModuleSymbol_clearMemoryPool ( );
void SgModuleSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgModuleSymbol_initializeStorageClassArray( SgModuleSymbolStorageClass *storageArray );
void SgModuleSymbol_resetValidFreepointers( );
unsigned long SgModuleSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgInterfaceSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgInterfaceSymbol* SgInterfaceSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgInterfaceSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgInterfaceSymbol* SgInterfaceSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgInterfaceSymbol* SgInterfaceSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgInterfaceSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgInterfaceSymbol_clearMemoryPool ( );
void SgInterfaceSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgInterfaceSymbol_initializeStorageClassArray( SgInterfaceSymbolStorageClass *storageArray );
void SgInterfaceSymbol_resetValidFreepointers( );
unsigned long SgInterfaceSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgCommonSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgCommonSymbol* SgCommonSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgCommonSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgCommonSymbol* SgCommonSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgCommonSymbol* SgCommonSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgCommonSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgCommonSymbol_clearMemoryPool ( );
void SgCommonSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgCommonSymbol_initializeStorageClassArray( SgCommonSymbolStorageClass *storageArray );
void SgCommonSymbol_resetValidFreepointers( );
unsigned long SgCommonSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAliasSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAliasSymbol* SgAliasSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAliasSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAliasSymbol* SgAliasSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAliasSymbol* SgAliasSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAliasSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAliasSymbol_clearMemoryPool ( );
void SgAliasSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgAliasSymbol_initializeStorageClassArray( SgAliasSymbolStorageClass *storageArray );
void SgAliasSymbol_resetValidFreepointers( );
unsigned long SgAliasSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgJavaLabelSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgJavaLabelSymbol* SgJavaLabelSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgJavaLabelSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgJavaLabelSymbol* SgJavaLabelSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgJavaLabelSymbol* SgJavaLabelSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgJavaLabelSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgJavaLabelSymbol_clearMemoryPool ( );
void SgJavaLabelSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgJavaLabelSymbol_initializeStorageClassArray( SgJavaLabelSymbolStorageClass *storageArray );
void SgJavaLabelSymbol_resetValidFreepointers( );
unsigned long SgJavaLabelSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaPackageSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaPackageSymbol* SgAdaPackageSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaPackageSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaPackageSymbol* SgAdaPackageSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaPackageSymbol* SgAdaPackageSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaPackageSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaPackageSymbol_clearMemoryPool ( );
void SgAdaPackageSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgAdaPackageSymbol_initializeStorageClassArray( SgAdaPackageSymbolStorageClass *storageArray );
void SgAdaPackageSymbol_resetValidFreepointers( );
unsigned long SgAdaPackageSymbol_getNumberOfLastValidPointer();


/* #line 1 "/space/scratch/garyb/SCM/rose/src/ROSETTA/Grammar/grammarMemoryPoolSupport.macro" */

#include <semaphore.h>
// DQ (9/21/2005): Static variables supporting memory pools
/*! \brief \b FOR \b INTERNAL \b USE Number of objects allocated within each block of objects forming a memory pool for this IR node.

\internal This is part of the support for memory pools within ROSE.
     This can be removed and should be replaced by a function that evaluates to an increasing 
     value so that each block in a memory pool is larger than the last (e.g. factor of 2).
*/
extern int SgAdaTaskSymbol_CLASS_ALLOCATION_POOL_SIZE;        // = DEFAULT_CLASS_ALLOCATION_POOL_SIZE;

/*! \brief \b FOR \b INTERNAL \b USE Current object (within a block) which will be returned from the new operator

\internal This is part of the support for memory pools withn ROSE.
*/
extern SgAdaTaskSymbol* SgAdaTaskSymbol_Current_Link;              // = NULL;

// DQ (12/15/2005): This is Jochen's implementation of the memory allocation pools.
// This is was one of the things on the todo list (above).

/*! \brief \b FOR \b INTERNAL \b USE This is the STL vector containing the pointers to the blocks in an IR node's memory pool.

\internal This is part of the support for memory pools within ROSE.
*/
extern std::vector < unsigned char* > SgAdaTaskSymbol_Memory_Block_List;
/* */

// DQ (4/6/2006): Newer code from Jochen
// Methods to find the pointer to a global and local index
SgAdaTaskSymbol* SgAdaTaskSymbol_getPointerFromGlobalIndex ( unsigned long globalIndex ) ;
SgAdaTaskSymbol* SgAdaTaskSymbol_getPointerFromGlobalIndex ( AstSpecificDataManagingClass* astInPool, unsigned long globalIndex ) ;

// Methods for computing the total size of the memory pool. It actually returns the
// size of the whole blocks allocated, no matter they contain valid pointers or not
unsigned long SgAdaTaskSymbol_getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long );
void SgAdaTaskSymbol_clearMemoryPool ( );
void SgAdaTaskSymbol_extendMemoryPoolForFileIO ( );
unsigned long SgAdaTaskSymbol_initializeStorageClassArray( SgAdaTaskSymbolStorageClass *storageArray );
void SgAdaTaskSymbol_resetValidFreepointers( );
unsigned long SgAdaTaskSymbol_getNumberOfLastValidPointer();



